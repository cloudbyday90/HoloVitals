{'role': 'assistant', 'content': 'Now let me create the Subscription Management Service:\n\n<function_calls>\n<create-file file_path="medical-analysis-platform/lib/services/SubscriptionService.ts">\n/**\n * Subscription Management Service\n * \n * Handles subscription creation, upgrades, downgrades, and lifecycle management\n */\n\nimport { PrismaClient } from \'@prisma/client\';\nimport {\n  SubscriptionTier,\n  getTierConfig,\n  PRICING_RULES,\n} from \'../config/pricing\';\n\nconst prisma = new PrismaClient();\n\nexport interface SubscriptionCreateInput {\n  userId: string;\n  tier: SubscriptionTier;\n  paymentMethodId?: string;\n  trialPeriod?: boolean;\n}\n\nexport interface SubscriptionUpgradeInput {\n  userId: string;\n  newTier: SubscriptionTier;\n  immediate?: boolean; // Apply immediately or at next billing cycle\n}\n\nexport interface SubscriptionCancellationInput {\n  userId: string;\n  reason?: string;\n  immediate?: boolean; // Cancel immediately or at end of billing cycle\n}\n\nexport class SubscriptionService {\n  /**\n   * Create a new subscription for a user\n   */\n  static async createSubscription(input: SubscriptionCreateInput) {\n    const tierConfig = getTierConfig(input.tier);\n    const now = new Date();\n    \n    // Calculate billing cycle dates\n    const billingCycleStart = now;\n    const billingCycleEnd = new Date(now);\n    billingCycleEnd.setMonth(billingCycleEnd.getMonth() + 1);\n    \n    const nextBillingDate = new Date(billingCycleEnd);\n    \n    // Calculate trial end date if applicable\n    let trialEndsAt: Date | null = null;\n    let status: \'ACTIVE\' | \'TRIAL\' = \'ACTIVE\';\n    \n    if (input.trialPeriod) {\n      trialEndsAt = new Date(now);\n      trialEndsAt.setDate(trialEndsAt.getDate() + PRICING_RULES.TRIAL_PERIOD_DAYS);\n      status = \'TRIAL\';\n    }\n    \n    // Create subscription\n    const subscription = await prisma.subscription.create({\n      data: {\n        userId: input.userId,\n        tier: input.tier,\n        status,\n        monthlyPrice: tierConfig.monthlyPrice,\n        billingCycleStart,\n        billingCycleEnd,\n        nextBillingDate,\n        trialEndsAt,\n        metadata: JSON.stringify({\n          paymentMethodId: input.paymentMethodId,\n          createdVia: \'web\',\n        }),\n      },\n    });\n    \n    // Create token balance\n    const initialTokens = input.trialPeriod\n      ? PRICING_RULES.TRIAL_TOKENS\n      : tierConfig.monthlyTokens;\n    \n    const tokenBalance = await prisma.tokenBalance.create({\n      data: {\n        userId: input.userId,\n        subscriptionId: subscription.id,\n        currentBalance: initialTokens,\n        totalEarned: initialTokens,\n        lastRefreshDate: now,\n      },\n    });\n    \n    // Create initial token transaction\n    await prisma.tokenTransaction.create({\n      data: {\n        tokenBalanceId: tokenBalance.id,\n        type: input.trialPeriod ? \'BONUS\' : \'INITIAL_DEPOSIT\',\n        amount: initialTokens,\n        balanceBefore: 0,\n        balanceAfter: initialTokens,\n        description: input.trialPeriod\n          ? `Trial period tokens (${PRICING_RULES.TRIAL_PERIOD_DAYS} days)`\n          : `Initial ${tierConfig.displayName} subscription tokens`,\n      },\n    });\n    \n    // Create subscription history entry\n    await prisma.subscriptionHistory.create({\n      data: {\n        subscriptionId: subscription.id,\n        toTier: input.tier,\n        toStatus: status,\n        reason: input.trialPeriod ? \'Trial subscription created\' : \'Subscription created\',\n      },\n    });\n    \n    return {\n      subscription,\n      tokenBalance,\n    };\n  }\n  \n  /**\n   * Upgrade or downgrade a subscription\n   */\n  static async changeSubscriptionTier(input: SubscriptionUpgradeInput) {\n    const subscription = await prisma.subscription.findUnique({\n      where: { userId: input.userId },\n      include: { tokenBalance: true },\n    });\n    \n    if (!subscription) {\n      throw new Error(\'Subscription not found\');\n    }\n    \n    const oldTier = subscription.tier as SubscriptionTier;\n    const newTier = input.newTier;\n    const oldConfig = getTierConfig(oldTier);\n    const newConfig = getTierConfig(newTier);\n    \n    // Determine if this is an upgrade or downgrade\n    const isUpgrade = newConfig.monthlyPrice > oldConfig.monthlyPrice;\n    \n    // Calculate token adjustment\n    const tokenDifference = newConfig.monthlyTokens - oldConfig.monthlyTokens;\n    \n    if (input.immediate) {\n      // Apply change immediately\n      const updatedSubscription = await prisma.subscription.update({\n        where: { id: subscription.id },\n        data: {\n          tier: newTier,\n          monthlyPrice: newConfig.monthlyPrice,\n        },\n      });\n      \n      // Adjust tokens if upgrade (add difference), if downgrade (no adjustment)\n      if (isUpgrade && tokenDifference > 0 && subscription.tokenBalance) {\n        const currentBalance = subscription.tokenBalance.currentBalance;\n        const newBalance = currentBalance + tokenDifference;\n        \n        await prisma.tokenBalance.update({\n          where: { id: subscription.tokenBalance.id },\n          data: {\n            currentBalance: newBalance,\n            totalEarned: subscription.tokenBalance.totalEarned + tokenDifference,\n          },\n        });\n        \n        await prisma.tokenTransaction.create({\n          data: {\n            tokenBalanceId: subscription.tokenBalance.id,\n            type: \'BONUS\',\n            amount: tokenDifference,\n            balanceBefore: currentBalance,\n            balanceAfter: newBalance,\n            description: `Upgrade bonus: ${oldConfig.displayName} â†’ ${newConfig.displayName}`,\n          },\n        });\n      }\n      \n      // Create history entry\n      await prisma.subscriptionHistory.create({\n        data: {\n          subscriptionId: subscription.id,\n          fromTier: oldTier,\n          toTier: newTier,\n          fromStatus: subscription.status,\n          toStatus: subscription.status,\n          reason: isUpgrade ? \'Immediate upgrade\' : \'Immediate downgrade\',\n        },\n      });\n      \n      return updatedSubscription;\n    } else {\n      // Schedule change for next billing cycle\n      const metadata = JSON.parse(subscription.metadata || \'{}\');\n      metadata.scheduledTierChange = {\n        newTier,\n        effectiveDate: subscription.nextBillingDate,\n        scheduledAt: new Date(),\n      };\n      \n      const updatedSubscription = await prisma.subscription.update({\n        where: { id: subscription.id },\n        data: {\n          metadata: JSON.stringify(metadata),\n        },\n      });\n      \n      // Create history entry\n      await prisma.subscriptionHistory.create({\n        data: {\n          subscriptionId: subscription.id,\n          fromTier: oldTier,\n          toTier: newTier,\n          fromStatus: subscription.status,\n          toStatus: subscription.status,\n          reason: `Scheduled ${isUpgrade ? \'upgrade\' : \'downgrade\'} for ${subscription.nextBillingDate?.toLocaleDateString()}`,\n        },\n      });\n      \n      return updatedSubscription;\n    }\n  }\n  \n  /**\n   * Cancel a subscription\n   */\n  static async cancelSubscription(input: SubscriptionCancellationInput) {\n    const subscription = await prisma.subscription.findUnique({\n      where: { userId: input.userId },\n    });\n    \n    if (!subscription) {\n      throw new Error(\'Subscription not found\');\n    }\n    \n    const now = new Date();\n    \n    if (input.immediate) {\n      // Cancel immediately\n      const updatedSubscription = await prisma.subscription.update({\n        where: { id: subscription.id },\n        data: {\n          status: \'CANCELLED\',\n          cancelledAt: now,\n        },\n      });\n      \n      await prisma.subscriptionHistory.create({\n        data: {\n          subscriptionId: subscription.id,\n          fromTier: subscription.tier,\n          toTier: subscription.tier,\n          fromStatus: subscription.status,\n          toStatus: \'CANCELLED\',\n          reason: input.reason || \'Immediate cancellation\',\n        },\n      });\n      \n      return updatedSubscription;\n    } else {\n      // Cancel at end of billing cycle\n      const metadata = JSON.parse(subscription.metadata || \'{}\');\n      metadata.scheduledCancellation = {\n        effectiveDate: subscription.billingCycleEnd,\n        scheduledAt: now,\n        reason: input.reason,\n      };\n      \n      const updatedSubscription = await prisma.subscription.update({\n        where: { id: subscription.id },\n        data: {\n          metadata: JSON.stringify(metadata),\n        },\n      });\n      \n      await prisma.subscriptionHistory.create({\n        data: {\n          subscriptionId: subscription.id,\n          fromTier: subscription.tier,\n          toTier: subscription.tier,\n          fromStatus: subscription.status,\n          toStatus: subscription.status,\n          reason: `Scheduled cancellation for ${subscription.billingCycleEnd.toLocaleDateString()}`,\n        },\n      });\n      \n      return updatedSubscription;\n    }\n  }\n  \n  /**\n   * Refresh monthly tokens (called by cron job)\n   */\n  static async refreshMonthlyTokens(userId: string) {\n    const subscription = await prisma.subscription.findUnique({\n      where: { userId },\n      include: { tokenBalance: true },\n    });\n    \n    if (!subscription || !subscription.tokenBalance) {\n      throw new Error(\'Subscription or token balance not found\');\n    }\n    \n    // Check if subscription is active\n    if (subscription.status !== \'ACTIVE\') {\n      throw new Error(\'Subscription is not active\');\n    }\n    \n    const tierConfig = getTierConfig(subscription.tier as SubscriptionTier);\n    const now = new Date();\n    \n    // Check if it\'s time for refresh\n    const lastRefresh = subscription.tokenBalance.lastRefreshDate;\n    if (lastRefresh) {\n      const daysSinceRefresh = Math.floor(\n        (now.getTime() - lastRefresh.getTime()) / (1000 * 60 * 60 * 24)\n      );\n      if (daysSinceRefresh < 30) {\n        throw new Error(\'Not time for monthly refresh yet\');\n      }\n    }\n    \n    // Add monthly tokens\n    const currentBalance = subscription.tokenBalance.currentBalance;\n    const newBalance = currentBalance + tierConfig.monthlyTokens;\n    \n    const updatedBalance = await prisma.tokenBalance.update({\n      where: { id: subscription.tokenBalance.id },\n      data: {\n        currentBalance: newBalance,\n        totalEarned: subscription.tokenBalance.totalEarned + tierConfig.monthlyTokens,\n        lastRefreshDate: now,\n      },\n    });\n    \n    // Create transaction\n    await prisma.tokenTransaction.create({\n      data: {\n        tokenBalanceId: subscription.tokenBalance.id,\n        type: \'MONTHLY_REFRESH\',\n        amount: tierConfig.monthlyTokens,\n        balanceBefore: currentBalance,\n        balanceAfter: newBalance,\n        description: `Monthly token refresh: ${tierConfig.displayName} tier`,\n      },\n    });\n    \n    // Update billing cycle\n    const newBillingCycleStart = subscription.billingCycleEnd;\n    const newBillingCycleEnd = new Date(newBillingCycleStart);\n    newBillingCycleEnd.setMonth(newBillingCycleEnd.getMonth() + 1);\n    \n    await prisma.subscription.update({\n      where: { id: subscription.id },\n      data: {\n        billingCycleStart: newBillingCycleStart,\n        billingCycleEnd: newBillingCycleEnd,\n        nextBillingDate: newBillingCycleEnd,\n      },\n    });\n    \n    return updatedBalance;\n  }\n  \n  /**\n   * Handle expired subscriptions (called by cron job)\n   */\n  static async handleExpiredSubscriptions() {\n    const now = new Date();\n    const gracePeriodEnd = new Date(now);\n    gracePeriodEnd.setDate(gracePeriodEnd.getDate() - PRICING_RULES.GRACE_PERIOD_DAYS);\n    \n    // Find subscriptions past grace period\n    const expiredSubscriptions = await prisma.subscription.findMany({\n      where: {\n        status: \'PAST_DUE\',\n        billingCycleEnd: {\n          lt: gracePeriodEnd,\n        },\n      },\n    });\n    \n    // Mark as expired\n    for (const subscription of expiredSubscriptions) {\n      await prisma.subscription.update({\n        where: { id: subscription.id },\n        data: {\n          status: \'EXPIRED\',\n        },\n      });\n      \n      await prisma.subscriptionHistory.create({\n        data: {\n          subscriptionId: subscription.id,\n          fromTier: subscription.tier,\n          toTier: subscription.tier,\n          fromStatus: \'PAST_DUE\',\n          toStatus: \'EXPIRED\',\n          reason: \'Subscription expired after grace period\',\n        },\n      });\n    }\n    \n    return expiredSubscriptions.length;\n  }\n  \n  /**\n   * Get subscription details with token balance\n   */\n  static async getSubscription(userId: string) {\n    const subscription = await prisma.subscription.findUnique({\n      where: { userId },\n      include: {\n        tokenBalance: true,\n        subscriptionHistory: {\n          orderBy: { changedAt: \'desc\' },\n          take: 10,\n        },\n      },\n    });\n    \n    if (!subscription) {\n      return null;\n    }\n    \n    const tierConfig = getTierConfig(subscription.tier as SubscriptionTier);\n    \n    return {\n      ...subscription,\n      tierConfig,\n    };\n  }\n  \n  /**\n   * Check if user has active subscription\n   */\n  static async hasActiveSubscription(userId: string): Promise<boolean> {\n    const subscription = await prisma.subscription.findUnique({\n      where: { userId },\n    });\n    \n    return subscription?.status === \'ACTIVE\' || subscription?.status === \'TRIAL\';\n  }\n  \n  /**\n   * Get subscription statistics\n   */\n  static async getSubscriptionStats() {\n    const [\n      totalSubscriptions,\n      activeSubscriptions,\n      trialSubscriptions,\n      cancelledSubscriptions,\n      tierDistribution,\n    ] = await Promise.all([\n      prisma.subscription.count(),\n      prisma.subscription.count({ where: { status: \'ACTIVE\' } }),\n      prisma.subscription.count({ where: { status: \'TRIAL\' } }),\n      prisma.subscription.count({ where: { status: \'CANCELLED\' } }),\n      prisma.subscription.groupBy({\n        by: [\'tier\'],\n        _count: true,\n      }),\n    ]);\n    \n    return {\n      totalSubscriptions,\n      activeSubscriptions,\n      trialSubscriptions,\n      cancelledSubscriptions,\n      tierDistribution: tierDistribution.map(t => ({\n        tier: t.tier,\n        count: t._count,\n      })),\n    };\n  }\n}\n</create-file>\n</function_calls>'}