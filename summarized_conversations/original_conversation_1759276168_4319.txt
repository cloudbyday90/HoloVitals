{'role': 'assistant', 'content': '# Starting Service 4: InstanceProvisionerService Implementation\n\nI\'ll now implement the final service in Phase 7 - the InstanceProvisionerService. This service will manage ephemeral cloud instances for GPU-intensive AI analysis tasks, providing 90% cost savings vs always-on instances.\n\n## Implementation Plan\n\n1. **Core Service Implementation** (~500 lines)\n   - Instance lifecycle management (provision → configure → execute → terminate)\n   - Multi-cloud support (Azure, AWS)\n   - GPU instance types and configurations\n   - Cost tracking and optimization\n   - Health monitoring and auto-recovery\n\n2. **API Endpoints** (~300 lines)\n   - POST /api/instances - Provision new instance\n   - GET /api/instances/:id - Get instance status\n   - DELETE /api/instances/:id - Terminate instance\n   - GET /api/instances/stats - Get usage statistics\n\n3. **Database Schema** (~100 lines)\n   - CloudInstance model with lifecycle tracking\n   - Cost tracking per instance\n   - Performance metrics\n\n4. **Testing Suite** (~400 lines)\n   - Unit tests for all operations\n   - Mock cloud provider responses\n   - Edge case handling\n\n5. **Documentation** (~200 lines)\n   - API reference\n   - Configuration guide\n   - Cost analysis\n\nLet me start implementing:\n\n<function_calls>\n<create-file file_path="lib/services/InstanceProvisionerService.ts">\n/**\n * InstanceProvisionerService\n * \n * Manages ephemeral cloud instances for GPU-intensive AI analysis tasks.\n * Provides 90% cost savings vs always-on instances through on-demand provisioning.\n * \n * Features:\n * - Multi-cloud support (Azure, AWS)\n * - Automatic instance lifecycle management\n * - GPU instance optimization\n * - Cost tracking and reporting\n * - Health monitoring and auto-recovery\n * - Automatic termination after analysis\n */\n\nimport { PrismaClient } from \'@prisma/client\';\nimport { EventEmitter } from \'events\';\n\nconst prisma = new PrismaClient();\n\n// Cloud provider types\nexport enum CloudProvider {\n  AZURE = \'AZURE\',\n  AWS = \'AWS\',\n  GCP = \'GCP\'\n}\n\n// Instance status lifecycle\nexport enum InstanceStatus {\n  PROVISIONING = \'PROVISIONING\',\n  CONFIGURING = \'CONFIGURING\',\n  READY = \'READY\',\n  RUNNING = \'RUNNING\',\n  STOPPING = \'STOPPING\',\n  TERMINATED = \'TERMINATED\',\n  FAILED = \'FAILED\'\n}\n\n// GPU instance types\nexport enum InstanceType {\n  // Azure GPU instances\n  AZURE_NC6 = \'Standard_NC6\',           // 1x K80, 6 cores, 56GB RAM - $0.90/hr\n  AZURE_NC12 = \'Standard_NC12\',         // 2x K80, 12 cores, 112GB RAM - $1.80/hr\n  AZURE_NC24 = \'Standard_NC24\',         // 4x K80, 24 cores, 224GB RAM - $3.60/hr\n  AZURE_NV6 = \'Standard_NV6\',           // 1x M60, 6 cores, 56GB RAM - $1.14/hr\n  AZURE_NV12 = \'Standard_NV12\',         // 2x M60, 12 cores, 112GB RAM - $2.28/hr\n  \n  // AWS GPU instances\n  AWS_P2_XLARGE = \'p2.xlarge\',          // 1x K80, 4 cores, 61GB RAM - $0.90/hr\n  AWS_P2_8XLARGE = \'p2.8xlarge\',        // 8x K80, 32 cores, 488GB RAM - $7.20/hr\n  AWS_P3_2XLARGE = \'p3.2xlarge\',        // 1x V100, 8 cores, 61GB RAM - $3.06/hr\n  AWS_G4DN_XLARGE = \'g4dn.xlarge\',      // 1x T4, 4 cores, 16GB RAM - $0.526/hr\n  AWS_G4DN_12XLARGE = \'g4dn.12xlarge\'   // 4x T4, 48 cores, 192GB RAM - $3.912/hr\n}\n\n// Instance configuration\nexport interface InstanceConfig {\n  provider: CloudProvider;\n  instanceType: InstanceType;\n  region: string;\n  diskSizeGB: number;\n  autoTerminateMinutes: number;\n  tags?: Record<string, string>;\n}\n\n// Instance details\nexport interface InstanceDetails {\n  id: string;\n  provider: CloudProvider;\n  instanceType: InstanceType;\n  status: InstanceStatus;\n  publicIp?: string;\n  privateIp?: string;\n  region: string;\n  costPerHour: number;\n  totalCost: number;\n  createdAt: Date;\n  terminatedAt?: Date;\n  metadata?: Record<string, any>;\n}\n\n// Provisioning request\nexport interface ProvisionRequest {\n  userId: string;\n  taskId: string;\n  config: InstanceConfig;\n  purpose: string;\n}\n\n// Instance statistics\nexport interface InstanceStatistics {\n  totalProvisioned: number;\n  currentlyRunning: number;\n  totalCost: number;\n  averageDuration: number;\n  averageCost: number;\n  providerBreakdown: Record<CloudProvider, number>;\n  instanceTypeBreakdown: Record<InstanceType, number>;\n}\n\nclass InstanceProvisionerService extends EventEmitter {\n  private static instance: InstanceProvisionerService;\n  private monitoringInterval?: NodeJS.Timeout;\n\n  private constructor() {\n    super();\n    this.startMonitoring();\n  }\n\n  public static getInstance(): InstanceProvisionerService {\n    if (!InstanceProvisionerService.instance) {\n      InstanceProvisionerService.instance = new InstanceProvisionerService();\n    }\n    return InstanceProvisionerService.instance;\n  }\n\n  /**\n   * Provision a new cloud instance\n   */\n  async provisionInstance(request: ProvisionRequest): Promise<InstanceDetails> {\n    try {\n      // Validate configuration\n      this.validateConfig(request.config);\n\n      // Create database record\n      const instance = await prisma.cloudInstance.create({\n        data: {\n          userId: request.userId,\n          taskId: request.taskId,\n          provider: request.config.provider,\n          instanceType: request.config.instanceType,\n          region: request.config.region,\n          status: InstanceStatus.PROVISIONING,\n          diskSizeGB: request.config.diskSizeGB,\n          autoTerminateMinutes: request.config.autoTerminateMinutes,\n          costPerHour: this.getCostPerHour(request.config.instanceType),\n          totalCost: 0,\n          purpose: request.purpose,\n          metadata: request.config.tags || {}\n        }\n      });\n\n      this.emit(\'instance:provisioning\', { instanceId: instance.id });\n\n      // Provision instance based on provider\n      let provisionResult;\n      switch (request.config.provider) {\n        case CloudProvider.AZURE:\n          provisionResult = await this.provisionAzureInstance(instance.id, request.config);\n          break;\n        case CloudProvider.AWS:\n          provisionResult = await this.provisionAWSInstance(instance.id, request.config);\n          break;\n        default:\n          throw new Error(`Unsupported provider: ${request.config.provider}`);\n      }\n\n      // Update instance with provisioning details\n      const updatedInstance = await prisma.cloudInstance.update({\n        where: { id: instance.id },\n        data: {\n          status: InstanceStatus.CONFIGURING,\n          publicIp: provisionResult.publicIp,\n          privateIp: provisionResult.privateIp,\n          cloudInstanceId: provisionResult.cloudInstanceId,\n          metadata: {\n            ...instance.metadata,\n            ...provisionResult.metadata\n          }\n        }\n      });\n\n      this.emit(\'instance:provisioned\', { instanceId: instance.id });\n\n      // Configure instance\n      await this.configureInstance(instance.id);\n\n      // Mark as ready\n      await prisma.cloudInstance.update({\n        where: { id: instance.id },\n        data: { status: InstanceStatus.READY }\n      });\n\n      this.emit(\'instance:ready\', { instanceId: instance.id });\n\n      return this.mapToInstanceDetails(updatedInstance);\n    } catch (error) {\n      this.emit(\'instance:error\', { error: error instanceof Error ? error.message : \'Unknown error\' });\n      throw error;\n    }\n  }\n\n  /**\n   * Get instance details\n   */\n  async getInstance(instanceId: string): Promise<InstanceDetails | null> {\n    const instance = await prisma.cloudInstance.findUnique({\n      where: { id: instanceId }\n    });\n\n    if (!instance) {\n      return null;\n    }\n\n    return this.mapToInstanceDetails(instance);\n  }\n\n  /**\n   * Terminate an instance\n   */\n  async terminateInstance(instanceId: string): Promise<void> {\n    const instance = await prisma.cloudInstance.findUnique({\n      where: { id: instanceId }\n    });\n\n    if (!instance) {\n      throw new Error(\'Instance not found\');\n    }\n\n    if (instance.status === InstanceStatus.TERMINATED) {\n      return; // Already terminated\n    }\n\n    try {\n      // Update status to stopping\n      await prisma.cloudInstance.update({\n        where: { id: instanceId },\n        data: { status: InstanceStatus.STOPPING }\n      });\n\n      this.emit(\'instance:stopping\', { instanceId });\n\n      // Terminate based on provider\n      switch (instance.provider) {\n        case CloudProvider.AZURE:\n          await this.terminateAzureInstance(instance.cloudInstanceId!);\n          break;\n        case CloudProvider.AWS:\n          await this.terminateAWSInstance(instance.cloudInstanceId!);\n          break;\n      }\n\n      // Calculate final cost\n      const durationHours = this.calculateDurationHours(instance.createdAt, new Date());\n      const totalCost = durationHours * instance.costPerHour;\n\n      // Update to terminated\n      await prisma.cloudInstance.update({\n        where: { id: instanceId },\n        data: {\n          status: InstanceStatus.TERMINATED,\n          terminatedAt: new Date(),\n          totalCost\n        }\n      });\n\n      this.emit(\'instance:terminated\', { instanceId, totalCost });\n    } catch (error) {\n      await prisma.cloudInstance.update({\n        where: { id: instanceId },\n        data: { status: InstanceStatus.FAILED }\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get instance statistics\n   */\n  async getStatistics(userId?: string): Promise<InstanceStatistics> {\n    const where = userId ? { userId } : {};\n\n    const instances = await prisma.cloudInstance.findMany({ where });\n\n    const stats: InstanceStatistics = {\n      totalProvisioned: instances.length,\n      currentlyRunning: instances.filter(i => \n        i.status === InstanceStatus.RUNNING || \n        i.status === InstanceStatus.READY\n      ).length,\n      totalCost: instances.reduce((sum, i) => sum + i.totalCost, 0),\n      averageDuration: 0,\n      averageCost: 0,\n      providerBreakdown: {} as Record<CloudProvider, number>,\n      instanceTypeBreakdown: {} as Record<InstanceType, number>\n    };\n\n    // Calculate averages\n    const terminatedInstances = instances.filter(i => i.terminatedAt);\n    if (terminatedInstances.length > 0) {\n      const totalDuration = terminatedInstances.reduce((sum, i) => {\n        return sum + this.calculateDurationHours(i.createdAt, i.terminatedAt!);\n      }, 0);\n      stats.averageDuration = totalDuration / terminatedInstances.length;\n      stats.averageCost = stats.totalCost / terminatedInstances.length;\n    }\n\n    // Provider breakdown\n    instances.forEach(i => {\n      stats.providerBreakdown[i.provider] = (stats.providerBreakdown[i.provider] || 0) + 1;\n    });\n\n    // Instance type breakdown\n    instances.forEach(i => {\n      stats.instanceTypeBreakdown[i.instanceType as InstanceType] = \n        (stats.instanceTypeBreakdown[i.instanceType as InstanceType] || 0) + 1;\n    });\n\n    return stats;\n  }\n\n  /**\n   * List instances for a user\n   */\n  async listInstances(userId: string, status?: InstanceStatus): Promise<InstanceDetails[]> {\n    const where: any = { userId };\n    if (status) {\n      where.status = status;\n    }\n\n    const instances = await prisma.cloudInstance.findMany({\n      where,\n      orderBy: { createdAt: \'desc\' }\n    });\n\n    return instances.map(i => this.mapToInstanceDetails(i));\n  }\n\n  /**\n   * Start monitoring for auto-termination\n   */\n  private startMonitoring(): void {\n    // Check every minute for instances that need auto-termination\n    this.monitoringInterval = setInterval(async () => {\n      try {\n        const instances = await prisma.cloudInstance.findMany({\n          where: {\n            status: {\n              in: [InstanceStatus.READY, InstanceStatus.RUNNING]\n            }\n          }\n        });\n\n        for (const instance of instances) {\n          const ageMinutes = (Date.now() - instance.createdAt.getTime()) / (1000 * 60);\n          \n          if (ageMinutes >= instance.autoTerminateMinutes) {\n            console.log(`Auto-terminating instance ${instance.id} after ${ageMinutes} minutes`);\n            await this.terminateInstance(instance.id);\n          }\n        }\n      } catch (error) {\n        console.error(\'Error in monitoring loop:\', error);\n      }\n    }, 60000); // Check every minute\n  }\n\n  /**\n   * Stop monitoring\n   */\n  public stopMonitoring(): void {\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n    }\n  }\n\n  // Private helper methods\n\n  private validateConfig(config: InstanceConfig): void {\n    if (!config.provider) {\n      throw new Error(\'Provider is required\');\n    }\n    if (!config.instanceType) {\n      throw new Error(\'Instance type is required\');\n    }\n    if (!config.region) {\n      throw new Error(\'Region is required\');\n    }\n    if (config.diskSizeGB < 30) {\n      throw new Error(\'Disk size must be at least 30GB\');\n    }\n    if (config.autoTerminateMinutes < 5) {\n      throw new Error(\'Auto-terminate must be at least 5 minutes\');\n    }\n  }\n\n  private getCostPerHour(instanceType: InstanceType): number {\n    const costs: Record<InstanceType, number> = {\n      [InstanceType.AZURE_NC6]: 0.90,\n      [InstanceType.AZURE_NC12]: 1.80,\n      [InstanceType.AZURE_NC24]: 3.60,\n      [InstanceType.AZURE_NV6]: 1.14,\n      [InstanceType.AZURE_NV12]: 2.28,\n      [InstanceType.AWS_P2_XLARGE]: 0.90,\n      [InstanceType.AWS_P2_8XLARGE]: 7.20,\n      [InstanceType.AWS_P3_2XLARGE]: 3.06,\n      [InstanceType.AWS_G4DN_XLARGE]: 0.526,\n      [InstanceType.AWS_G4DN_12XLARGE]: 3.912\n    };\n    return costs[instanceType] || 0;\n  }\n\n  private async provisionAzureInstance(instanceId: string, config: InstanceConfig): Promise<any> {\n    // In production, this would use Azure SDK\n    // For now, simulate provisioning\n    await this.simulateDelay(5000); // 5 second provisioning\n\n    return {\n      cloudInstanceId: `azure-${instanceId}`,\n      publicIp: this.generateMockIP(),\n      privateIp: this.generateMockIP(true),\n      metadata: {\n        resourceGroup: \'holovitals-rg\',\n        location: config.region,\n        vmSize: config.instanceType\n      }\n    };\n  }\n\n  private async provisionAWSInstance(instanceId: string, config: InstanceConfig): Promise<any> {\n    // In production, this would use AWS SDK\n    // For now, simulate provisioning\n    await this.simulateDelay(5000); // 5 second provisioning\n\n    return {\n      cloudInstanceId: `i-${instanceId.substring(0, 17)}`,\n      publicIp: this.generateMockIP(),\n      privateIp: this.generateMockIP(true),\n      metadata: {\n        availabilityZone: `${config.region}a`,\n        instanceType: config.instanceType,\n        imageId: \'ami-0c55b159cbfafe1f0\'\n      }\n    };\n  }\n\n  private async configureInstance(instanceId: string): Promise<void> {\n    // In production, this would:\n    // 1. Wait for instance to be accessible\n    // 2. Install required software (CUDA, PyTorch, etc.)\n    // 3. Configure security groups\n    // 4. Set up monitoring\n    await this.simulateDelay(10000); // 10 second configuration\n  }\n\n  private async terminateAzureInstance(cloudInstanceId: string): Promise<void> {\n    // In production, this would use Azure SDK\n    await this.simulateDelay(2000); // 2 second termination\n  }\n\n  private async terminateAWSInstance(cloudInstanceId: string): Promise<void> {\n    // In production, this would use AWS SDK\n    await this.simulateDelay(2000); // 2 second termination\n  }\n\n  private calculateDurationHours(start: Date, end: Date): number {\n    return (end.getTime() - start.getTime()) / (1000 * 60 * 60);\n  }\n\n  private mapToInstanceDetails(instance: any): InstanceDetails {\n    return {\n      id: instance.id,\n      provider: instance.provider,\n      instanceType: instance.instanceType,\n      status: instance.status,\n      publicIp: instance.publicIp,\n      privateIp: instance.privateIp,\n      region: instance.region,\n      costPerHour: instance.costPerHour,\n      totalCost: instance.totalCost,\n      createdAt: instance.createdAt,\n      terminatedAt: instance.terminatedAt,\n      metadata: instance.metadata\n    };\n  }\n\n  private generateMockIP(isPrivate: boolean = false): string {\n    if (isPrivate) {\n      return `10.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;\n    }\n    return `${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;\n  }\n\n  private simulateDelay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\nexport default InstanceProvisionerService;\n</create-file>\n</function_calls>'}