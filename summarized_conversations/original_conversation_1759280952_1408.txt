{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/services/ErrorAlertService.ts">\n/**\n * Error Alert Service\n * Sends alerts for critical errors via multiple channels\n */\n\nimport { ErrorSeverity } from \'../errors/ErrorLogger\';\nimport { prisma } from \'../prisma\';\n\n// ============================================================================\n// ALERT CHANNELS\n// ============================================================================\n\nexport enum AlertChannel {\n  EMAIL = \'EMAIL\',\n  SLACK = \'SLACK\',\n  SMS = \'SMS\',\n  WEBHOOK = \'WEBHOOK\',\n  IN_APP = \'IN_APP\',\n}\n\n// ============================================================================\n// ALERT CONFIGURATION\n// ============================================================================\n\ninterface AlertConfig {\n  channels: AlertChannel[];\n  recipients: string[];\n  webhookUrl?: string;\n  slackWebhook?: string;\n}\n\n// ============================================================================\n// ERROR ALERT SERVICE\n// ============================================================================\n\nexport class ErrorAlertService {\n  private static instance: ErrorAlertService;\n  private config: AlertConfig;\n\n  private constructor() {\n    this.config = {\n      channels: [AlertChannel.IN_APP],\n      recipients: [],\n      webhookUrl: process.env.ALERT_WEBHOOK_URL,\n      slackWebhook: process.env.SLACK_WEBHOOK_URL,\n    };\n  }\n\n  public static getInstance(): ErrorAlertService {\n    if (!ErrorAlertService.instance) {\n      ErrorAlertService.instance = new ErrorAlertService();\n    }\n    return ErrorAlertService.instance;\n  }\n\n  /**\n   * Send alert for critical error\n   */\n  public async sendCriticalAlert(\n    errorId: string,\n    message: string,\n    details: {\n      code?: string;\n      endpoint?: string;\n      userId?: string;\n      timestamp: Date;\n    }\n  ): Promise<void> {\n    console.log(\'üö® CRITICAL ALERT:\', {\n      errorId,\n      message,\n      ...details,\n    });\n\n    // Send to all configured channels\n    await Promise.all([\n      this.sendInAppNotification(errorId, message, details),\n      this.sendSlackAlert(message, details),\n      this.sendWebhookAlert(message, details),\n      this.sendEmailAlert(message, details),\n    ]);\n  }\n\n  /**\n   * Send in-app notification\n   */\n  private async sendInAppNotification(\n    errorId: string,\n    message: string,\n    details: any\n  ): Promise<void> {\n    try {\n      // Get all admin and owner users\n      const adminUsers = await prisma.user.findMany({\n        where: {\n          role: {\n            in: [\'OWNER\', \'ADMIN\'],\n          },\n        },\n        select: { id: true },\n      });\n\n      // Create notification for each admin\n      await Promise.all(\n        adminUsers.map(user =>\n          prisma.notification.create({\n            data: {\n              userId: user.id,\n              type: \'CRITICAL_ERROR\',\n              title: \'Critical System Error\',\n              message: message,\n              severity: \'CRITICAL\',\n              metadata: JSON.stringify({\n                errorId,\n                ...details,\n              }),\n              read: false,\n            },\n          })\n        )\n      );\n\n      console.log(`‚úì In-app notifications sent to ${adminUsers.length} admins`);\n    } catch (error) {\n      console.error(\'Failed to send in-app notification:\', error);\n    }\n  }\n\n  /**\n   * Send Slack alert\n   */\n  private async sendSlackAlert(message: string, details: any): Promise<void> {\n    if (!this.config.slackWebhook) {\n      return;\n    }\n\n    try {\n      const payload = {\n        text: \'üö® Critical System Error\',\n        blocks: [\n          {\n            type: \'header\',\n            text: {\n              type: \'plain_text\',\n              text: \'üö® Critical System Error\',\n            },\n          },\n          {\n            type: \'section\',\n            text: {\n              type: \'mrkdwn\',\n              text: `*Message:* ${message}`,\n            },\n          },\n          {\n            type: \'section\',\n            fields: [\n              {\n                type: \'mrkdwn\',\n                text: `*Code:*\\n${details.code || \'N/A\'}`,\n              },\n              {\n                type: \'mrkdwn\',\n                text: `*Endpoint:*\\n${details.endpoint || \'N/A\'}`,\n              },\n              {\n                type: \'mrkdwn\',\n                text: `*Time:*\\n${details.timestamp.toISOString()}`,\n              },\n              {\n                type: \'mrkdwn\',\n                text: `*User:*\\n${details.userId || \'N/A\'}`,\n              },\n            ],\n          },\n        ],\n      };\n\n      await fetch(this.config.slackWebhook, {\n        method: \'POST\',\n        headers: { \'Content-Type\': \'application/json\' },\n        body: JSON.stringify(payload),\n      });\n\n      console.log(\'‚úì Slack alert sent\');\n    } catch (error) {\n      console.error(\'Failed to send Slack alert:\', error);\n    }\n  }\n\n  /**\n   * Send webhook alert\n   */\n  private async sendWebhookAlert(message: string, details: any): Promise<void> {\n    if (!this.config.webhookUrl) {\n      return;\n    }\n\n    try {\n      await fetch(this.config.webhookUrl, {\n        method: \'POST\',\n        headers: { \'Content-Type\': \'application/json\' },\n        body: JSON.stringify({\n          type: \'critical_error\',\n          message,\n          details,\n          timestamp: new Date().toISOString(),\n        }),\n      });\n\n      console.log(\'‚úì Webhook alert sent\');\n    } catch (error) {\n      console.error(\'Failed to send webhook alert:\', error);\n    }\n  }\n\n  /**\n   * Send email alert\n   */\n  private async sendEmailAlert(message: string, details: any): Promise<void> {\n    // TODO: Implement email sending\n    // This would integrate with your email service (SendGrid, AWS SES, etc.)\n    console.log(\'‚úì Email alert queued (not implemented)\');\n  }\n\n  /**\n   * Send high severity alert\n   */\n  public async sendHighSeverityAlert(\n    errorId: string,\n    message: string,\n    details: any\n  ): Promise<void> {\n    console.log(\'‚ö†Ô∏è HIGH SEVERITY ALERT:\', {\n      errorId,\n      message,\n      ...details,\n    });\n\n    // Only send in-app notification for high severity\n    await this.sendInAppNotification(errorId, message, details);\n  }\n\n  /**\n   * Configure alert settings\n   */\n  public configure(config: Partial<AlertConfig>): void {\n    this.config = {\n      ...this.config,\n      ...config,\n    };\n  }\n\n  /**\n   * Get alert statistics\n   */\n  public async getAlertStats(hours: number = 24): Promise<{\n    total: number;\n    bySeverity: Record<string, number>;\n    byType: Record<string, number>;\n  }> {\n    const since = new Date(Date.now() - hours * 60 * 60 * 1000);\n\n    const notifications = await prisma.notification.findMany({\n      where: {\n        createdAt: { gte: since },\n        type: {\n          in: [\'CRITICAL_ERROR\', \'HIGH_SEVERITY_ERROR\'],\n        },\n      },\n      select: {\n        severity: true,\n        type: true,\n      },\n    });\n\n    const stats = {\n      total: notifications.length,\n      bySeverity: {} as Record<string, number>,\n      byType: {} as Record<string, number>,\n    };\n\n    notifications.forEach(notification => {\n      stats.bySeverity[notification.severity] =\n        (stats.bySeverity[notification.severity] || 0) + 1;\n      stats.byType[notification.type] =\n        (stats.byType[notification.type] || 0) + 1;\n    });\n\n    return stats;\n  }\n}\n\n// Export singleton instance\nexport const errorAlertService = ErrorAlertService.getInstance();\n</create-file>\n</function_calls>'}