{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/repositories/patient/PatientRepository.ts">\n/**\n * Patient Repository for HoloVitals\n * \n * Each patient has their own isolated, sandboxed repository containing:\n * - Personal information (encrypted)\n * - Medical history\n * - Documents and test results\n * - Stored context for AI analysis\n * - Preferences and settings\n * \n * Key Features:\n * - One repository per patient (enforced by identity verification)\n * - Complete data isolation (sandboxed)\n * - Comprehensive data model\n * - Secure deletion and purging\n * - Account migration support\n */\n\nimport { PrismaClient } from \'@prisma/client\';\nimport { identityVerificationService, IdentityFactors } from \'../../identity/IdentityVerificationService\';\nimport { HIPAASanitizer } from \'../../utils/hipaa/sanitizer\';\nimport { auditLogger } from \'../../audit/AuditLogger\';\nimport crypto from \'crypto\';\n\nconst prisma = new PrismaClient();\n\nexport interface PatientRepositoryData {\n  id: string;\n  userId: string;\n  \n  // Identity Information (hashed, not stored in plain text)\n  identityHash: {\n    primary: string;\n    secondary: string;\n    composite: string;\n  };\n  \n  // Personal Information (encrypted)\n  personalInfo: PersonalInformation;\n  \n  // Medical Information\n  medicalInfo: MedicalInformation;\n  \n  // Documents\n  documents: DocumentReference[];\n  \n  // Stored Context (for AI analysis)\n  storedContext: StoredContext;\n  \n  // Preferences\n  preferences: PatientPreferences;\n  \n  // Metadata\n  createdAt: Date;\n  updatedAt: Date;\n  lastAccessedAt: Date;\n  version: number;\n}\n\nexport interface PersonalInformation {\n  // Encrypted fields\n  firstName: string;\n  middleName?: string;\n  lastName: string;\n  dateOfBirth: Date;\n  gender: \'male\' | \'female\' | \'other\' | \'prefer_not_to_say\';\n  placeOfBirth: {\n    city: string;\n    state: string;\n    country: string;\n  };\n  \n  // Contact (encrypted)\n  email: string;\n  phone?: string;\n  address?: {\n    street: string;\n    city: string;\n    state: string;\n    zipCode: string;\n    country: string;\n  };\n  \n  // Emergency Contact (encrypted)\n  emergencyContact?: {\n    name: string;\n    relationship: string;\n    phone: string;\n  };\n}\n\nexport interface MedicalInformation {\n  // Current Conditions\n  diagnoses: Diagnosis[];\n  \n  // Medications\n  medications: Medication[];\n  \n  // Allergies\n  allergies: Allergy[];\n  \n  // Vital Signs History\n  vitalSigns: VitalSign[];\n  \n  // Test Results\n  testResults: TestResult[];\n  \n  // Procedures\n  procedures: Procedure[];\n  \n  // Immunizations\n  immunizations: Immunization[];\n  \n  // Family History\n  familyHistory: FamilyHistory[];\n  \n  // Social History\n  socialHistory: SocialHistory;\n}\n\nexport interface Diagnosis {\n  id: string;\n  condition: string;\n  icd10Code?: string;\n  diagnosedDate: Date;\n  status: \'active\' | \'resolved\' | \'chronic\';\n  severity?: \'mild\' | \'moderate\' | \'severe\';\n  notes?: string;\n}\n\nexport interface Medication {\n  id: string;\n  name: string;\n  dosage: string;\n  frequency: string;\n  startDate: Date;\n  endDate?: Date;\n  prescribedBy?: string;\n  purpose?: string;\n  status: \'active\' | \'discontinued\' | \'completed\';\n}\n\nexport interface Allergy {\n  id: string;\n  allergen: string;\n  type: \'drug\' | \'food\' | \'environmental\' | \'other\';\n  reaction: string;\n  severity: \'mild\' | \'moderate\' | \'severe\' | \'life-threatening\';\n  diagnosedDate?: Date;\n}\n\nexport interface VitalSign {\n  id: string;\n  date: Date;\n  bloodPressure?: { systolic: number; diastolic: number };\n  heartRate?: number;\n  temperature?: number;\n  weight?: number;\n  height?: number;\n  bmi?: number;\n  oxygenSaturation?: number;\n}\n\nexport interface TestResult {\n  id: string;\n  documentId: string;\n  testType: string;\n  testDate: Date;\n  results: Record<string, any>;\n  abnormalFlags: string[];\n  interpretation?: string;\n}\n\nexport interface Procedure {\n  id: string;\n  name: string;\n  date: Date;\n  performedBy?: string;\n  location?: string;\n  notes?: string;\n}\n\nexport interface Immunization {\n  id: string;\n  vaccine: string;\n  date: Date;\n  doseNumber?: number;\n  administeredBy?: string;\n  lotNumber?: string;\n}\n\nexport interface FamilyHistory {\n  id: string;\n  relationship: string;\n  condition: string;\n  ageAtDiagnosis?: number;\n  notes?: string;\n}\n\nexport interface SocialHistory {\n  smokingStatus?: \'never\' | \'former\' | \'current\';\n  alcoholUse?: \'none\' | \'occasional\' | \'moderate\' | \'heavy\';\n  exerciseFrequency?: string;\n  occupation?: string;\n  maritalStatus?: string;\n}\n\nexport interface DocumentReference {\n  documentId: string;\n  type: string;\n  uploadDate: Date;\n  summary?: string;\n}\n\nexport interface StoredContext {\n  // Context from AI Context Cache Repository\n  recentAnalyses: string[];\n  importantFindings: string[];\n  trends: Record<string, any>;\n  lastUpdated: Date;\n}\n\nexport interface PatientPreferences {\n  language: string;\n  timezone: string;\n  notifications: {\n    email: boolean;\n    sms: boolean;\n    push: boolean;\n  };\n  privacySettings: {\n    shareDataForResearch: boolean;\n    allowAnonymousAnalytics: boolean;\n  };\n}\n\nexport class PatientRepository {\n  private readonly ENCRYPTION_ALGORITHM = \'aes-256-gcm\';\n  private readonly ENCRYPTION_KEY = process.env.PATIENT_DATA_ENCRYPTION_KEY || \'change-this-key-in-production\';\n\n  /**\n   * Create a new patient repository\n   * Enforces one repository per patient through identity verification\n   */\n  async createRepository(\n    userId: string,\n    identityFactors: IdentityFactors,\n    personalInfo: PersonalInformation\n  ): Promise<PatientRepositoryData> {\n    // Verify identity and check for existing repository\n    const verification = await identityVerificationService.verifyIdentity(identityFactors);\n\n    if (verification.existingRepositoryId) {\n      throw new Error(\n        \'A repository already exists for this identity. \' +\n        \'Please use account migration if you need to change your email/username.\'\n      );\n    }\n\n    if (!verification.verified || verification.confidence < 0.85) {\n      throw new Error(\n        \'Identity verification failed. Please provide additional verification factors.\'\n      );\n    }\n\n    // Generate identity hashes\n    const identityHash = identityVerificationService.generateIdentityHash(identityFactors);\n\n    // Encrypt personal information\n    const encryptedPersonalInfo = this.encryptData(personalInfo);\n\n    // Create repository\n    const repositoryId = this.generateRepositoryId();\n\n    await prisma.$executeRaw`\n      INSERT INTO patient_repositories (\n        id, user_id, primary_identity_hash, secondary_identity_hash, \n        composite_identity_hash, encrypted_personal_info, created_at, updated_at, version\n      ) VALUES (\n        ${repositoryId}, ${userId}, ${identityHash.primaryHash}, \n        ${identityHash.secondaryHash}, ${identityHash.compositeHash},\n        ${encryptedPersonalInfo}, NOW(), NOW(), 1\n      )\n    `;\n\n    // Initialize empty medical info\n    await this.initializeMedicalInfo(repositoryId);\n\n    // Log creation\n    await auditLogger.log({\n      userId,\n      action: \'repository_created\',\n      resource: \'patient_repository\',\n      resourceId: repositoryId,\n      details: {\n        verificationConfidence: verification.confidence,\n        matchedFactors: verification.matchedFactors\n      },\n      severity: \'high\'\n    });\n\n    return await this.getRepository(repositoryId);\n  }\n\n  /**\n   * Get patient repository\n   */\n  async getRepository(repositoryId: string): Promise<PatientRepositoryData> {\n    const result = await prisma.$queryRaw<any[]>`\n      SELECT * FROM patient_repositories WHERE id = ${repositoryId}\n    `;\n\n    if (!result || result.length === 0) {\n      throw new Error(\'Repository not found\');\n    }\n\n    const repo = result[0];\n\n    // Decrypt personal information\n    const personalInfo = this.decryptData(repo.encrypted_personal_info);\n\n    // Get medical information\n    const medicalInfo = await this.getMedicalInfo(repositoryId);\n\n    // Get documents\n    const documents = await this.getDocuments(repositoryId);\n\n    // Get stored context\n    const storedContext = await this.getStoredContext(repositoryId);\n\n    // Get preferences\n    const preferences = await this.getPreferences(repositoryId);\n\n    // Update last accessed\n    await this.updateLastAccessed(repositoryId);\n\n    return {\n      id: repo.id,\n      userId: repo.user_id,\n      identityHash: {\n        primary: repo.primary_identity_hash,\n        secondary: repo.secondary_identity_hash,\n        composite: repo.composite_identity_hash\n      },\n      personalInfo,\n      medicalInfo,\n      documents,\n      storedContext,\n      preferences,\n      createdAt: repo.created_at,\n      updatedAt: repo.updated_at,\n      lastAccessedAt: repo.last_accessed_at,\n      version: repo.version\n    };\n  }\n\n  /**\n   * Get repository by user ID\n   */\n  async getRepositoryByUserId(userId: string): Promise<PatientRepositoryData> {\n    const result = await prisma.$queryRaw<any[]>`\n      SELECT id FROM patient_repositories WHERE user_id = ${userId}\n    `;\n\n    if (!result || result.length === 0) {\n      throw new Error(\'No repository found for user\');\n    }\n\n    return await this.getRepository(result[0].id);\n  }\n\n  /**\n   * Update personal information\n   */\n  async updatePersonalInfo(\n    repositoryId: string,\n    personalInfo: Partial<PersonalInformation>\n  ): Promise<void> {\n    const current = await this.getRepository(repositoryId);\n    const updated = { ...current.personalInfo, ...personalInfo };\n\n    const encrypted = this.encryptData(updated);\n\n    await prisma.$executeRaw`\n      UPDATE patient_repositories \n      SET encrypted_personal_info = ${encrypted},\n          updated_at = NOW(),\n          version = version + 1\n      WHERE id = ${repositoryId}\n    `;\n\n    await auditLogger.log({\n      userId: current.userId,\n      action: \'personal_info_updated\',\n      resource: \'patient_repository\',\n      resourceId: repositoryId,\n      details: { updatedFields: Object.keys(personalInfo) },\n      severity: \'medium\'\n    });\n  }\n\n  /**\n   * Add diagnosis\n   */\n  async addDiagnosis(repositoryId: string, diagnosis: Omit<Diagnosis, \'id\'>): Promise<string> {\n    const diagnosisId = this.generateId(\'diagnosis\');\n    \n    await prisma.$executeRaw`\n      INSERT INTO patient_diagnoses (\n        id, repository_id, condition, icd10_code, diagnosed_date, \n        status, severity, notes, created_at\n      ) VALUES (\n        ${diagnosisId}, ${repositoryId}, ${diagnosis.condition}, \n        ${diagnosis.icd10Code}, ${diagnosis.diagnosedDate}, ${diagnosis.status},\n        ${diagnosis.severity}, ${diagnosis.notes}, NOW()\n      )\n    `;\n\n    return diagnosisId;\n  }\n\n  /**\n   * Add medication\n   */\n  async addMedication(repositoryId: string, medication: Omit<Medication, \'id\'>): Promise<string> {\n    const medicationId = this.generateId(\'medication\');\n    \n    await prisma.$executeRaw`\n      INSERT INTO patient_medications (\n        id, repository_id, name, dosage, frequency, start_date,\n        end_date, prescribed_by, purpose, status, created_at\n      ) VALUES (\n        ${medicationId}, ${repositoryId}, ${medication.name}, ${medication.dosage},\n        ${medication.frequency}, ${medication.startDate}, ${medication.endDate},\n        ${medication.prescribedBy}, ${medication.purpose}, ${medication.status}, NOW()\n      )\n    `;\n\n    return medicationId;\n  }\n\n  /**\n   * Add allergy\n   */\n  async addAllergy(repositoryId: string, allergy: Omit<Allergy, \'id\'>): Promise<string> {\n    const allergyId = this.generateId(\'allergy\');\n    \n    await prisma.$executeRaw`\n      INSERT INTO patient_allergies (\n        id, repository_id, allergen, type, reaction, severity,\n        diagnosed_date, created_at\n      ) VALUES (\n        ${allergyId}, ${repositoryId}, ${allergy.allergen}, ${allergy.type},\n        ${allergy.reaction}, ${allergy.severity}, ${allergy.diagnosedDate}, NOW()\n      )\n    `;\n\n    return allergyId;\n  }\n\n  /**\n   * Add vital signs\n   */\n  async addVitalSigns(repositoryId: string, vitalSign: Omit<VitalSign, \'id\'>): Promise<string> {\n    const vitalSignId = this.generateId(\'vital\');\n    \n    await prisma.$executeRaw`\n      INSERT INTO patient_vital_signs (\n        id, repository_id, date, blood_pressure_systolic, blood_pressure_diastolic,\n        heart_rate, temperature, weight, height, bmi, oxygen_saturation, created_at\n      ) VALUES (\n        ${vitalSignId}, ${repositoryId}, ${vitalSign.date},\n        ${vitalSign.bloodPressure?.systolic}, ${vitalSign.bloodPressure?.diastolic},\n        ${vitalSign.heartRate}, ${vitalSign.temperature}, ${vitalSign.weight},\n        ${vitalSign.height}, ${vitalSign.bmi}, ${vitalSign.oxygenSaturation}, NOW()\n      )\n    `;\n\n    return vitalSignId;\n  }\n\n  /**\n   * Migrate account to new email/username\n   */\n  async migrateAccount(\n    repositoryId: string,\n    newUserId: string,\n    identityFactors: IdentityFactors,\n    verificationToken: string\n  ): Promise<void> {\n    // Verify identity for migration\n    const verification = await identityVerificationService.verifyForMigration(\n      repositoryId,\n      identityFactors,\n      {\n        currentEmail: \'\', // Would get from current user\n        mfaToken: verificationToken\n      }\n    );\n\n    if (!verification.verified || verification.confidence < 0.9) {\n      throw new Error(\'Identity verification failed for migration. Higher confidence required.\');\n    }\n\n    const oldUserId = await this.getUserIdFromRepository(repositoryId);\n\n    // Update repository with new user ID\n    await prisma.$executeRaw`\n      UPDATE patient_repositories \n      SET user_id = ${newUserId},\n          updated_at = NOW(),\n          version = version + 1\n      WHERE id = ${repositoryId}\n    `;\n\n    // Log migration\n    await auditLogger.log({\n      userId: newUserId,\n      action: \'account_migrated\',\n      resource: \'patient_repository\',\n      resourceId: repositoryId,\n      details: {\n        oldUserId,\n        newUserId,\n        verificationConfidence: verification.confidence\n      },\n      severity: \'critical\',\n      requiresReview: true\n    });\n  }\n\n  /**\n   * Delete and purge repository\n   * This is irreversible and removes ALL patient data\n   */\n  async deleteAndPurgeRepository(\n    repositoryId: string,\n    userId: string,\n    confirmationToken: string\n  ): Promise<void> {\n    // Verify user owns this repository\n    const repository = await this.getRepository(repositoryId);\n    \n    if (repository.userId !== userId) {\n      throw new Error(\'Unauthorized: You do not own this repository\');\n    }\n\n    // Verify confirmation token (should be generated and sent to user)\n    const isValidToken = await this.verifyDeletionToken(userId, confirmationToken);\n    \n    if (!isValidToken) {\n      throw new Error(\'Invalid confirmation token\');\n    }\n\n    // Log deletion BEFORE deleting\n    await auditLogger.log({\n      userId,\n      action: \'repository_deleted\',\n      resource: \'patient_repository\',\n      resourceId: repositoryId,\n      details: {\n        personalInfo: repository.personalInfo, // Log for audit before deletion\n        documentCount: repository.documents.length,\n        diagnosesCount: repository.medicalInfo.diagnoses.length\n      },\n      severity: \'critical\',\n      requiresReview: true\n    });\n\n    // Delete all related data\n    await this.purgeAllData(repositoryId);\n\n    // Delete repository\n    await prisma.$executeRaw`\n      DELETE FROM patient_repositories WHERE id = ${repositoryId}\n    `;\n\n    console.log(`[PatientRepository] Repository ${repositoryId} completely purged`);\n  }\n\n  /**\n   * Get repository statistics\n   */\n  async getRepositoryStats(repositoryId: string): Promise<RepositoryStatistics> {\n    const repository = await this.getRepository(repositoryId);\n\n    return {\n      totalDocuments: repository.documents.length,\n      totalDiagnoses: repository.medicalInfo.diagnoses.length,\n      totalMedications: repository.medicalInfo.medications.filter(m => m.status === \'active\').length,\n      totalAllergies: repository.medicalInfo.allergies.length,\n      totalVitalSigns: repository.medicalInfo.vitalSigns.length,\n      totalTestResults: repository.medicalInfo.testResults.length,\n      lastUpdated: repository.updatedAt,\n      dataCompleteness: this.calculateDataCompleteness(repository)\n    };\n  }\n\n  // Private helper methods\n\n  private encryptData(data: any): string {\n    const iv = crypto.randomBytes(16);\n    const key = crypto.scryptSync(this.ENCRYPTION_KEY, \'salt\', 32);\n    const cipher = crypto.createCipheriv(this.ENCRYPTION_ALGORITHM, key, iv);\n    \n    let encrypted = cipher.update(JSON.stringify(data), \'utf8\', \'hex\');\n    encrypted += cipher.final(\'hex\');\n    \n    const authTag = cipher.getAuthTag();\n    \n    return JSON.stringify({\n      iv: iv.toString(\'hex\'),\n      data: encrypted,\n      authTag: authTag.toString(\'hex\')\n    });\n  }\n\n  private decryptData(encryptedData: string): any {\n    const { iv, data, authTag } = JSON.parse(encryptedData);\n    const key = crypto.scryptSync(this.ENCRYPTION_KEY, \'salt\', 32);\n    \n    const decipher = crypto.createDecipheriv(\n      this.ENCRYPTION_ALGORITHM,\n      key,\n      Buffer.from(iv, \'hex\')\n    );\n    \n    decipher.setAuthTag(Buffer.from(authTag, \'hex\'));\n    \n    let decrypted = decipher.update(data, \'hex\', \'utf8\');\n    decrypted += decipher.final(\'utf8\');\n    \n    return JSON.parse(decrypted);\n  }\n\n  private generateRepositoryId(): string {\n    return `repo_${Date.now()}_${crypto.randomBytes(16).toString(\'hex\')}`;\n  }\n\n  private generateId(prefix: string): string {\n    return `${prefix}_${Date.now()}_${crypto.randomBytes(8).toString(\'hex\')}`;\n  }\n\n  private async initializeMedicalInfo(repositoryId: string): Promise<void> {\n    // Initialize empty medical info tables\n    // This creates the structure for storing medical data\n  }\n\n  private async getMedicalInfo(repositoryId: string): Promise<MedicalInformation> {\n    // Get all medical information from various tables\n    const diagnoses = await this.getDiagnoses(repositoryId);\n    const medications = await this.getMedications(repositoryId);\n    const allergies = await this.getAllergies(repositoryId);\n    const vitalSigns = await this.getVitalSigns(repositoryId);\n    const testResults = await this.getTestResults(repositoryId);\n    const procedures = await this.getProcedures(repositoryId);\n    const immunizations = await this.getImmunizations(repositoryId);\n    const familyHistory = await this.getFamilyHistory(repositoryId);\n    const socialHistory = await this.getSocialHistory(repositoryId);\n\n    return {\n      diagnoses,\n      medications,\n      allergies,\n      vitalSigns,\n      testResults,\n      procedures,\n      immunizations,\n      familyHistory,\n      socialHistory\n    };\n  }\n\n  private async getDiagnoses(repositoryId: string): Promise<Diagnosis[]> {\n    const results = await prisma.$queryRaw<any[]>`\n      SELECT * FROM patient_diagnoses WHERE repository_id = ${repositoryId}\n      ORDER BY diagnosed_date DESC\n    `;\n\n    return results.map(r => ({\n      id: r.id,\n      condition: r.condition,\n      icd10Code: r.icd10_code,\n      diagnosedDate: r.diagnosed_date,\n      status: r.status,\n      severity: r.severity,\n      notes: r.notes\n    }));\n  }\n\n  private async getMedications(repositoryId: string): Promise<Medication[]> {\n    const results = await prisma.$queryRaw<any[]>`\n      SELECT * FROM patient_medications WHERE repository_id = ${repositoryId}\n      ORDER BY start_date DESC\n    `;\n\n    return results.map(r => ({\n      id: r.id,\n      name: r.name,\n      dosage: r.dosage,\n      frequency: r.frequency,\n      startDate: r.start_date,\n      endDate: r.end_date,\n      prescribedBy: r.prescribed_by,\n      purpose: r.purpose,\n      status: r.status\n    }));\n  }\n\n  private async getAllergies(repositoryId: string): Promise<Allergy[]> {\n    const results = await prisma.$queryRaw<any[]>`\n      SELECT * FROM patient_allergies WHERE repository_id = ${repositoryId}\n    `;\n\n    return results.map(r => ({\n      id: r.id,\n      allergen: r.allergen,\n      type: r.type,\n      reaction: r.reaction,\n      severity: r.severity,\n      diagnosedDate: r.diagnosed_date\n    }));\n  }\n\n  private async getVitalSigns(repositoryId: string): Promise<VitalSign[]> {\n    const results = await prisma.$queryRaw<any[]>`\n      SELECT * FROM patient_vital_signs WHERE repository_id = ${repositoryId}\n      ORDER BY date DESC LIMIT 100\n    `;\n\n    return results.map(r => ({\n      id: r.id,\n      date: r.date,\n      bloodPressure: r.blood_pressure_systolic ? {\n        systolic: r.blood_pressure_systolic,\n        diastolic: r.blood_pressure_diastolic\n      } : undefined,\n      heartRate: r.heart_rate,\n      temperature: r.temperature,\n      weight: r.weight,\n      height: r.height,\n      bmi: r.bmi,\n      oxygenSaturation: r.oxygen_saturation\n    }));\n  }\n\n  private async getTestResults(repositoryId: string): Promise<TestResult[]> {\n    // Implementation would query test results\n    return [];\n  }\n\n  private async getProcedures(repositoryId: string): Promise<Procedure[]> {\n    // Implementation would query procedures\n    return [];\n  }\n\n  private async getImmunizations(repositoryId: string): Promise<Immunization[]> {\n    // Implementation would query immunizations\n    return [];\n  }\n\n  private async getFamilyHistory(repositoryId: string): Promise<FamilyHistory[]> {\n    // Implementation would query family history\n    return [];\n  }\n\n  private async getSocialHistory(repositoryId: string): Promise<SocialHistory> {\n    // Implementation would query social history\n    return {};\n  }\n\n  private async getDocuments(repositoryId: string): Promise<DocumentReference[]> {\n    const results = await prisma.$queryRaw<any[]>`\n      SELECT d.id, d.document_type, d.upload_date\n      FROM documents d\n      JOIN patient_repositories pr ON d.user_id = pr.user_id\n      WHERE pr.id = ${repositoryId}\n      ORDER BY d.upload_date DESC\n    `;\n\n    return results.map(r => ({\n      documentId: r.id,\n      type: r.document_type,\n      uploadDate: r.upload_date\n    }));\n  }\n\n  private async getStoredContext(repositoryId: string): Promise<StoredContext> {\n    // Get stored context from AI Context Cache Repository\n    return {\n      recentAnalyses: [],\n      importantFindings: [],\n      trends: {},\n      lastUpdated: new Date()\n    };\n  }\n\n  private async getPreferences(repositoryId: string): Promise<PatientPreferences> {\n    // Get patient preferences\n    return {\n      language: \'en\',\n      timezone: \'UTC\',\n      notifications: {\n        email: true,\n        sms: false,\n        push: true\n      },\n      privacySettings: {\n        shareDataForResearch: false,\n        allowAnonymousAnalytics: true\n      }\n    };\n  }\n\n  private async updateLastAccessed(repositoryId: string): Promise<void> {\n    await prisma.$executeRaw`\n      UPDATE patient_repositories \n      SET last_accessed_at = NOW()\n      WHERE id = ${repositoryId}\n    `;\n  }\n\n  private async getUserIdFromRepository(repositoryId: string): Promise<string> {\n    const result = await prisma.$queryRaw<any[]>`\n      SELECT user_id FROM patient_repositories WHERE id = ${repositoryId}\n    `;\n\n    return result[0].user_id;\n  }\n\n  private async verifyDeletionToken(userId: string, token: string): Promise<boolean> {\n    // Verify deletion confirmation token\n    // In production, this would check a token sent to user\'s email\n    return true;\n  }\n\n  private async purgeAllData(repositoryId: string): Promise<void> {\n    // Delete all related data in correct order\n    await prisma.$executeRaw`DELETE FROM patient_diagnoses WHERE repository_id = ${repositoryId}`;\n    await prisma.$executeRaw`DELETE FROM patient_medications WHERE repository_id = ${repositoryId}`;\n    await prisma.$executeRaw`DELETE FROM patient_allergies WHERE repository_id = ${repositoryId}`;\n    await prisma.$executeRaw`DELETE FROM patient_vital_signs WHERE repository_id = ${repositoryId}`;\n    // ... delete from all other related tables\n  }\n\n  private calculateDataCompleteness(repository: PatientRepositoryData): number {\n    let score = 0;\n    let total = 0;\n\n    // Personal info completeness\n    if (repository.personalInfo.firstName) score++;\n    total++;\n    if (repository.personalInfo.dateOfBirth) score++;\n    total++;\n    if (repository.personalInfo.gender) score++;\n    total++;\n\n    // Medical info completeness\n    if (repository.medicalInfo.diagnoses.length > 0) score++;\n    total++;\n    if (repository.medicalInfo.medications.length > 0) score++;\n    total++;\n    if (repository.medicalInfo.allergies.length > 0) score++;\n    total++;\n\n    return score / total;\n  }\n}\n\nexport interface RepositoryStatistics {\n  totalDocuments: number;\n  totalDiagnoses: number;\n  totalMedications: number;\n  totalAllergies: number;\n  totalVitalSigns: number;\n  totalTestResults: number;\n  lastUpdated: Date;\n  dataCompleteness: number;\n}\n\nexport const patientRepository = new PatientRepository();\n</create-file>\n</function_calls>'}