{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/services/DevelopmentEnhancementService.ts">\n/**\n * Development & Enhancement Repository Service\n * \n * Manages feature requests, roadmap planning, and enhancement tracking.\n * Integrates with Bug Repository for bug-driven improvements.\n */\n\nimport { PrismaClient, Feature, FeatureStatus, FeaturePriority, FeatureType, Roadmap } from \'@prisma/client\';\n\nconst prisma = new PrismaClient();\n\ninterface FeatureRequest {\n  title: string;\n  description: string;\n  type: FeatureType;\n  priority?: FeaturePriority;\n  requestedBy?: string;\n  requestedByEmail?: string;\n  businessValue?: string;\n  targetAudience?: string;\n  expectedImpact?: string;\n  successMetrics?: string;\n  technicalSpec?: string;\n  estimatedEffort?: number;\n  complexity?: number;\n  dependsOn?: string[];\n  blockedBy?: string[];\n  relatedBugs?: string[];\n  tags?: string[];\n  attachments?: string[];\n}\n\ninterface RoadmapPlan {\n  name: string;\n  description?: string;\n  version: string;\n  startDate: Date;\n  endDate: Date;\n  features: string[];\n  goals: string[];\n}\n\ninterface ImpactAnalysis {\n  featureId: string;\n  technicalImpact: {\n    complexity: number;\n    effort: number;\n    risk: string;\n    dependencies: string[];\n  };\n  businessImpact: {\n    value: number;\n    audience: string;\n    expectedOutcome: string;\n  };\n  resourceImpact: {\n    developmentTime: number;\n    testingTime: number;\n    documentationTime: number;\n  };\n  overallScore: number;\n}\n\nexport class DevelopmentEnhancementService {\n  /**\n   * Submit a new feature request\n   */\n  async submitFeatureRequest(request: FeatureRequest): Promise<Feature> {\n    const feature = await prisma.feature.create({\n      data: {\n        title: request.title,\n        description: request.description,\n        type: request.type,\n        priority: request.priority || FeaturePriority.MEDIUM,\n        status: FeatureStatus.PROPOSED,\n        requestedBy: request.requestedBy,\n        requestedByEmail: request.requestedByEmail,\n        businessValue: request.businessValue,\n        targetAudience: request.targetAudience,\n        expectedImpact: request.expectedImpact,\n        successMetrics: request.successMetrics,\n        technicalSpec: request.technicalSpec,\n        estimatedEffort: request.estimatedEffort,\n        complexity: request.complexity,\n        dependsOn: request.dependsOn || [],\n        blockedBy: request.blockedBy || [],\n        relatedBugs: request.relatedBugs || [],\n        tags: request.tags || [],\n        attachments: request.attachments || [],\n      },\n    });\n\n    // Log feature creation\n    await this.logFeatureHistory(feature.id, \'status\', null, FeatureStatus.PROPOSED, \'SYSTEM\');\n\n    // Notify stakeholders\n    await this.notifyFeatureCreated(feature);\n\n    return feature;\n  }\n\n  /**\n   * Evaluate a feature request\n   */\n  async evaluateFeature(featureId: string, evaluation: {\n    approved: boolean;\n    priority?: FeaturePriority;\n    targetRelease?: string;\n    targetDate?: Date;\n    feedback?: string;\n    evaluatedBy: string;\n  }): Promise<Feature> {\n    const feature = await prisma.feature.findUnique({ where: { id: featureId } });\n    if (!feature) throw new Error(\'Feature not found\');\n\n    const newStatus = evaluation.approved ? FeatureStatus.APPROVED : FeatureStatus.REJECTED;\n\n    const updates: any = {\n      status: newStatus,\n      updatedAt: new Date(),\n    };\n\n    if (evaluation.priority) {\n      updates.priority = evaluation.priority;\n      await this.logFeatureHistory(featureId, \'priority\', feature.priority, evaluation.priority, evaluation.evaluatedBy);\n    }\n\n    if (evaluation.targetRelease) {\n      updates.targetRelease = evaluation.targetRelease;\n    }\n\n    if (evaluation.targetDate) {\n      updates.targetDate = evaluation.targetDate;\n    }\n\n    await this.logFeatureHistory(featureId, \'status\', feature.status, newStatus, evaluation.evaluatedBy);\n\n    if (evaluation.feedback) {\n      await this.addComment(featureId, evaluation.evaluatedBy, \'Evaluation Team\', evaluation.feedback, true);\n    }\n\n    return await prisma.feature.update({\n      where: { id: featureId },\n      data: updates,\n    });\n  }\n\n  /**\n   * Add feature to roadmap\n   */\n  async addToRoadmap(featureId: string, targetRelease: string, targetDate?: Date): Promise<Feature> {\n    const feature = await prisma.feature.findUnique({ where: { id: featureId } });\n    if (!feature) throw new Error(\'Feature not found\');\n\n    // Check dependencies\n    const blockedDependencies = await this.checkDependencies(featureId);\n    if (blockedDependencies.length > 0) {\n      throw new Error(`Feature is blocked by: ${blockedDependencies.join(\', \')}`);\n    }\n\n    const updates: any = {\n      status: FeatureStatus.PLANNED,\n      targetRelease,\n      updatedAt: new Date(),\n    };\n\n    if (targetDate) {\n      updates.targetDate = targetDate;\n    }\n\n    await this.logFeatureHistory(featureId, \'status\', feature.status, FeatureStatus.PLANNED, \'ROADMAP_SYSTEM\');\n\n    return await prisma.feature.update({\n      where: { id: featureId },\n      data: updates,\n    });\n  }\n\n  /**\n   * Start feature development\n   */\n  async startDevelopment(featureId: string, assignedTo: string): Promise<Feature> {\n    const feature = await prisma.feature.findUnique({ where: { id: featureId } });\n    if (!feature) throw new Error(\'Feature not found\');\n\n    const updates: any = {\n      status: FeatureStatus.IN_PROGRESS,\n      assignedTo,\n      assignedAt: new Date(),\n      startedAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    await this.logFeatureHistory(featureId, \'status\', feature.status, FeatureStatus.IN_PROGRESS, assignedTo);\n\n    return await prisma.feature.update({\n      where: { id: featureId },\n      data: updates,\n    });\n  }\n\n  /**\n   * Complete feature development\n   */\n  async completeFeature(featureId: string, implementedBy: string): Promise<Feature> {\n    const feature = await prisma.feature.findUnique({ where: { id: featureId } });\n    if (!feature) throw new Error(\'Feature not found\');\n\n    const updates: any = {\n      status: FeatureStatus.COMPLETED,\n      completedAt: new Date(),\n      implementedBy,\n      updatedAt: new Date(),\n    };\n\n    await this.logFeatureHistory(featureId, \'status\', feature.status, FeatureStatus.COMPLETED, implementedBy);\n\n    return await prisma.feature.update({\n      where: { id: featureId },\n      data: updates,\n    });\n  }\n\n  /**\n   * Create a roadmap\n   */\n  async createRoadmap(plan: RoadmapPlan): Promise<Roadmap> {\n    // Validate features exist and are approved\n    const features = await prisma.feature.findMany({\n      where: {\n        id: { in: plan.features },\n        status: { in: [FeatureStatus.APPROVED, FeatureStatus.PLANNED] },\n      },\n    });\n\n    if (features.length !== plan.features.length) {\n      throw new Error(\'Some features are not approved or do not exist\');\n    }\n\n    const roadmap = await prisma.roadmap.create({\n      data: {\n        name: plan.name,\n        description: plan.description,\n        version: plan.version,\n        startDate: plan.startDate,\n        endDate: plan.endDate,\n        features: plan.features,\n        goals: plan.goals,\n        status: \'PLANNING\',\n      },\n    });\n\n    // Update features to reference this roadmap\n    await prisma.feature.updateMany({\n      where: { id: { in: plan.features } },\n      data: {\n        targetRelease: plan.version,\n        status: FeatureStatus.PLANNED,\n      },\n    });\n\n    return roadmap;\n  }\n\n  /**\n   * Get roadmap by version\n   */\n  async getRoadmap(version: string): Promise<Roadmap | null> {\n    return await prisma.roadmap.findFirst({\n      where: { version },\n    });\n  }\n\n  /**\n   * Get all active roadmaps\n   */\n  async getActiveRoadmaps(): Promise<Roadmap[]> {\n    return await prisma.roadmap.findMany({\n      where: {\n        status: { in: [\'PLANNING\', \'ACTIVE\'] },\n      },\n      orderBy: { startDate: \'asc\' },\n    });\n  }\n\n  /**\n   * Perform impact analysis on a feature\n   */\n  async performImpactAnalysis(featureId: string): Promise<ImpactAnalysis> {\n    const feature = await prisma.feature.findUnique({ where: { id: featureId } });\n    if (!feature) throw new Error(\'Feature not found\');\n\n    // Technical Impact\n    const technicalImpact = {\n      complexity: feature.complexity || 5,\n      effort: feature.estimatedEffort || 0,\n      risk: this.assessRisk(feature),\n      dependencies: feature.dependsOn,\n    };\n\n    // Business Impact\n    const businessImpact = {\n      value: this.calculateBusinessValue(feature),\n      audience: feature.targetAudience || \'Unknown\',\n      expectedOutcome: feature.expectedImpact || \'Not specified\',\n    };\n\n    // Resource Impact\n    const resourceImpact = {\n      developmentTime: feature.estimatedEffort || 0,\n      testingTime: Math.ceil((feature.estimatedEffort || 0) * 0.3),\n      documentationTime: Math.ceil((feature.estimatedEffort || 0) * 0.1),\n    };\n\n    // Calculate overall score (0-100)\n    const overallScore = this.calculateOverallScore(technicalImpact, businessImpact, resourceImpact);\n\n    return {\n      featureId,\n      technicalImpact,\n      businessImpact,\n      resourceImpact,\n      overallScore,\n    };\n  }\n\n  /**\n   * Get features by priority\n   */\n  async getFeaturesByPriority(priority: FeaturePriority, status?: FeatureStatus): Promise<Feature[]> {\n    const where: any = { priority };\n\n    if (status) {\n      where.status = status;\n    }\n\n    return await prisma.feature.findMany({\n      where,\n      orderBy: [\n        { requestedAt: \'asc\' },\n      ],\n    });\n  }\n\n  /**\n   * Get features for a release\n   */\n  async getFeaturesForRelease(version: string): Promise<Feature[]> {\n    return await prisma.feature.findMany({\n      where: { targetRelease: version },\n      orderBy: [\n        { priority: \'desc\' },\n        { status: \'asc\' },\n      ],\n    });\n  }\n\n  /**\n   * Get bug-driven enhancements\n   */\n  async getBugDrivenEnhancements(): Promise<Feature[]> {\n    return await prisma.feature.findMany({\n      where: {\n        type: FeatureType.ENHANCEMENT,\n        relatedBugs: { isEmpty: false },\n        status: { in: [FeatureStatus.PROPOSED, FeatureStatus.APPROVED, FeatureStatus.PLANNED] },\n      },\n      orderBy: [\n        { priority: \'desc\' },\n      ],\n    });\n  }\n\n  /**\n   * Get feature statistics\n   */\n  async getFeatureStatistics(): Promise<any> {\n    const [\n      totalFeatures,\n      proposedFeatures,\n      inProgressFeatures,\n      completedFeatures,\n      featuresByType,\n      featuresByPriority,\n      featuresByStatus,\n      averageCompletionTime,\n    ] = await Promise.all([\n      prisma.feature.count(),\n      prisma.feature.count({ where: { status: FeatureStatus.PROPOSED } }),\n      prisma.feature.count({ where: { status: FeatureStatus.IN_PROGRESS } }),\n      prisma.feature.count({ where: { status: FeatureStatus.COMPLETED } }),\n      this.getFeatureCountByType(),\n      this.getFeatureCountByPriority(),\n      this.getFeatureCountByStatus(),\n      this.calculateAverageCompletionTime(),\n    ]);\n\n    return {\n      total: totalFeatures,\n      proposed: proposedFeatures,\n      inProgress: inProgressFeatures,\n      completed: completedFeatures,\n      byType: featuresByType,\n      byPriority: featuresByPriority,\n      byStatus: featuresByStatus,\n      averageCompletionTime,\n    };\n  }\n\n  /**\n   * Vote on a feature\n   */\n  async voteOnFeature(featureId: string, userId: string, vote: number, comment?: string): Promise<void> {\n    await prisma.featureVote.upsert({\n      where: {\n        featureId_userId: {\n          featureId,\n          userId,\n        },\n      },\n      create: {\n        featureId,\n        userId,\n        vote,\n        comment,\n      },\n      update: {\n        vote,\n        comment,\n      },\n    });\n  }\n\n  /**\n   * Get feature votes\n   */\n  async getFeatureVotes(featureId: string): Promise<{ upvotes: number; downvotes: number; total: number }> {\n    const votes = await prisma.featureVote.findMany({\n      where: { featureId },\n    });\n\n    const upvotes = votes.filter(v => v.vote > 0).length;\n    const downvotes = votes.filter(v => v.vote < 0).length;\n\n    return {\n      upvotes,\n      downvotes,\n      total: upvotes - downvotes,\n    };\n  }\n\n  /**\n   * Add comment to feature\n   */\n  async addComment(featureId: string, authorId: string, authorName: string, content: string, isInternal: boolean = false): Promise<void> {\n    await prisma.featureComment.create({\n      data: {\n        featureId,\n        authorId,\n        authorName,\n        content,\n        isInternal,\n      },\n    });\n  }\n\n  /**\n   * Create feature task\n   */\n  async createTask(featureId: string, task: {\n    title: string;\n    description?: string;\n    assignedTo?: string;\n    estimatedHours?: number;\n  }): Promise<void> {\n    await prisma.featureTask.create({\n      data: {\n        featureId,\n        ...task,\n      },\n    });\n  }\n\n  /**\n   * Update task status\n   */\n  async updateTaskStatus(taskId: string, status: string, actualHours?: number): Promise<void> {\n    const updates: any = { status };\n\n    if (status === \'DONE\') {\n      updates.completedAt = new Date();\n    }\n\n    if (actualHours !== undefined) {\n      updates.actualHours = actualHours;\n    }\n\n    await prisma.featureTask.update({\n      where: { id: taskId },\n      data: updates,\n    });\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  private async checkDependencies(featureId: string): Promise<string[]> {\n    const feature = await prisma.feature.findUnique({ where: { id: featureId } });\n    if (!feature || feature.dependsOn.length === 0) return [];\n\n    const dependencies = await prisma.feature.findMany({\n      where: {\n        id: { in: feature.dependsOn },\n        status: { notIn: [FeatureStatus.COMPLETED] },\n      },\n    });\n\n    return dependencies.map(d => d.title);\n  }\n\n  private assessRisk(feature: Feature): string {\n    const complexity = feature.complexity || 5;\n    const hasDependencies = feature.dependsOn.length > 0;\n    const isBlocked = feature.blockedBy.length > 0;\n\n    if (complexity >= 8 || isBlocked) return \'HIGH\';\n    if (complexity >= 5 || hasDependencies) return \'MEDIUM\';\n    return \'LOW\';\n  }\n\n  private calculateBusinessValue(feature: Feature): number {\n    let value = 50; // Base value\n\n    // Adjust based on priority\n    const priorityBonus = {\n      [FeaturePriority.CRITICAL]: 40,\n      [FeaturePriority.HIGH]: 30,\n      [FeaturePriority.MEDIUM]: 20,\n      [FeaturePriority.LOW]: 10,\n      [FeaturePriority.BACKLOG]: 5,\n    };\n    value += priorityBonus[feature.priority];\n\n    // Adjust based on type\n    if (feature.type === FeatureType.SECURITY) value += 20;\n    if (feature.type === FeatureType.PERFORMANCE) value += 15;\n\n    // Adjust based on related bugs\n    if (feature.relatedBugs.length > 0) value += feature.relatedBugs.length * 5;\n\n    return Math.min(value, 100);\n  }\n\n  private calculateOverallScore(technical: any, business: any, resource: any): number {\n    // Business value (40%)\n    const businessScore = business.value * 0.4;\n\n    // Technical feasibility (30%) - inverse of complexity\n    const technicalScore = (10 - technical.complexity) * 3;\n\n    // Resource efficiency (30%) - inverse of effort\n    const resourceScore = Math.max(0, 30 - (resource.developmentTime / 10));\n\n    return Math.round(businessScore + technicalScore + resourceScore);\n  }\n\n  private async logFeatureHistory(featureId: string, field: string, oldValue: string | null, newValue: string, changedBy: string): Promise<void> {\n    await prisma.featureHistory.create({\n      data: {\n        featureId,\n        field,\n        oldValue,\n        newValue,\n        changedBy,\n      },\n    });\n  }\n\n  private async notifyFeatureCreated(feature: Feature): Promise<void> {\n    // TODO: Implement notification logic\n    console.log(`Feature created: ${feature.id} - ${feature.title}`);\n  }\n\n  private async getFeatureCountByType(): Promise<any> {\n    const counts = await prisma.feature.groupBy({\n      by: [\'type\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.type] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async getFeatureCountByPriority(): Promise<any> {\n    const counts = await prisma.feature.groupBy({\n      by: [\'priority\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.priority] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async getFeatureCountByStatus(): Promise<any> {\n    const counts = await prisma.feature.groupBy({\n      by: [\'status\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.status] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async calculateAverageCompletionTime(): Promise<number> {\n    const completedFeatures = await prisma.feature.findMany({\n      where: {\n        status: FeatureStatus.COMPLETED,\n        completedAt: { not: null },\n        startedAt: { not: null },\n      },\n      select: {\n        startedAt: true,\n        completedAt: true,\n      },\n    });\n\n    if (completedFeatures.length === 0) return 0;\n\n    const totalTime = completedFeatures.reduce((sum, feature) => {\n      const completionTime = feature.completedAt!.getTime() - feature.startedAt!.getTime();\n      return sum + completionTime;\n    }, 0);\n\n    // Return average in days\n    return Math.round(totalTime / completedFeatures.length / (1000 * 60 * 60 * 24));\n  }\n}\n\nexport default DevelopmentEnhancementService;\n</create-file>\n</function_calls>'}