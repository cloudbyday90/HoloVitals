{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/services/IncidentManagementService.ts">\n/**\n * Incident Management Service\n * \n * Manages incidents from detection to resolution, including escalation,\n * communication, and post-incident reviews.\n */\n\nimport { PrismaClient, Incident, IncidentSeverity, IncidentStatus } from \'@prisma/client\';\nimport EmergencyRecoveryService from \'./EmergencyRecoveryService\';\nimport ChangeManagementService from \'./ChangeManagementService\';\nimport AIErrorDiagnosisService from \'./AIErrorDiagnosisService\';\n\nconst prisma = new PrismaClient();\n\ninterface IncidentData {\n  severity: IncidentSeverity;\n  title: string;\n  description: string;\n  affectedServices: string[];\n  affectedUsers?: number;\n  businessImpact?: string;\n  detectedBy: string;\n  detectionMethod: string;\n  errorEvents?: string[];\n}\n\ninterface StatusUpdate {\n  status: IncidentStatus;\n  message: string;\n  updatedBy: string;\n}\n\ninterface ResolutionData {\n  resolvedBy: string;\n  resolutionMethod: string;\n  resolutionSummary: string;\n  changeRequestId?: string;\n  restorationId?: string;\n}\n\nexport class IncidentManagementService {\n  private recoveryService: EmergencyRecoveryService;\n  private changeService: ChangeManagementService;\n  private diagnosisService: AIErrorDiagnosisService;\n\n  constructor() {\n    this.recoveryService = new EmergencyRecoveryService();\n    this.changeService = new ChangeManagementService();\n    this.diagnosisService = new AIErrorDiagnosisService();\n  }\n\n  /**\n   * Create and respond to incident\n   */\n  async createIncident(data: IncidentData): Promise<Incident> {\n    const incident = await prisma.incident.create({\n      data: {\n        severity: data.severity,\n        title: data.title,\n        description: data.description,\n        affectedServices: data.affectedServices,\n        affectedUsers: data.affectedUsers,\n        businessImpact: data.businessImpact,\n        detectedBy: data.detectedBy,\n        detectionMethod: data.detectionMethod,\n        errorEvents: data.errorEvents || [],\n        status: IncidentStatus.DETECTED,\n      },\n    });\n\n    // Immediate notification based on severity\n    await this.notifyIncidentDetected(incident);\n\n    // Auto-acknowledge SEV1 incidents\n    if (incident.severity === IncidentSeverity.SEV1) {\n      await this.acknowledgeIncident(incident.id, \'SYSTEM\');\n    }\n\n    return incident;\n  }\n\n  /**\n   * Acknowledge incident\n   */\n  async acknowledgeIncident(incidentId: string, acknowledgedBy: string): Promise<Incident> {\n    const incident = await prisma.incident.findUnique({\n      where: { id: incidentId },\n    });\n\n    if (!incident) {\n      throw new Error(\'Incident not found\');\n    }\n\n    const timeToAcknowledge = Math.floor(\n      (Date.now() - incident.detectedAt.getTime()) / (1000 * 60)\n    );\n\n    const updatedIncident = await prisma.incident.update({\n      where: { id: incidentId },\n      data: {\n        status: IncidentStatus.ACKNOWLEDGED,\n        acknowledgedAt: new Date(),\n        acknowledgedBy,\n        timeToAcknowledge,\n      },\n    });\n\n    await this.notifyIncidentAcknowledged(updatedIncident);\n\n    return updatedIncident;\n  }\n\n  /**\n   * Start incident investigation\n   */\n  async startInvestigation(incidentId: string, respondedBy: string): Promise<any> {\n    const incident = await prisma.incident.update({\n      where: { id: incidentId },\n      data: {\n        status: IncidentStatus.INVESTIGATING,\n        respondedAt: new Date(),\n        respondedBy,\n        timeToRespond: Math.floor(\n          (Date.now() - (await prisma.incident.findUnique({ where: { id: incidentId } }))!.detectedAt.getTime()) / (1000 * 60)\n        ),\n      },\n    });\n\n    // If error events are associated, get AI diagnosis\n    if (incident.errorEvents.length > 0) {\n      const diagnoses = await Promise.all(\n        incident.errorEvents.map(errorId => \n          this.diagnosisService.getErrorDiagnosis(errorId)\n        )\n      );\n\n      return {\n        incident,\n        diagnoses: diagnoses.filter(d => d !== null),\n      };\n    }\n\n    return { incident };\n  }\n\n  /**\n   * Identify root cause\n   */\n  async identifyRootCause(incidentId: string, rootCause: string): Promise<Incident> {\n    const incident = await prisma.incident.update({\n      where: { id: incidentId },\n      data: {\n        status: IncidentStatus.IDENTIFIED,\n      },\n    });\n\n    await this.addStatusUpdate(incidentId, {\n      status: IncidentStatus.IDENTIFIED,\n      message: `Root cause identified: ${rootCause}`,\n      updatedBy: \'SYSTEM\',\n    });\n\n    return incident;\n  }\n\n  /**\n   * Resolve incident\n   */\n  async resolveIncident(incidentId: string, resolution: ResolutionData): Promise<Incident> {\n    const incident = await prisma.incident.findUnique({\n      where: { id: incidentId },\n    });\n\n    if (!incident) {\n      throw new Error(\'Incident not found\');\n    }\n\n    const timeToResolve = Math.floor(\n      (Date.now() - incident.detectedAt.getTime()) / (1000 * 60)\n    );\n\n    const resolvedIncident = await prisma.incident.update({\n      where: { id: incidentId },\n      data: {\n        status: IncidentStatus.RESOLVED,\n        resolvedAt: new Date(),\n        resolvedBy: resolution.resolvedBy,\n        resolutionMethod: resolution.resolutionMethod,\n        resolutionSummary: resolution.resolutionSummary,\n        timeToResolve,\n        totalDuration: timeToResolve,\n        changeRequests: resolution.changeRequestId ? [resolution.changeRequestId] : [],\n        restorations: resolution.restorationId ? [resolution.restorationId] : [],\n      },\n    });\n\n    // Mark associated errors as resolved\n    if (incident.errorEvents.length > 0) {\n      await prisma.errorEvent.updateMany({\n        where: { id: { in: incident.errorEvents } },\n        data: {\n          resolved: true,\n          resolvedAt: new Date(),\n          resolutionMethod: resolution.resolutionMethod,\n          incidentId,\n        },\n      });\n    }\n\n    await this.notifyIncidentResolved(resolvedIncident);\n\n    // Determine if post-mortem is required\n    const requiresPostMortem = this.requiresPostMortem(resolvedIncident);\n    if (requiresPostMortem) {\n      await prisma.incident.update({\n        where: { id: incidentId },\n        data: { postMortemRequired: true },\n      });\n    }\n\n    return resolvedIncident;\n  }\n\n  /**\n   * Close incident with post-mortem\n   */\n  async closeIncident(incidentId: string, postMortemUrl?: string, lessonsLearned?: string, actionItems?: any[]): Promise<Incident> {\n    return await prisma.incident.update({\n      where: { id: incidentId },\n      data: {\n        status: IncidentStatus.CLOSED,\n        closedAt: new Date(),\n        postMortemCompleted: !!postMortemUrl,\n        postMortemUrl,\n        lessonsLearned,\n        actionItems,\n      },\n    });\n  }\n\n  /**\n   * Add status update\n   */\n  async addStatusUpdate(incidentId: string, update: StatusUpdate): Promise<void> {\n    const incident = await prisma.incident.findUnique({\n      where: { id: incidentId },\n    });\n\n    if (!incident) {\n      throw new Error(\'Incident not found\');\n    }\n\n    const statusUpdates = (incident.statusUpdates as any[]) || [];\n    statusUpdates.push({\n      timestamp: new Date(),\n      status: update.status,\n      message: update.message,\n      updatedBy: update.updatedBy,\n    });\n\n    await prisma.incident.update({\n      where: { id: incidentId },\n      data: {\n        statusUpdates,\n        status: update.status,\n      },\n    });\n  }\n\n  /**\n   * Escalate incident\n   */\n  async escalateIncident(incidentId: string, escalatedBy: string, reason: string): Promise<void> {\n    const incident = await prisma.incident.findUnique({\n      where: { id: incidentId },\n    });\n\n    if (!incident) {\n      throw new Error(\'Incident not found\');\n    }\n\n    // Upgrade severity if not already SEV1\n    let newSeverity = incident.severity;\n    if (incident.severity !== IncidentSeverity.SEV1) {\n      const severityLevels = [IncidentSeverity.SEV4, IncidentSeverity.SEV3, IncidentSeverity.SEV2, IncidentSeverity.SEV1];\n      const currentIndex = severityLevels.indexOf(incident.severity);\n      newSeverity = severityLevels[Math.max(0, currentIndex - 1)];\n    }\n\n    await prisma.incident.update({\n      where: { id: incidentId },\n      data: {\n        severity: newSeverity,\n      },\n    });\n\n    await this.addStatusUpdate(incidentId, {\n      status: incident.status,\n      message: `Incident escalated: ${reason}`,\n      updatedBy: escalatedBy,\n    });\n\n    await this.notifyIncidentEscalated(incident, reason);\n  }\n\n  /**\n   * Automated incident response\n   */\n  async automatedIncidentResponse(incidentId: string): Promise<any> {\n    const incident = await prisma.incident.findUnique({\n      where: { id: incidentId },\n    });\n\n    if (!incident) {\n      throw new Error(\'Incident not found\');\n    }\n\n    const actions = [];\n\n    // 1. Get AI diagnosis if error events exist\n    if (incident.errorEvents.length > 0) {\n      const diagnoses = await Promise.all(\n        incident.errorEvents.map(errorId => \n          this.diagnosisService.getErrorDiagnosis(errorId)\n        )\n      );\n      actions.push({ action: \'AI_DIAGNOSIS\', result: diagnoses });\n    }\n\n    // 2. For SEV1, attempt automated recovery\n    if (incident.severity === IncidentSeverity.SEV1) {\n      try {\n        const rollback = await this.recoveryService.emergencyRollback(\n          \'SYSTEM\',\n          `Automated response to incident ${incidentId}`\n        );\n        actions.push({ action: \'EMERGENCY_ROLLBACK\', result: rollback });\n\n        // If rollback successful, resolve incident\n        if (rollback.success) {\n          await this.resolveIncident(incidentId, {\n            resolvedBy: \'SYSTEM\',\n            resolutionMethod: \'AUTOMATED_ROLLBACK\',\n            resolutionSummary: \'System automatically rolled back to last known good state\',\n            restorationId: rollback.restoration.id,\n          });\n        }\n      } catch (error: any) {\n        actions.push({ action: \'EMERGENCY_ROLLBACK\', error: error.message });\n      }\n    }\n\n    // 3. Create emergency change request if needed\n    if (incident.severity === IncidentSeverity.SEV1 || incident.severity === IncidentSeverity.SEV2) {\n      const changeRequest = await this.changeService.submitEmergencyChange({\n        title: `Emergency fix for: ${incident.title}`,\n        description: incident.description,\n        justification: `Critical incident requiring immediate resolution`,\n        affectedServices: incident.affectedServices,\n        implementationPlan: \'To be determined based on diagnosis\',\n        rollbackPlan: \'Restore from snapshot\',\n        requestedBy: \'SYSTEM\',\n        requestedByName: \'Automated Incident Response\',\n        requestedByEmail: \'system@holovitals.com\',\n        incidentId,\n      });\n      actions.push({ action: \'EMERGENCY_CHANGE_REQUEST\', result: changeRequest });\n    }\n\n    return {\n      incident,\n      automatedActions: actions,\n    };\n  }\n\n  /**\n   * Get incident statistics\n   */\n  async getIncidentStatistics(): Promise<any> {\n    const [\n      totalIncidents,\n      activeIncidents,\n      sev1Incidents,\n      incidentsBySeverity,\n      incidentsByStatus,\n      averageTimeToAcknowledge,\n      averageTimeToResolve,\n      mttr,\n    ] = await Promise.all([\n      prisma.incident.count(),\n      prisma.incident.count({\n        where: {\n          status: {\n            in: [IncidentStatus.DETECTED, IncidentStatus.ACKNOWLEDGED, IncidentStatus.INVESTIGATING, IncidentStatus.IDENTIFIED, IncidentStatus.RESOLVING],\n          },\n        },\n      }),\n      prisma.incident.count({ where: { severity: IncidentSeverity.SEV1 } }),\n      this.getIncidentCountBySeverity(),\n      this.getIncidentCountByStatus(),\n      this.calculateAverageTimeToAcknowledge(),\n      this.calculateAverageTimeToResolve(),\n      this.calculateMTTR(),\n    ]);\n\n    return {\n      total: totalIncidents,\n      active: activeIncidents,\n      sev1: sev1Incidents,\n      bySeverity: incidentsBySeverity,\n      byStatus: incidentsByStatus,\n      averageTimeToAcknowledge,\n      averageTimeToResolve,\n      mttr,\n    };\n  }\n\n  /**\n   * Get active incidents\n   */\n  async getActiveIncidents(): Promise<Incident[]> {\n    return await prisma.incident.findMany({\n      where: {\n        status: {\n          in: [IncidentStatus.DETECTED, IncidentStatus.ACKNOWLEDGED, IncidentStatus.INVESTIGATING, IncidentStatus.IDENTIFIED, IncidentStatus.RESOLVING],\n        },\n      },\n      orderBy: [\n        { severity: \'asc\' },\n        { detectedAt: \'asc\' },\n      ],\n    });\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  private requiresPostMortem(incident: Incident): boolean {\n    // Post-mortem required for:\n    // - All SEV1 incidents\n    // - SEV2 incidents lasting > 1 hour\n    // - Any incident affecting > 100 users\n    \n    if (incident.severity === IncidentSeverity.SEV1) return true;\n    \n    if (incident.severity === IncidentSeverity.SEV2 && incident.timeToResolve && incident.timeToResolve > 60) {\n      return true;\n    }\n    \n    if (incident.affectedUsers && incident.affectedUsers > 100) return true;\n    \n    return false;\n  }\n\n  private async notifyIncidentDetected(incident: Incident): Promise<void> {\n    // TODO: Implement notification\n    console.log(`Incident detected: ${incident.id} - ${incident.title}`);\n  }\n\n  private async notifyIncidentAcknowledged(incident: Incident): Promise<void> {\n    // TODO: Implement notification\n    console.log(`Incident acknowledged: ${incident.id}`);\n  }\n\n  private async notifyIncidentResolved(incident: Incident): Promise<void> {\n    // TODO: Implement notification\n    console.log(`Incident resolved: ${incident.id}`);\n  }\n\n  private async notifyIncidentEscalated(incident: Incident, reason: string): Promise<void> {\n    // TODO: Implement notification\n    console.log(`Incident escalated: ${incident.id} - ${reason}`);\n  }\n\n  private async getIncidentCountBySeverity(): Promise<any> {\n    const counts = await prisma.incident.groupBy({\n      by: [\'severity\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.severity] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async getIncidentCountByStatus(): Promise<any> {\n    const counts = await prisma.incident.groupBy({\n      by: [\'status\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.status] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async calculateAverageTimeToAcknowledge(): Promise<number> {\n    const incidents = await prisma.incident.findMany({\n      where: {\n        timeToAcknowledge: { not: null },\n      },\n    });\n\n    if (incidents.length === 0) return 0;\n\n    const totalTime = incidents.reduce((sum, incident) => sum + (incident.timeToAcknowledge || 0), 0);\n    return Math.round(totalTime / incidents.length);\n  }\n\n  private async calculateAverageTimeToResolve(): Promise<number> {\n    const incidents = await prisma.incident.findMany({\n      where: {\n        timeToResolve: { not: null },\n      },\n    });\n\n    if (incidents.length === 0) return 0;\n\n    const totalTime = incidents.reduce((sum, incident) => sum + (incident.timeToResolve || 0), 0);\n    return Math.round(totalTime / incidents.length);\n  }\n\n  private async calculateMTTR(): Promise<number> {\n    // Mean Time To Recovery - average time to resolve incidents\n    return await this.calculateAverageTimeToResolve();\n  }\n}\n\nexport default IncidentManagementService;\n</create-file>\n</function_calls>'}