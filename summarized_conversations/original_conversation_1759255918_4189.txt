{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/services/ChangeManagementService.ts">\n/**\n * Change Management Service\n * \n * Manages change requests, approvals, and implementations with emergency fast-track\n * capabilities for critical system changes.\n */\n\nimport { PrismaClient, ChangeRequest, ChangeType, ChangePriority, ChangeStatus, ChangeRiskLevel, ApprovalStatus } from \'@prisma/client\';\n\nconst prisma = new PrismaClient();\n\ninterface ChangeRequestData {\n  type: ChangeType;\n  priority: ChangePriority;\n  riskLevel: ChangeRiskLevel;\n  title: string;\n  description: string;\n  justification: string;\n  affectedServices: string[];\n  affectedSystems: string[];\n  changeScope: string;\n  implementationPlan: string;\n  rollbackPlan: string;\n  testingPlan?: string;\n  estimatedDowntime?: number;\n  userImpact?: string;\n  businessImpact?: string;\n  technicalImpact?: string;\n  complianceImpact?: string;\n  scheduledStart?: Date;\n  scheduledEnd?: Date;\n  requestedBy: string;\n  requestedByName: string;\n  requestedByEmail: string;\n  tags?: string[];\n  attachments?: string[];\n}\n\ninterface EmergencyChangeData {\n  title: string;\n  description: string;\n  justification: string;\n  affectedServices: string[];\n  implementationPlan: string;\n  rollbackPlan: string;\n  requestedBy: string;\n  requestedByName: string;\n  requestedByEmail: string;\n  incidentId?: string;\n}\n\ninterface ApprovalDecision {\n  approverId: string;\n  approverName: string;\n  decision: \'APPROVED\' | \'REJECTED\' | \'ESCALATED\';\n  comments?: string;\n  conditions?: string;\n}\n\ninterface ImplementationStep {\n  step: number;\n  stepName: string;\n  stepDescription: string;\n  rollbackCommand?: string;\n}\n\nexport class ChangeManagementService {\n  /**\n   * Submit a change request\n   */\n  async submitChangeRequest(data: ChangeRequestData): Promise<ChangeRequest> {\n    // Determine approval level based on risk\n    const approvalLevel = this.determineApprovalLevel(data.riskLevel, data.type);\n\n    const changeRequest = await prisma.changeRequest.create({\n      data: {\n        type: data.type,\n        priority: data.priority,\n        riskLevel: data.riskLevel,\n        title: data.title,\n        description: data.description,\n        justification: data.justification,\n        affectedServices: data.affectedServices,\n        affectedSystems: data.affectedSystems,\n        changeScope: data.changeScope,\n        implementationPlan: data.implementationPlan,\n        rollbackPlan: data.rollbackPlan,\n        testingPlan: data.testingPlan,\n        estimatedDowntime: data.estimatedDowntime,\n        userImpact: data.userImpact,\n        businessImpact: data.businessImpact,\n        technicalImpact: data.technicalImpact,\n        complianceImpact: data.complianceImpact,\n        scheduledStart: data.scheduledStart,\n        scheduledEnd: data.scheduledEnd,\n        requestedBy: data.requestedBy,\n        requestedByName: data.requestedByName,\n        requestedByEmail: data.requestedByEmail,\n        tags: data.tags || [],\n        attachments: data.attachments || [],\n        status: ChangeStatus.SUBMITTED,\n        approvalLevel,\n        requiresApproval: data.type !== ChangeType.STANDARD,\n      },\n    });\n\n    // Create approval requests\n    await this.createApprovalRequests(changeRequest.id, approvalLevel);\n\n    // Notify relevant parties\n    await this.notifyChangeSubmitted(changeRequest);\n\n    return changeRequest;\n  }\n\n  /**\n   * Submit emergency change request (fast-track)\n   */\n  async submitEmergencyChange(data: EmergencyChangeData): Promise<ChangeRequest> {\n    const changeRequest = await prisma.changeRequest.create({\n      data: {\n        type: ChangeType.EMERGENCY,\n        priority: ChangePriority.CRITICAL,\n        riskLevel: ChangeRiskLevel.CRITICAL,\n        title: data.title,\n        description: data.description,\n        justification: data.justification,\n        affectedServices: data.affectedServices,\n        affectedSystems: [],\n        changeScope: \'Emergency change to restore service\',\n        implementationPlan: data.implementationPlan,\n        rollbackPlan: data.rollbackPlan,\n        requestedBy: data.requestedBy,\n        requestedByName: data.requestedByName,\n        requestedByEmail: data.requestedByEmail,\n        status: ChangeStatus.SUBMITTED,\n        approvalLevel: 2, // Requires technical lead approval\n        requiresApproval: true,\n        relatedIncidents: data.incidentId ? [data.incidentId] : [],\n      },\n    });\n\n    // Create fast-track approval requests\n    await this.createEmergencyApprovalRequests(changeRequest.id);\n\n    // Send urgent notifications\n    await this.notifyEmergencyChange(changeRequest);\n\n    return changeRequest;\n  }\n\n  /**\n   * Approve or reject change request\n   */\n  async processApproval(changeRequestId: string, approvalId: string, decision: ApprovalDecision): Promise<any> {\n    const approval = await prisma.changeApproval.findUnique({\n      where: { id: approvalId },\n      include: { changeRequest: true },\n    });\n\n    if (!approval) {\n      throw new Error(\'Approval request not found\');\n    }\n\n    // Update approval\n    await prisma.changeApproval.update({\n      where: { id: approvalId },\n      data: {\n        status: decision.decision === \'APPROVED\' ? ApprovalStatus.APPROVED : \n                decision.decision === \'REJECTED\' ? ApprovalStatus.REJECTED : \n                ApprovalStatus.ESCALATED,\n        decision: decision.decision,\n        approverId: decision.approverId,\n        approverName: decision.approverName,\n        comments: decision.comments,\n        conditions: decision.conditions,\n        respondedAt: new Date(),\n      },\n    });\n\n    // Check if all required approvals are complete\n    const allApprovals = await prisma.changeApproval.findMany({\n      where: { changeRequestId },\n    });\n\n    const allApproved = allApprovals.every(a => a.status === ApprovalStatus.APPROVED);\n    const anyRejected = allApprovals.some(a => a.status === ApprovalStatus.REJECTED);\n\n    // Update change request status\n    if (anyRejected) {\n      await prisma.changeRequest.update({\n        where: { id: changeRequestId },\n        data: { status: ChangeStatus.REJECTED },\n      });\n\n      await this.notifyChangeRejected(approval.changeRequest, decision.comments);\n    } else if (allApproved) {\n      await prisma.changeRequest.update({\n        where: { id: changeRequestId },\n        data: { status: ChangeStatus.APPROVED },\n      });\n\n      await this.notifyChangeApproved(approval.changeRequest);\n    }\n\n    return {\n      approved: allApproved,\n      rejected: anyRejected,\n      pendingApprovals: allApprovals.filter(a => a.status === ApprovalStatus.PENDING).length,\n    };\n  }\n\n  /**\n   * Implement change request\n   */\n  async implementChange(changeRequestId: string, implementedBy: string, steps: ImplementationStep[]): Promise<any> {\n    const changeRequest = await prisma.changeRequest.findUnique({\n      where: { id: changeRequestId },\n    });\n\n    if (!changeRequest) {\n      throw new Error(\'Change request not found\');\n    }\n\n    if (changeRequest.status !== ChangeStatus.APPROVED && changeRequest.status !== ChangeStatus.SCHEDULED) {\n      throw new Error(`Change request must be approved before implementation. Current status: ${changeRequest.status}`);\n    }\n\n    // Update change request status\n    await prisma.changeRequest.update({\n      where: { id: changeRequestId },\n      data: {\n        status: ChangeStatus.IN_PROGRESS,\n        implementedBy,\n        actualStart: new Date(),\n      },\n    });\n\n    // Create implementation steps\n    for (const step of steps) {\n      await prisma.changeImplementation.create({\n        data: {\n          changeRequestId,\n          step: step.step,\n          stepName: step.stepName,\n          stepDescription: step.stepDescription,\n          rollbackCommand: step.rollbackCommand,\n          status: \'PENDING\',\n        },\n      });\n    }\n\n    // Notify implementation started\n    await this.notifyImplementationStarted(changeRequest);\n\n    return {\n      changeRequestId,\n      status: \'IN_PROGRESS\',\n      totalSteps: steps.length,\n    };\n  }\n\n  /**\n   * Execute implementation step\n   */\n  async executeImplementationStep(stepId: string): Promise<any> {\n    const step = await prisma.changeImplementation.findUnique({\n      where: { id: stepId },\n    });\n\n    if (!step) {\n      throw new Error(\'Implementation step not found\');\n    }\n\n    try {\n      // Update step status\n      await prisma.changeImplementation.update({\n        where: { id: stepId },\n        data: {\n          status: \'IN_PROGRESS\',\n          startedAt: new Date(),\n        },\n      });\n\n      // Execute step (this would integrate with actual deployment system)\n      const result = await this.executeStep(step);\n\n      // Update step with results\n      await prisma.changeImplementation.update({\n        where: { id: stepId },\n        data: {\n          status: \'COMPLETED\',\n          completedAt: new Date(),\n          duration: Math.floor((Date.now() - (step.startedAt?.getTime() || Date.now())) / 1000),\n          success: true,\n          output: result.output,\n        },\n      });\n\n      return {\n        success: true,\n        stepId,\n        output: result.output,\n      };\n    } catch (error: any) {\n      // Mark step as failed\n      await prisma.changeImplementation.update({\n        where: { id: stepId },\n        data: {\n          status: \'FAILED\',\n          completedAt: new Date(),\n          success: false,\n          errorMessage: error.message,\n        },\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Complete change implementation\n   */\n  async completeChange(changeRequestId: string, actualDowntime?: number): Promise<ChangeRequest> {\n    const changeRequest = await prisma.changeRequest.update({\n      where: { id: changeRequestId },\n      data: {\n        status: ChangeStatus.TESTING,\n        actualEnd: new Date(),\n        actualDowntime,\n      },\n    });\n\n    // Create validation tasks\n    await this.createValidationTasks(changeRequestId);\n\n    // Notify completion\n    await this.notifyChangeCompleted(changeRequest);\n\n    return changeRequest;\n  }\n\n  /**\n   * Validate change implementation\n   */\n  async validateChange(changeRequestId: string, validationType: string, results: any): Promise<any> {\n    await prisma.changeValidation.create({\n      data: {\n        changeRequestId,\n        validationType,\n        validationName: `${validationType} Validation`,\n        validationSteps: JSON.stringify(results.steps),\n        status: \'COMPLETED\',\n        startedAt: new Date(),\n        completedAt: new Date(),\n        passed: results.passed,\n        results: results,\n        issues: results.issues || [],\n        recommendations: results.recommendations || [],\n      },\n    });\n\n    // Check if all validations are complete\n    const allValidations = await prisma.changeValidation.findMany({\n      where: { changeRequestId },\n    });\n\n    const allPassed = allValidations.every(v => v.passed);\n\n    if (allPassed) {\n      await prisma.changeRequest.update({\n        where: { id: changeRequestId },\n        data: {\n          status: ChangeStatus.COMPLETED,\n          validationPassed: true,\n        },\n      });\n    }\n\n    return {\n      validationType,\n      passed: results.passed,\n      allValidationsPassed: allPassed,\n    };\n  }\n\n  /**\n   * Rollback change\n   */\n  async rollbackChange(changeRequestId: string, rolledBackBy: string, reason: string): Promise<any> {\n    const changeRequest = await prisma.changeRequest.findUnique({\n      where: { id: changeRequestId },\n    });\n\n    if (!changeRequest) {\n      throw new Error(\'Change request not found\');\n    }\n\n    // Get implementation steps in reverse order\n    const steps = await prisma.changeImplementation.findMany({\n      where: {\n        changeRequestId,\n        status: \'COMPLETED\',\n        canRollback: true,\n      },\n      orderBy: { step: \'desc\' },\n    });\n\n    // Execute rollback commands\n    for (const step of steps) {\n      if (step.rollbackCommand) {\n        try {\n          await this.executeRollbackCommand(step.rollbackCommand);\n        } catch (error) {\n          console.error(`Rollback failed for step ${step.step}:`, error);\n        }\n      }\n    }\n\n    // Update change request\n    await prisma.changeRequest.update({\n      where: { id: changeRequestId },\n      data: {\n        status: ChangeStatus.ROLLED_BACK,\n        rolledBack: true,\n        rollbackReason: reason,\n        rollbackAt: new Date(),\n      },\n    });\n\n    // Notify rollback\n    await this.notifyChangeRolledBack(changeRequest, reason);\n\n    return {\n      success: true,\n      changeRequestId,\n      stepsRolledBack: steps.length,\n    };\n  }\n\n  /**\n   * Get change request statistics\n   */\n  async getChangeStatistics(): Promise<any> {\n    const [\n      totalChanges,\n      pendingApproval,\n      inProgress,\n      completed,\n      emergencyChanges,\n      changesByType,\n      changesByRisk,\n      averageApprovalTime,\n      averageImplementationTime,\n    ] = await Promise.all([\n      prisma.changeRequest.count(),\n      prisma.changeRequest.count({ where: { status: ChangeStatus.SUBMITTED } }),\n      prisma.changeRequest.count({ where: { status: ChangeStatus.IN_PROGRESS } }),\n      prisma.changeRequest.count({ where: { status: ChangeStatus.COMPLETED } }),\n      prisma.changeRequest.count({ where: { type: ChangeType.EMERGENCY } }),\n      this.getChangeCountByType(),\n      this.getChangeCountByRisk(),\n      this.calculateAverageApprovalTime(),\n      this.calculateAverageImplementationTime(),\n    ]);\n\n    return {\n      total: totalChanges,\n      pendingApproval,\n      inProgress,\n      completed,\n      emergency: emergencyChanges,\n      byType: changesByType,\n      byRisk: changesByRisk,\n      averageApprovalTime,\n      averageImplementationTime,\n    };\n  }\n\n  /**\n   * Get pending approvals for user\n   */\n  async getPendingApprovals(userId: string): Promise<any[]> {\n    return await prisma.changeApproval.findMany({\n      where: {\n        status: ApprovalStatus.PENDING,\n        // TODO: Add user role-based filtering\n      },\n      include: {\n        changeRequest: true,\n      },\n      orderBy: {\n        requestedAt: \'asc\',\n      },\n    });\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  private determineApprovalLevel(riskLevel: ChangeRiskLevel, type: ChangeType): number {\n    if (type === ChangeType.STANDARD) return 0; // No approval needed\n    if (type === ChangeType.EMERGENCY) return 2; // Technical lead\n    \n    switch (riskLevel) {\n      case ChangeRiskLevel.CRITICAL:\n        return 3; // CTO approval\n      case ChangeRiskLevel.HIGH:\n        return 2; // Technical lead\n      case ChangeRiskLevel.MEDIUM:\n        return 1; // Engineer\n      case ChangeRiskLevel.LOW:\n        return 1; // Engineer\n      default:\n        return 1;\n    }\n  }\n\n  private async createApprovalRequests(changeRequestId: string, approvalLevel: number): Promise<void> {\n    const approvalLevels = [\n      { level: 1, role: \'Engineer\' },\n      { level: 2, role: \'Technical Lead\' },\n      { level: 3, role: \'CTO\' },\n      { level: 4, role: \'Compliance Officer\' },\n    ];\n\n    for (const level of approvalLevels) {\n      if (level.level <= approvalLevel) {\n        await prisma.changeApproval.create({\n          data: {\n            changeRequestId,\n            approverLevel: level.level,\n            approverRole: level.role,\n            status: ApprovalStatus.PENDING,\n          },\n        });\n      }\n    }\n  }\n\n  private async createEmergencyApprovalRequests(changeRequestId: string): Promise<void> {\n    // Emergency changes require immediate technical lead approval\n    await prisma.changeApproval.create({\n      data: {\n        changeRequestId,\n        approverLevel: 2,\n        approverRole: \'Technical Lead (Emergency)\',\n        status: ApprovalStatus.PENDING,\n      },\n    });\n  }\n\n  private async createValidationTasks(changeRequestId: string): Promise<void> {\n    const validationTypes = [\'FUNCTIONAL\', \'PERFORMANCE\', \'SECURITY\', \'COMPLIANCE\'];\n\n    for (const type of validationTypes) {\n      await prisma.changeValidation.create({\n        data: {\n          changeRequestId,\n          validationType: type,\n          validationName: `${type} Validation`,\n          validationSteps: \'Automated validation steps\',\n          status: \'PENDING\',\n        },\n      });\n    }\n  }\n\n  private async executeStep(step: any): Promise<any> {\n    // TODO: Integrate with actual deployment system\n    console.log(`Executing step: ${step.stepName}`);\n    \n    // Simulate execution\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    return {\n      output: `Step ${step.stepName} completed successfully`,\n    };\n  }\n\n  private async executeRollbackCommand(command: string): Promise<void> {\n    // TODO: Integrate with actual deployment system\n    console.log(`Executing rollback command: ${command}`);\n    \n    // Simulate execution\n    await new Promise(resolve => setTimeout(resolve, 500));\n  }\n\n  private async notifyChangeSubmitted(changeRequest: ChangeRequest): Promise<void> {\n    // TODO: Implement notification\n    console.log(`Change request submitted: ${changeRequest.id}`);\n  }\n\n  private async notifyEmergencyChange(changeRequest: ChangeRequest): Promise<void> {\n    // TODO: Implement urgent notification\n    console.log(`EMERGENCY change request: ${changeRequest.id}`);\n  }\n\n  private async notifyChangeApproved(changeRequest: ChangeRequest): Promise<void> {\n    // TODO: Implement notification\n    console.log(`Change request approved: ${changeRequest.id}`);\n  }\n\n  private async notifyChangeRejected(changeRequest: ChangeRequest, reason?: string): Promise<void> {\n    // TODO: Implement notification\n    console.log(`Change request rejected: ${changeRequest.id} - ${reason}`);\n  }\n\n  private async notifyImplementationStarted(changeRequest: ChangeRequest): Promise<void> {\n    // TODO: Implement notification\n    console.log(`Change implementation started: ${changeRequest.id}`);\n  }\n\n  private async notifyChangeCompleted(changeRequest: ChangeRequest): Promise<void> {\n    // TODO: Implement notification\n    console.log(`Change completed: ${changeRequest.id}`);\n  }\n\n  private async notifyChangeRolledBack(changeRequest: ChangeRequest, reason: string): Promise<void> {\n    // TODO: Implement notification\n    console.log(`Change rolled back: ${changeRequest.id} - ${reason}`);\n  }\n\n  private async getChangeCountByType(): Promise<any> {\n    const counts = await prisma.changeRequest.groupBy({\n      by: [\'type\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.type] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async getChangeCountByRisk(): Promise<any> {\n    const counts = await prisma.changeRequest.groupBy({\n      by: [\'riskLevel\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.riskLevel] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async calculateAverageApprovalTime(): Promise<number> {\n    const approvedChanges = await prisma.changeRequest.findMany({\n      where: {\n        status: { in: [ChangeStatus.APPROVED, ChangeStatus.COMPLETED] },\n      },\n      select: {\n        requestedAt: true,\n        updatedAt: true,\n      },\n    });\n\n    if (approvedChanges.length === 0) return 0;\n\n    const totalTime = approvedChanges.reduce((sum, change) => {\n      return sum + (change.updatedAt.getTime() - change.requestedAt.getTime());\n    }, 0);\n\n    // Return average in minutes\n    return Math.round(totalTime / approvedChanges.length / (1000 * 60));\n  }\n\n  private async calculateAverageImplementationTime(): Promise<number> {\n    const completedChanges = await prisma.changeRequest.findMany({\n      where: {\n        status: ChangeStatus.COMPLETED,\n        actualStart: { not: null },\n        actualEnd: { not: null },\n      },\n      select: {\n        actualStart: true,\n        actualEnd: true,\n      },\n    });\n\n    if (completedChanges.length === 0) return 0;\n\n    const totalTime = completedChanges.reduce((sum, change) => {\n      return sum + (change.actualEnd!.getTime() - change.actualStart!.getTime());\n    }, 0);\n\n    // Return average in minutes\n    return Math.round(totalTime / completedChanges.length / (1000 * 60));\n  }\n}\n\nexport default ChangeManagementService;\n</create-file>\n</function_calls>'}