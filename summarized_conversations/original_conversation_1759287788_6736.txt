{'role': 'assistant', 'content': 'Now let me create the File Upload & Cost Analysis Service:\n\n<function_calls>\n<create-file file_path="medical-analysis-platform/lib/services/FileUploadService.ts">\n/**\n * File Upload Service\n * \n * Handles large file uploads, cost estimation, approval workflow, and multi-month processing\n */\n\nimport { PrismaClient } from \'@prisma/client\';\nimport { PricingService } from \'./PricingService\';\nimport { TokenService } from \'./TokenService\';\nimport { SubscriptionTier, getTierConfig } from \'../config/pricing\';\n\nconst prisma = new PrismaClient();\n\nexport interface FileUploadInput {\n  userId: string;\n  fileName: string;\n  filePath: string;\n  fileSize: number;\n  mimeType: string;\n  requiresOCR?: boolean;\n  requiresAnalysis?: boolean;\n}\n\nexport interface CostApprovalInput {\n  uploadId: string;\n  approved: boolean;\n  processingOption?: \'immediate\' | \'one-time-purchase\' | \'multi-month\' | \'upgrade\';\n  packageIndex?: number; // For one-time purchase\n  newTier?: SubscriptionTier; // For upgrade\n}\n\nexport class FileUploadService {\n  /**\n   * Create file upload with cost estimation\n   */\n  static async createUpload(input: FileUploadInput) {\n    // Get user\'s subscription and token balance\n    const subscription = await prisma.subscription.findUnique({\n      where: { userId: input.userId },\n      include: { tokenBalance: true },\n    });\n    \n    if (!subscription || !subscription.tokenBalance) {\n      throw new Error(\'User subscription not found\');\n    }\n    \n    const tier = subscription.tier as SubscriptionTier;\n    const tierConfig = getTierConfig(tier);\n    \n    // Validate file size against tier limits\n    const sizeValidation = PricingService.validateFileSize(input.fileSize, tier);\n    if (!sizeValidation.valid) {\n      throw new Error(sizeValidation.message);\n    }\n    \n    // Estimate cost\n    const costEstimation = PricingService.estimateFileCost(\n      input.fileSize,\n      input.mimeType,\n      subscription.tokenBalance.currentBalance,\n      tier,\n      subscription.tokenBalance.freeUploadUsed,\n      input.requiresOCR ?? true,\n      input.requiresAnalysis ?? true\n    );\n    \n    // Create file upload record\n    const upload = await prisma.fileUpload.create({\n      data: {\n        userId: input.userId,\n        fileName: input.fileName,\n        filePath: input.filePath,\n        fileSize: input.fileSize,\n        mimeType: input.mimeType,\n        status: \'PENDING\',\n        estimatedTokens: costEstimation.estimatedTokens,\n        estimatedCost: costEstimation.estimatedCost,\n        usedFreeUpload: costEstimation.useFreeUpload,\n        metadata: JSON.stringify({\n          requiresOCR: input.requiresOCR ?? true,\n          requiresAnalysis: input.requiresAnalysis ?? true,\n          costEstimation,\n        }),\n      },\n    });\n    \n    return {\n      upload,\n      costEstimation,\n      tierConfig,\n    };\n  }\n  \n  /**\n   * Approve or reject file upload cost\n   */\n  static async approveCost(input: CostApprovalInput) {\n    const upload = await prisma.fileUpload.findUnique({\n      where: { id: input.uploadId },\n    });\n    \n    if (!upload) {\n      throw new Error(\'Upload not found\');\n    }\n    \n    if (upload.status !== \'PENDING\') {\n      throw new Error(\'Upload is not in pending state\');\n    }\n    \n    if (!input.approved) {\n      // User rejected the cost\n      await prisma.fileUpload.update({\n        where: { id: upload.id },\n        data: {\n          status: \'CANCELLED\',\n          errorMessage: \'User cancelled upload due to cost\',\n        },\n      });\n      \n      return { status: \'cancelled\' };\n    }\n    \n    // User approved - handle based on processing option\n    switch (input.processingOption) {\n      case \'immediate\':\n        return await this.processImmediate(upload);\n      \n      case \'one-time-purchase\':\n        if (input.packageIndex === undefined) {\n          throw new Error(\'Package index required for one-time purchase\');\n        }\n        return await this.processWithPurchase(upload, input.packageIndex);\n      \n      case \'multi-month\':\n        return await this.scheduleMultiMonth(upload);\n      \n      case \'upgrade\':\n        if (!input.newTier) {\n          throw new Error(\'New tier required for upgrade\');\n        }\n        return await this.processWithUpgrade(upload, input.newTier);\n      \n      default:\n        throw new Error(\'Invalid processing option\');\n    }\n  }\n  \n  /**\n   * Process file immediately (user has sufficient balance)\n   */\n  private static async processImmediate(upload: any) {\n    const subscription = await prisma.subscription.findUnique({\n      where: { userId: upload.userId },\n      include: { tokenBalance: true },\n    });\n    \n    if (!subscription || !subscription.tokenBalance) {\n      throw new Error(\'Subscription not found\');\n    }\n    \n    // Check if user can afford\n    const canAfford = await TokenService.canAfford(\n      upload.userId,\n      upload.estimatedTokens || 0\n    );\n    \n    if (!canAfford) {\n      throw new Error(\'Insufficient token balance\');\n    }\n    \n    // Update upload status\n    await prisma.fileUpload.update({\n      where: { id: upload.id },\n      data: {\n        status: \'APPROVED\',\n        processingStartedAt: new Date(),\n      },\n    });\n    \n    // Deduct tokens (if not using free upload)\n    if (!upload.usedFreeUpload && upload.estimatedTokens > 0) {\n      await TokenService.deductTokens({\n        userId: upload.userId,\n        amount: upload.estimatedTokens,\n        description: `File processing: ${upload.fileName}`,\n        referenceId: upload.id,\n        referenceType: \'FileUpload\',\n      });\n    } else if (upload.usedFreeUpload) {\n      // Track free upload usage\n      await TokenService.trackFreeUploadUsage(upload.userId, upload.fileSize);\n    }\n    \n    // Queue for processing (integrate with AnalysisQueueService)\n    // This would be handled by the actual processing pipeline\n    \n    return {\n      status: \'approved\',\n      message: \'File queued for immediate processing\',\n      upload,\n    };\n  }\n  \n  /**\n   * Process file after one-time token purchase\n   */\n  private static async processWithPurchase(upload: any, packageIndex: number) {\n    // This would integrate with payment processing\n    // For now, we\'ll simulate the purchase\n    \n    // After successful payment, add tokens\n    await TokenService.purchaseTokens({\n      userId: upload.userId,\n      packageIndex,\n      paymentIntentId: `pi_${Date.now()}`, // Would be real payment ID\n    });\n    \n    // Then process immediately\n    return await this.processImmediate(upload);\n  }\n  \n  /**\n   * Schedule multi-month processing\n   */\n  private static async scheduleMultiMonth(upload: any) {\n    const subscription = await prisma.subscription.findUnique({\n      where: { userId: upload.userId },\n      include: { tokenBalance: true },\n    });\n    \n    if (!subscription || !subscription.tokenBalance) {\n      throw new Error(\'Subscription not found\');\n    }\n    \n    const tier = subscription.tier as SubscriptionTier;\n    const tierConfig = getTierConfig(tier);\n    \n    // Calculate multi-month schedule\n    const multiMonthPlan = PricingService.calculateMultiMonthProcessing(\n      upload.estimatedTokens || 0,\n      subscription.tokenBalance.currentBalance,\n      tierConfig.monthlyTokens\n    );\n    \n    // Update upload with schedule\n    await prisma.fileUpload.update({\n      where: { id: upload.id },\n      data: {\n        status: \'SCHEDULED\',\n        scheduledMonths: multiMonthPlan.monthsRequired,\n        currentMonth: 0,\n        metadata: JSON.stringify({\n          ...JSON.parse(upload.metadata || \'{}\'),\n          multiMonthPlan,\n        }),\n      },\n    });\n    \n    return {\n      status: \'scheduled\',\n      message: `File scheduled for processing over ${multiMonthPlan.monthsRequired} months`,\n      multiMonthPlan,\n      upload,\n    };\n  }\n  \n  /**\n   * Process file after tier upgrade\n   */\n  private static async processWithUpgrade(upload: any, newTier: SubscriptionTier) {\n    // This would integrate with SubscriptionService\n    // For now, we\'ll assume the upgrade happens first\n    \n    // After upgrade, process immediately\n    return await this.processImmediate(upload);\n  }\n  \n  /**\n   * Process next chunk of multi-month upload (called by cron)\n   */\n  static async processMultiMonthChunk(uploadId: string) {\n    const upload = await prisma.fileUpload.findUnique({\n      where: { id: uploadId },\n    });\n    \n    if (!upload || upload.status !== \'SCHEDULED\') {\n      throw new Error(\'Upload not found or not scheduled\');\n    }\n    \n    const metadata = JSON.parse(upload.metadata || \'{}\');\n    const multiMonthPlan = metadata.multiMonthPlan;\n    \n    if (!multiMonthPlan) {\n      throw new Error(\'Multi-month plan not found\');\n    }\n    \n    const currentMonth = upload.currentMonth || 0;\n    const nextMonth = currentMonth + 1;\n    \n    if (nextMonth > multiMonthPlan.monthsRequired) {\n      throw new Error(\'All months already processed\');\n    }\n    \n    const monthData = multiMonthPlan.monthlyProcessing[currentMonth];\n    \n    // Deduct tokens for this month\n    await TokenService.deductTokens({\n      userId: upload.userId,\n      amount: monthData.tokens,\n      description: `Multi-month processing (Month ${nextMonth}/${multiMonthPlan.monthsRequired}): ${upload.fileName}`,\n      referenceId: upload.id,\n      referenceType: \'FileUpload\',\n    });\n    \n    // Update upload progress\n    const isComplete = nextMonth === multiMonthPlan.monthsRequired;\n    \n    await prisma.fileUpload.update({\n      where: { id: upload.id },\n      data: {\n        currentMonth: nextMonth,\n        status: isComplete ? \'COMPLETED\' : \'SCHEDULED\',\n        processingCompletedAt: isComplete ? new Date() : undefined,\n      },\n    });\n    \n    return {\n      uploadId: upload.id,\n      month: nextMonth,\n      totalMonths: multiMonthPlan.monthsRequired,\n      tokensProcessed: monthData.tokens,\n      percentageComplete: (nextMonth / multiMonthPlan.monthsRequired) * 100,\n      isComplete,\n    };\n  }\n  \n  /**\n   * Get upload details\n   */\n  static async getUpload(uploadId: string) {\n    const upload = await prisma.fileUpload.findUnique({\n      where: { id: uploadId },\n    });\n    \n    if (!upload) {\n      throw new Error(\'Upload not found\');\n    }\n    \n    const metadata = JSON.parse(upload.metadata || \'{}\');\n    \n    return {\n      ...upload,\n      metadata,\n    };\n  }\n  \n  /**\n   * Get user\'s upload history\n   */\n  static async getUserUploads(\n    userId: string,\n    limit: number = 50,\n    offset: number = 0\n  ) {\n    const uploads = await prisma.fileUpload.findMany({\n      where: { userId },\n      orderBy: { createdAt: \'desc\' },\n      take: limit,\n      skip: offset,\n    });\n    \n    const total = await prisma.fileUpload.count({\n      where: { userId },\n    });\n    \n    return {\n      uploads: uploads.map(u => ({\n        ...u,\n        metadata: JSON.parse(u.metadata || \'{}\'),\n      })),\n      total,\n      limit,\n      offset,\n      hasMore: offset + limit < total,\n    };\n  }\n  \n  /**\n   * Get upload statistics\n   */\n  static async getUploadStats(userId?: string) {\n    const where = userId ? { userId } : {};\n    \n    const [\n      totalUploads,\n      pendingUploads,\n      processingUploads,\n      completedUploads,\n      failedUploads,\n      totalSize,\n      totalTokensUsed,\n    ] = await Promise.all([\n      prisma.fileUpload.count({ where }),\n      prisma.fileUpload.count({ where: { ...where, status: \'PENDING\' } }),\n      prisma.fileUpload.count({ where: { ...where, status: \'PROCESSING\' } }),\n      prisma.fileUpload.count({ where: { ...where, status: \'COMPLETED\' } }),\n      prisma.fileUpload.count({ where: { ...where, status: \'FAILED\' } }),\n      prisma.fileUpload.aggregate({\n        where,\n        _sum: { fileSize: true },\n      }),\n      prisma.fileUpload.aggregate({\n        where: { ...where, status: \'COMPLETED\' },\n        _sum: { actualTokens: true },\n      }),\n    ]);\n    \n    return {\n      totalUploads,\n      pendingUploads,\n      processingUploads,\n      completedUploads,\n      failedUploads,\n      totalSize: totalSize._sum.fileSize || 0,\n      totalTokensUsed: totalTokensUsed._sum.actualTokens || 0,\n    };\n  }\n  \n  /**\n   * Cancel upload\n   */\n  static async cancelUpload(uploadId: string, reason?: string) {\n    const upload = await prisma.fileUpload.findUnique({\n      where: { id: uploadId },\n    });\n    \n    if (!upload) {\n      throw new Error(\'Upload not found\');\n    }\n    \n    if (upload.status === \'COMPLETED\') {\n      throw new Error(\'Cannot cancel completed upload\');\n    }\n    \n    await prisma.fileUpload.update({\n      where: { id: upload.id },\n      data: {\n        status: \'CANCELLED\',\n        errorMessage: reason || \'User cancelled upload\',\n      },\n    });\n    \n    return { status: \'cancelled\' };\n  }\n}\n</create-file>\n</function_calls>'}