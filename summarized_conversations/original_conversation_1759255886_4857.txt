{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/services/BugRepositoryService.ts">\n/**\n * Bug Repository Service\n * \n * Manages bug detection, tracking, categorization, and lifecycle management.\n * Integrates with multiple sources: user reports, system monitoring, automated tests.\n */\n\nimport { PrismaClient, Bug, BugSource, BugSeverity, BugStatus, BugCategory } from \'@prisma/client\';\n\nconst prisma = new PrismaClient();\n\ninterface BugDetectionResult {\n  detected: boolean;\n  bugs: Bug[];\n  source: BugSource;\n}\n\ninterface BugReport {\n  title: string;\n  description: string;\n  source: BugSource;\n  severity?: BugSeverity;\n  category?: BugCategory;\n  reportedBy?: string;\n  reportedByEmail?: string;\n  stackTrace?: string;\n  errorMessage?: string;\n  affectedComponent?: string;\n  environment?: string;\n  stepsToReproduce?: string;\n  expectedBehavior?: string;\n  actualBehavior?: string;\n  attachments?: string[];\n}\n\ninterface BugPriorityScore {\n  bugId: string;\n  score: number;\n  factors: {\n    severity: number;\n    usersAffected: number;\n    businessImpact: number;\n    age: number;\n    recurrence: number;\n  };\n}\n\nexport class BugRepositoryService {\n  /**\n   * Report a new bug\n   */\n  async reportBug(report: BugReport): Promise<Bug> {\n    // Calculate initial priority and impact\n    const priority = this.calculatePriority(report.severity || BugSeverity.MEDIUM);\n    const impactScore = await this.calculateImpactScore(report);\n\n    const bug = await prisma.bug.create({\n      data: {\n        title: report.title,\n        description: report.description,\n        source: report.source,\n        severity: report.severity || BugSeverity.MEDIUM,\n        category: report.category || BugCategory.OTHER,\n        reportedBy: report.reportedBy,\n        reportedByEmail: report.reportedByEmail,\n        stackTrace: report.stackTrace,\n        errorMessage: report.errorMessage,\n        affectedComponent: report.affectedComponent,\n        environment: report.environment,\n        stepsToReproduce: report.stepsToReproduce,\n        expectedBehavior: report.expectedBehavior,\n        actualBehavior: report.actualBehavior,\n        attachments: report.attachments || [],\n        priority,\n        impactScore,\n        status: BugStatus.NEW,\n      },\n    });\n\n    // Check for duplicates\n    await this.checkForDuplicates(bug.id);\n\n    // Log bug creation\n    await this.logBugHistory(bug.id, \'status\', null, BugStatus.NEW, \'SYSTEM\');\n\n    // Notify relevant parties\n    await this.notifyBugCreated(bug);\n\n    return bug;\n  }\n\n  /**\n   * Detect bugs from system monitoring\n   */\n  async detectSystemBugs(): Promise<BugDetectionResult> {\n    const detectedBugs: Bug[] = [];\n\n    // Check error logs for patterns\n    const errorPatterns = await this.analyzeErrorLogs();\n    for (const pattern of errorPatterns) {\n      const bug = await this.reportBug({\n        title: `System Error: ${pattern.errorType}`,\n        description: `Detected recurring error pattern: ${pattern.description}`,\n        source: BugSource.SYSTEM_DETECTION,\n        severity: this.mapErrorSeverity(pattern.frequency, pattern.impact),\n        category: this.categorizeError(pattern.errorType),\n        errorMessage: pattern.sampleError,\n        affectedComponent: pattern.component,\n        environment: \'PRODUCTION\',\n      });\n      detectedBugs.push(bug);\n    }\n\n    // Check performance degradation\n    const performanceIssues = await this.detectPerformanceIssues();\n    for (const issue of performanceIssues) {\n      const bug = await this.reportBug({\n        title: `Performance Degradation: ${issue.component}`,\n        description: `Detected performance issue: ${issue.description}`,\n        source: BugSource.PERFORMANCE_MON,\n        severity: BugSeverity.MEDIUM,\n        category: BugCategory.PERFORMANCE,\n        affectedComponent: issue.component,\n        environment: \'PRODUCTION\',\n      });\n      detectedBugs.push(bug);\n    }\n\n    return {\n      detected: detectedBugs.length > 0,\n      bugs: detectedBugs,\n      source: BugSource.SYSTEM_DETECTION,\n    };\n  }\n\n  /**\n   * Triage a bug (categorize and prioritize)\n   */\n  async triageBug(bugId: string, triageData: {\n    severity?: BugSeverity;\n    category?: BugCategory;\n    priority?: number;\n    assignedTo?: string;\n  }): Promise<Bug> {\n    const bug = await prisma.bug.findUnique({ where: { id: bugId } });\n    if (!bug) throw new Error(\'Bug not found\');\n\n    const updates: any = {\n      status: BugStatus.TRIAGED,\n      updatedAt: new Date(),\n    };\n\n    if (triageData.severity) {\n      await this.logBugHistory(bugId, \'severity\', bug.severity, triageData.severity, \'TRIAGE_SYSTEM\');\n      updates.severity = triageData.severity;\n    }\n\n    if (triageData.category) {\n      await this.logBugHistory(bugId, \'category\', bug.category, triageData.category, \'TRIAGE_SYSTEM\');\n      updates.category = triageData.category;\n    }\n\n    if (triageData.priority !== undefined) {\n      await this.logBugHistory(bugId, \'priority\', bug.priority.toString(), triageData.priority.toString(), \'TRIAGE_SYSTEM\');\n      updates.priority = triageData.priority;\n    }\n\n    if (triageData.assignedTo) {\n      updates.assignedTo = triageData.assignedTo;\n      updates.assignedAt = new Date();\n      await this.logBugHistory(bugId, \'assignedTo\', bug.assignedTo || \'null\', triageData.assignedTo, \'TRIAGE_SYSTEM\');\n    }\n\n    return await prisma.bug.update({\n      where: { id: bugId },\n      data: updates,\n    });\n  }\n\n  /**\n   * Update bug status\n   */\n  async updateBugStatus(bugId: string, newStatus: BugStatus, userId: string): Promise<Bug> {\n    const bug = await prisma.bug.findUnique({ where: { id: bugId } });\n    if (!bug) throw new Error(\'Bug not found\');\n\n    await this.logBugHistory(bugId, \'status\', bug.status, newStatus, userId);\n\n    const updates: any = {\n      status: newStatus,\n      updatedAt: new Date(),\n    };\n\n    // Set timestamps based on status\n    if (newStatus === BugStatus.CLOSED) {\n      updates.closedAt = new Date();\n    } else if (newStatus === BugStatus.FIXED) {\n      updates.fixedAt = new Date();\n      updates.fixedBy = userId;\n    }\n\n    return await prisma.bug.update({\n      where: { id: bugId },\n      data: updates,\n    });\n  }\n\n  /**\n   * Mark bug as duplicate\n   */\n  async markAsDuplicate(bugId: string, originalBugId: string): Promise<Bug> {\n    const bug = await prisma.bug.update({\n      where: { id: bugId },\n      data: {\n        isDuplicate: true,\n        duplicateOf: originalBugId,\n        status: BugStatus.DUPLICATE,\n      },\n    });\n\n    await this.logBugHistory(bugId, \'status\', bug.status, BugStatus.DUPLICATE, \'SYSTEM\');\n\n    return bug;\n  }\n\n  /**\n   * Get high-priority bugs\n   */\n  async getHighPriorityBugs(limit: number = 20): Promise<Bug[]> {\n    return await prisma.bug.findMany({\n      where: {\n        status: {\n          in: [BugStatus.NEW, BugStatus.TRIAGED, BugStatus.CONFIRMED, BugStatus.IN_PROGRESS],\n        },\n        isDuplicate: false,\n      },\n      orderBy: [\n        { severity: \'desc\' },\n        { priority: \'desc\' },\n        { reportedAt: \'asc\' },\n      ],\n      take: limit,\n    });\n  }\n\n  /**\n   * Get bugs by category\n   */\n  async getBugsByCategory(category: BugCategory, status?: BugStatus): Promise<Bug[]> {\n    const where: any = {\n      category,\n      isDuplicate: false,\n    };\n\n    if (status) {\n      where.status = status;\n    }\n\n    return await prisma.bug.findMany({\n      where,\n      orderBy: [\n        { severity: \'desc\' },\n        { priority: \'desc\' },\n      ],\n    });\n  }\n\n  /**\n   * Get bug statistics\n   */\n  async getBugStatistics(): Promise<any> {\n    const [\n      totalBugs,\n      openBugs,\n      criticalBugs,\n      bugsBySeverity,\n      bugsByCategory,\n      bugsByStatus,\n      averageResolutionTime,\n    ] = await Promise.all([\n      prisma.bug.count(),\n      prisma.bug.count({\n        where: {\n          status: {\n            in: [BugStatus.NEW, BugStatus.TRIAGED, BugStatus.CONFIRMED, BugStatus.IN_PROGRESS],\n          },\n        },\n      }),\n      prisma.bug.count({\n        where: {\n          severity: BugSeverity.CRITICAL,\n          status: {\n            notIn: [BugStatus.CLOSED, BugStatus.WONT_FIX],\n          },\n        },\n      }),\n      this.getBugCountBySeverity(),\n      this.getBugCountByCategory(),\n      this.getBugCountByStatus(),\n      this.calculateAverageResolutionTime(),\n    ]);\n\n    return {\n      total: totalBugs,\n      open: openBugs,\n      critical: criticalBugs,\n      bySeverity: bugsBySeverity,\n      byCategory: bugsByCategory,\n      byStatus: bugsByStatus,\n      averageResolutionTime,\n    };\n  }\n\n  /**\n   * Calculate bug priority score\n   */\n  async calculateBugPriorityScore(bugId: string): Promise<BugPriorityScore> {\n    const bug = await prisma.bug.findUnique({ where: { id: bugId } });\n    if (!bug) throw new Error(\'Bug not found\');\n\n    // Severity factor (0-40 points)\n    const severityScore = this.getSeverityScore(bug.severity);\n\n    // Users affected factor (0-25 points)\n    const usersAffectedScore = Math.min((bug.usersAffected || 0) / 100 * 25, 25);\n\n    // Business impact factor (0-20 points)\n    const businessImpactScore = bug.businessImpact ? 20 : 0;\n\n    // Age factor (0-10 points) - older bugs get higher priority\n    const ageInDays = (Date.now() - bug.reportedAt.getTime()) / (1000 * 60 * 60 * 24);\n    const ageScore = Math.min(ageInDays / 30 * 10, 10);\n\n    // Recurrence factor (0-5 points)\n    const recurrenceScore = await this.getRecurrenceScore(bugId);\n\n    const totalScore = severityScore + usersAffectedScore + businessImpactScore + ageScore + recurrenceScore;\n\n    return {\n      bugId,\n      score: Math.round(totalScore),\n      factors: {\n        severity: severityScore,\n        usersAffected: usersAffectedScore,\n        businessImpact: businessImpactScore,\n        age: ageScore,\n        recurrence: recurrenceScore,\n      },\n    };\n  }\n\n  /**\n   * Add comment to bug\n   */\n  async addComment(bugId: string, authorId: string, authorName: string, content: string, isInternal: boolean = false): Promise<void> {\n    await prisma.bugComment.create({\n      data: {\n        bugId,\n        authorId,\n        authorName,\n        content,\n        isInternal,\n      },\n    });\n  }\n\n  /**\n   * Create test case for bug\n   */\n  async createTestCase(bugId: string, testCase: {\n    title: string;\n    description: string;\n    steps: string;\n    expectedResult: string;\n    automated?: boolean;\n    testScript?: string;\n  }): Promise<void> {\n    await prisma.bugTestCase.create({\n      data: {\n        bugId,\n        ...testCase,\n      },\n    });\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  private calculatePriority(severity: BugSeverity): number {\n    const priorityMap = {\n      [BugSeverity.CRITICAL]: 100,\n      [BugSeverity.HIGH]: 75,\n      [BugSeverity.MEDIUM]: 50,\n      [BugSeverity.LOW]: 25,\n      [BugSeverity.TRIVIAL]: 10,\n    };\n    return priorityMap[severity];\n  }\n\n  private async calculateImpactScore(report: BugReport): Promise<number> {\n    // Base score on severity\n    let score = this.getSeverityScore(report.severity || BugSeverity.MEDIUM);\n\n    // Adjust based on environment\n    if (report.environment === \'PRODUCTION\') {\n      score *= 1.5;\n    }\n\n    // Adjust based on component criticality\n    if (report.affectedComponent) {\n      const criticalComponents = [\'authentication\', \'authorization\', \'payment\', \'data-integrity\'];\n      if (criticalComponents.some(c => report.affectedComponent?.toLowerCase().includes(c))) {\n        score *= 1.3;\n      }\n    }\n\n    return Math.min(score, 100);\n  }\n\n  private getSeverityScore(severity: BugSeverity): number {\n    const scoreMap = {\n      [BugSeverity.CRITICAL]: 40,\n      [BugSeverity.HIGH]: 30,\n      [BugSeverity.MEDIUM]: 20,\n      [BugSeverity.LOW]: 10,\n      [BugSeverity.TRIVIAL]: 5,\n    };\n    return scoreMap[severity];\n  }\n\n  private async checkForDuplicates(bugId: string): Promise<void> {\n    const bug = await prisma.bug.findUnique({ where: { id: bugId } });\n    if (!bug) return;\n\n    // Find similar bugs based on title and description\n    const similarBugs = await prisma.bug.findMany({\n      where: {\n        id: { not: bugId },\n        isDuplicate: false,\n        status: { notIn: [BugStatus.CLOSED, BugStatus.WONT_FIX] },\n        OR: [\n          { title: { contains: bug.title.substring(0, 20) } },\n          { errorMessage: bug.errorMessage ? { contains: bug.errorMessage.substring(0, 50) } : undefined },\n        ],\n      },\n    });\n\n    // If similar bugs found, mark as potential duplicate\n    if (similarBugs.length > 0) {\n      await prisma.bug.update({\n        where: { id: bugId },\n        data: {\n          relatedBugs: similarBugs.map(b => b.id),\n        },\n      });\n    }\n  }\n\n  private async logBugHistory(bugId: string, field: string, oldValue: string | null, newValue: string, changedBy: string): Promise<void> {\n    await prisma.bugHistory.create({\n      data: {\n        bugId,\n        field,\n        oldValue,\n        newValue,\n        changedBy,\n      },\n    });\n  }\n\n  private async notifyBugCreated(bug: Bug): Promise<void> {\n    // TODO: Implement notification logic\n    // - Send email to assigned developer\n    // - Post to Slack/Teams channel\n    // - Create notification in system\n    console.log(`Bug created: ${bug.id} - ${bug.title}`);\n  }\n\n  private async analyzeErrorLogs(): Promise<any[]> {\n    // TODO: Implement error log analysis\n    // - Query error logs from monitoring system\n    // - Identify patterns and recurring errors\n    // - Group similar errors\n    return [];\n  }\n\n  private async detectPerformanceIssues(): Promise<any[]> {\n    // TODO: Implement performance monitoring\n    // - Query performance metrics\n    // - Identify degradation patterns\n    // - Detect slow endpoints\n    return [];\n  }\n\n  private mapErrorSeverity(frequency: number, impact: string): BugSeverity {\n    if (impact === \'CRITICAL\' || frequency > 100) return BugSeverity.CRITICAL;\n    if (impact === \'HIGH\' || frequency > 50) return BugSeverity.HIGH;\n    if (frequency > 10) return BugSeverity.MEDIUM;\n    return BugSeverity.LOW;\n  }\n\n  private categorizeError(errorType: string): BugCategory {\n    const categoryMap: { [key: string]: BugCategory } = {\n      \'auth\': BugCategory.AUTHENTICATION,\n      \'permission\': BugCategory.AUTHORIZATION,\n      \'database\': BugCategory.DATABASE,\n      \'api\': BugCategory.API,\n      \'performance\': BugCategory.PERFORMANCE,\n      \'security\': BugCategory.SECURITY,\n    };\n\n    for (const [key, category] of Object.entries(categoryMap)) {\n      if (errorType.toLowerCase().includes(key)) {\n        return category;\n      }\n    }\n\n    return BugCategory.OTHER;\n  }\n\n  private async getBugCountBySeverity(): Promise<any> {\n    const counts = await prisma.bug.groupBy({\n      by: [\'severity\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.severity] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async getBugCountByCategory(): Promise<any> {\n    const counts = await prisma.bug.groupBy({\n      by: [\'category\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.category] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async getBugCountByStatus(): Promise<any> {\n    const counts = await prisma.bug.groupBy({\n      by: [\'status\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.status] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async calculateAverageResolutionTime(): Promise<number> {\n    const closedBugs = await prisma.bug.findMany({\n      where: {\n        status: BugStatus.CLOSED,\n        closedAt: { not: null },\n      },\n      select: {\n        reportedAt: true,\n        closedAt: true,\n      },\n    });\n\n    if (closedBugs.length === 0) return 0;\n\n    const totalTime = closedBugs.reduce((sum, bug) => {\n      const resolutionTime = bug.closedAt!.getTime() - bug.reportedAt.getTime();\n      return sum + resolutionTime;\n    }, 0);\n\n    // Return average in hours\n    return Math.round(totalTime / closedBugs.length / (1000 * 60 * 60));\n  }\n\n  private async getRecurrenceScore(bugId: string): Promise<number> {\n    const bug = await prisma.bug.findUnique({ where: { id: bugId } });\n    if (!bug) return 0;\n\n    // Check if similar bugs have been reported before\n    const similarBugs = await prisma.bug.count({\n      where: {\n        id: { not: bugId },\n        category: bug.category,\n        affectedComponent: bug.affectedComponent,\n        status: BugStatus.CLOSED,\n      },\n    });\n\n    return Math.min(similarBugs, 5);\n  }\n}\n\nexport default BugRepositoryService;\n</create-file>\n</function_calls>'}