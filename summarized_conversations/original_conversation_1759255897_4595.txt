{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/services/NotificationService.ts">\n/**\n * Notification Service\n * \n * Manages notifications across all repositories for bugs, features, deployments, and system events.\n * Supports multiple channels: email, in-app, Slack, webhooks.\n */\n\nimport { PrismaClient } from \'@prisma/client\';\n\nconst prisma = new PrismaClient();\n\nenum NotificationChannel {\n  EMAIL = \'EMAIL\',\n  IN_APP = \'IN_APP\',\n  SLACK = \'SLACK\',\n  WEBHOOK = \'WEBHOOK\',\n  SMS = \'SMS\',\n}\n\nenum NotificationPriority {\n  LOW = \'LOW\',\n  MEDIUM = \'MEDIUM\',\n  HIGH = \'HIGH\',\n  URGENT = \'URGENT\',\n}\n\nenum NotificationType {\n  BUG_CREATED = \'BUG_CREATED\',\n  BUG_ASSIGNED = \'BUG_ASSIGNED\',\n  BUG_STATUS_CHANGED = \'BUG_STATUS_CHANGED\',\n  BUG_CRITICAL = \'BUG_CRITICAL\',\n  FEATURE_CREATED = \'FEATURE_CREATED\',\n  FEATURE_APPROVED = \'FEATURE_APPROVED\',\n  FEATURE_COMPLETED = \'FEATURE_COMPLETED\',\n  DEPLOYMENT_STARTED = \'DEPLOYMENT_STARTED\',\n  DEPLOYMENT_SUCCESS = \'DEPLOYMENT_SUCCESS\',\n  DEPLOYMENT_FAILED = \'DEPLOYMENT_FAILED\',\n  TEST_FAILED = \'TEST_FAILED\',\n  ENVIRONMENT_DOWN = \'ENVIRONMENT_DOWN\',\n  CODE_REVIEW_REQUESTED = \'CODE_REVIEW_REQUESTED\',\n  SYSTEM_ALERT = \'SYSTEM_ALERT\',\n}\n\ninterface NotificationData {\n  type: NotificationType;\n  priority: NotificationPriority;\n  recipientId: string;\n  recipientEmail?: string;\n  title: string;\n  message: string;\n  data?: any;\n  channels?: NotificationChannel[];\n  actionUrl?: string;\n}\n\ninterface NotificationPreferences {\n  userId: string;\n  channels: NotificationChannel[];\n  bugNotifications: boolean;\n  featureNotifications: boolean;\n  deploymentNotifications: boolean;\n  systemAlerts: boolean;\n  emailDigest: boolean;\n  digestFrequency?: \'DAILY\' | \'WEEKLY\';\n}\n\nexport class NotificationService {\n  /**\n   * Send a notification\n   */\n  async sendNotification(data: NotificationData): Promise<void> {\n    // Get user preferences\n    const preferences = await this.getUserPreferences(data.recipientId);\n    \n    // Check if user wants this type of notification\n    if (!this.shouldSendNotification(data.type, preferences)) {\n      return;\n    }\n\n    // Determine channels to use\n    const channels = data.channels || preferences.channels || [NotificationChannel.IN_APP];\n\n    // Send to each channel\n    for (const channel of channels) {\n      try {\n        await this.sendToChannel(channel, data);\n      } catch (error) {\n        console.error(`Failed to send notification via ${channel}:`, error);\n      }\n    }\n\n    // Store notification in database\n    await this.storeNotification(data);\n  }\n\n  /**\n   * Send bulk notifications\n   */\n  async sendBulkNotifications(notifications: NotificationData[]): Promise<void> {\n    await Promise.all(notifications.map(n => this.sendNotification(n)));\n  }\n\n  /**\n   * Notify about new bug\n   */\n  async notifyBugCreated(bugId: string, bug: any): Promise<void> {\n    const priority = this.mapBugSeverityToPriority(bug.severity);\n    \n    // Notify assigned developer\n    if (bug.assignedTo) {\n      await this.sendNotification({\n        type: NotificationType.BUG_CREATED,\n        priority,\n        recipientId: bug.assignedTo,\n        title: `New Bug Assigned: ${bug.title}`,\n        message: `A ${bug.severity} bug has been assigned to you: ${bug.description.substring(0, 100)}...`,\n        data: { bugId, bug },\n        actionUrl: `/bugs/${bugId}`,\n      });\n    }\n\n    // Notify team leads for critical bugs\n    if (bug.severity === \'CRITICAL\') {\n      await this.notifyTeamLeads({\n        type: NotificationType.BUG_CRITICAL,\n        priority: NotificationPriority.URGENT,\n        title: `CRITICAL BUG: ${bug.title}`,\n        message: `A critical bug has been reported: ${bug.description}`,\n        data: { bugId, bug },\n        actionUrl: `/bugs/${bugId}`,\n      });\n    }\n  }\n\n  /**\n   * Notify about bug status change\n   */\n  async notifyBugStatusChanged(bugId: string, bug: any, oldStatus: string, newStatus: string): Promise<void> {\n    // Notify reporter\n    if (bug.reportedBy) {\n      await this.sendNotification({\n        type: NotificationType.BUG_STATUS_CHANGED,\n        priority: NotificationPriority.MEDIUM,\n        recipientId: bug.reportedBy,\n        title: `Bug Status Updated: ${bug.title}`,\n        message: `Bug status changed from ${oldStatus} to ${newStatus}`,\n        data: { bugId, bug, oldStatus, newStatus },\n        actionUrl: `/bugs/${bugId}`,\n      });\n    }\n\n    // Notify assigned developer\n    if (bug.assignedTo && bug.assignedTo !== bug.reportedBy) {\n      await this.sendNotification({\n        type: NotificationType.BUG_STATUS_CHANGED,\n        priority: NotificationPriority.MEDIUM,\n        recipientId: bug.assignedTo,\n        title: `Bug Status Updated: ${bug.title}`,\n        message: `Bug status changed from ${oldStatus} to ${newStatus}`,\n        data: { bugId, bug, oldStatus, newStatus },\n        actionUrl: `/bugs/${bugId}`,\n      });\n    }\n  }\n\n  /**\n   * Notify about new feature request\n   */\n  async notifyFeatureCreated(featureId: string, feature: any): Promise<void> {\n    // Notify product team\n    await this.notifyProductTeam({\n      type: NotificationType.FEATURE_CREATED,\n      priority: NotificationPriority.MEDIUM,\n      title: `New Feature Request: ${feature.title}`,\n      message: `A new feature has been requested: ${feature.description.substring(0, 100)}...`,\n      data: { featureId, feature },\n      actionUrl: `/features/${featureId}`,\n    });\n  }\n\n  /**\n   * Notify about feature approval\n   */\n  async notifyFeatureApproved(featureId: string, feature: any): Promise<void> {\n    // Notify requester\n    if (feature.requestedBy) {\n      await this.sendNotification({\n        type: NotificationType.FEATURE_APPROVED,\n        priority: NotificationPriority.HIGH,\n        recipientId: feature.requestedBy,\n        title: `Feature Approved: ${feature.title}`,\n        message: `Your feature request has been approved and added to the roadmap!`,\n        data: { featureId, feature },\n        actionUrl: `/features/${featureId}`,\n      });\n    }\n\n    // Notify development team\n    await this.notifyDevelopmentTeam({\n      type: NotificationType.FEATURE_APPROVED,\n      priority: NotificationPriority.MEDIUM,\n      title: `New Feature Approved: ${feature.title}`,\n      message: `A new feature has been approved for development: ${feature.description.substring(0, 100)}...`,\n      data: { featureId, feature },\n      actionUrl: `/features/${featureId}`,\n    });\n  }\n\n  /**\n   * Notify about deployment\n   */\n  async notifyDeploymentStarted(projectId: string, deployment: any): Promise<void> {\n    await this.notifyDevelopmentTeam({\n      type: NotificationType.DEPLOYMENT_STARTED,\n      priority: NotificationPriority.MEDIUM,\n      title: `Deployment Started: ${deployment.environment}`,\n      message: `Deployment to ${deployment.environment} has started for version ${deployment.version}`,\n      data: { projectId, deployment },\n      actionUrl: `/projects/${projectId}/deployments`,\n    });\n  }\n\n  /**\n   * Notify about deployment success\n   */\n  async notifyDeploymentSuccess(projectId: string, deployment: any): Promise<void> {\n    await this.notifyDevelopmentTeam({\n      type: NotificationType.DEPLOYMENT_SUCCESS,\n      priority: NotificationPriority.MEDIUM,\n      title: `Deployment Successful: ${deployment.environment}`,\n      message: `Version ${deployment.version} has been successfully deployed to ${deployment.environment}`,\n      data: { projectId, deployment },\n      actionUrl: `/projects/${projectId}/deployments`,\n    });\n  }\n\n  /**\n   * Notify about deployment failure\n   */\n  async notifyDeploymentFailed(projectId: string, deployment: any): Promise<void> {\n    await this.notifyDevelopmentTeam({\n      type: NotificationType.DEPLOYMENT_FAILED,\n      priority: NotificationPriority.URGENT,\n      title: `Deployment Failed: ${deployment.environment}`,\n      message: `Deployment to ${deployment.environment} has failed: ${deployment.errorMessage}`,\n      data: { projectId, deployment },\n      actionUrl: `/projects/${projectId}/deployments`,\n      channels: [NotificationChannel.EMAIL, NotificationChannel.SLACK, NotificationChannel.IN_APP],\n    });\n  }\n\n  /**\n   * Notify about test failures\n   */\n  async notifyTestFailed(projectId: string, testRun: any): Promise<void> {\n    await this.notifyDevelopmentTeam({\n      type: NotificationType.TEST_FAILED,\n      priority: NotificationPriority.HIGH,\n      title: `Tests Failed: ${testRun.testSuite}`,\n      message: `${testRun.failedTests} tests failed in ${testRun.environment} environment`,\n      data: { projectId, testRun },\n      actionUrl: `/projects/${projectId}/tests`,\n    });\n  }\n\n  /**\n   * Notify about environment issues\n   */\n  async notifyEnvironmentDown(environment: string, issues: string[]): Promise<void> {\n    await this.notifyTeamLeads({\n      type: NotificationType.ENVIRONMENT_DOWN,\n      priority: NotificationPriority.URGENT,\n      title: `Environment Down: ${environment}`,\n      message: `The ${environment} environment is experiencing issues: ${issues.join(\', \')}`,\n      data: { environment, issues },\n      channels: [NotificationChannel.EMAIL, NotificationChannel.SLACK, NotificationChannel.SMS],\n    });\n  }\n\n  /**\n   * Notify about code review request\n   */\n  async notifyCodeReviewRequested(projectId: string, reviewerId: string, changes: any[]): Promise<void> {\n    await this.sendNotification({\n      type: NotificationType.CODE_REVIEW_REQUESTED,\n      priority: NotificationPriority.MEDIUM,\n      recipientId: reviewerId,\n      title: `Code Review Requested`,\n      message: `You have been requested to review ${changes.length} code changes`,\n      data: { projectId, changes },\n      actionUrl: `/projects/${projectId}/reviews`,\n    });\n  }\n\n  /**\n   * Send system alert\n   */\n  async sendSystemAlert(title: string, message: string, priority: NotificationPriority = NotificationPriority.HIGH): Promise<void> {\n    await this.notifyTeamLeads({\n      type: NotificationType.SYSTEM_ALERT,\n      priority,\n      title,\n      message,\n      channels: [NotificationChannel.EMAIL, NotificationChannel.SLACK, NotificationChannel.IN_APP],\n    });\n  }\n\n  /**\n   * Get user notifications\n   */\n  async getUserNotifications(userId: string, unreadOnly: boolean = false): Promise<any[]> {\n    // TODO: Implement database query for notifications\n    // This would query a Notification table\n    return [];\n  }\n\n  /**\n   * Mark notification as read\n   */\n  async markAsRead(notificationId: string): Promise<void> {\n    // TODO: Implement database update\n  }\n\n  /**\n   * Update user notification preferences\n   */\n  async updatePreferences(preferences: NotificationPreferences): Promise<void> {\n    // TODO: Implement database update for user preferences\n  }\n\n  /**\n   * Get user notification preferences\n   */\n  async getUserPreferences(userId: string): Promise<NotificationPreferences> {\n    // TODO: Implement database query for preferences\n    // Return default preferences for now\n    return {\n      userId,\n      channels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL],\n      bugNotifications: true,\n      featureNotifications: true,\n      deploymentNotifications: true,\n      systemAlerts: true,\n      emailDigest: false,\n    };\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  private async sendToChannel(channel: NotificationChannel, data: NotificationData): Promise<void> {\n    switch (channel) {\n      case NotificationChannel.EMAIL:\n        await this.sendEmail(data);\n        break;\n      case NotificationChannel.IN_APP:\n        await this.sendInApp(data);\n        break;\n      case NotificationChannel.SLACK:\n        await this.sendSlack(data);\n        break;\n      case NotificationChannel.WEBHOOK:\n        await this.sendWebhook(data);\n        break;\n      case NotificationChannel.SMS:\n        await this.sendSMS(data);\n        break;\n    }\n  }\n\n  private async sendEmail(data: NotificationData): Promise<void> {\n    // TODO: Integrate with email service (SendGrid, AWS SES, etc.)\n    console.log(`Sending email to ${data.recipientEmail}: ${data.title}`);\n  }\n\n  private async sendInApp(data: NotificationData): Promise<void> {\n    // TODO: Store in database for in-app display\n    console.log(`Sending in-app notification to ${data.recipientId}: ${data.title}`);\n  }\n\n  private async sendSlack(data: NotificationData): Promise<void> {\n    // TODO: Integrate with Slack API\n    console.log(`Sending Slack notification: ${data.title}`);\n  }\n\n  private async sendWebhook(data: NotificationData): Promise<void> {\n    // TODO: Send to configured webhook URL\n    console.log(`Sending webhook notification: ${data.title}`);\n  }\n\n  private async sendSMS(data: NotificationData): Promise<void> {\n    // TODO: Integrate with SMS service (Twilio, AWS SNS, etc.)\n    console.log(`Sending SMS notification: ${data.title}`);\n  }\n\n  private async storeNotification(data: NotificationData): Promise<void> {\n    // TODO: Store notification in database\n    console.log(`Storing notification: ${data.title}`);\n  }\n\n  private shouldSendNotification(type: NotificationType, preferences: NotificationPreferences): boolean {\n    // Check if user wants this category of notifications\n    if (type.startsWith(\'BUG_\') && !preferences.bugNotifications) return false;\n    if (type.startsWith(\'FEATURE_\') && !preferences.featureNotifications) return false;\n    if (type.startsWith(\'DEPLOYMENT_\') && !preferences.deploymentNotifications) return false;\n    if (type === NotificationType.SYSTEM_ALERT && !preferences.systemAlerts) return false;\n\n    return true;\n  }\n\n  private mapBugSeverityToPriority(severity: string): NotificationPriority {\n    const map: { [key: string]: NotificationPriority } = {\n      CRITICAL: NotificationPriority.URGENT,\n      HIGH: NotificationPriority.HIGH,\n      MEDIUM: NotificationPriority.MEDIUM,\n      LOW: NotificationPriority.LOW,\n      TRIVIAL: NotificationPriority.LOW,\n    };\n    return map[severity] || NotificationPriority.MEDIUM;\n  }\n\n  private async notifyTeamLeads(data: Omit<NotificationData, \'recipientId\'>): Promise<void> {\n    // TODO: Get team lead IDs from database\n    const teamLeadIds = [\'TEAM_LEAD_1\', \'TEAM_LEAD_2\'];\n    \n    for (const leadId of teamLeadIds) {\n      await this.sendNotification({\n        ...data,\n        recipientId: leadId,\n      });\n    }\n  }\n\n  private async notifyProductTeam(data: Omit<NotificationData, \'recipientId\'>): Promise<void> {\n    // TODO: Get product team IDs from database\n    const productTeamIds = [\'PRODUCT_MANAGER_1\', \'PRODUCT_OWNER_1\'];\n    \n    for (const memberId of productTeamIds) {\n      await this.sendNotification({\n        ...data,\n        recipientId: memberId,\n      });\n    }\n  }\n\n  private async notifyDevelopmentTeam(data: Omit<NotificationData, \'recipientId\'>): Promise<void> {\n    // TODO: Get development team IDs from database\n    const devTeamIds = [\'DEV_1\', \'DEV_2\', \'DEV_3\'];\n    \n    for (const devId of devTeamIds) {\n      await this.sendNotification({\n        ...data,\n        recipientId: devId,\n      });\n    }\n  }\n}\n\nexport default NotificationService;\n</create-file>\n</function_calls>'}