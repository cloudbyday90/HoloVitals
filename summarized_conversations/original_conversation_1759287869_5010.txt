{'role': 'assistant', 'content': 'Now let\'s create the SMART on FHIR authentication service:\n\n<function_calls>\n<create-file file_path="medical-analysis-platform/lib/fhir/SMARTAuthService.ts">\n/**\n * SMART on FHIR Authentication Service\n * \n * Handles OAuth2 authentication flow for SMART on FHIR\n * Supports authorization code flow with PKCE\n */\n\nimport { AuthorizationCode } from \'simple-oauth2\';\nimport crypto from \'crypto\';\n\nexport interface SMARTAuthConfig {\n  clientId: string;\n  clientSecret?: string;\n  redirectUri: string;\n  authorizationUrl: string;\n  tokenUrl: string;\n  scopes: string[];\n}\n\nexport interface AuthorizationParams {\n  state: string;\n  codeVerifier: string;\n  codeChallenge: string;\n}\n\nexport interface TokenResponse {\n  accessToken: string;\n  refreshToken?: string;\n  expiresIn: number;\n  expiresAt: Date;\n  patientId?: string;\n  scope?: string;\n}\n\nexport class SMARTAuthService {\n  private oauth2Client: AuthorizationCode;\n  private config: SMARTAuthConfig;\n\n  constructor(config: SMARTAuthConfig) {\n    this.config = config;\n\n    this.oauth2Client = new AuthorizationCode({\n      client: {\n        id: config.clientId,\n        secret: config.clientSecret,\n      },\n      auth: {\n        tokenHost: new URL(config.tokenUrl).origin,\n        tokenPath: new URL(config.tokenUrl).pathname,\n        authorizePath: new URL(config.authorizationUrl).pathname,\n      },\n    });\n  }\n\n  /**\n   * Generate authorization URL for user to visit\n   * Returns URL and parameters needed for callback\n   */\n  generateAuthorizationUrl(launch?: string): {\n    url: string;\n    params: AuthorizationParams;\n  } {\n    // Generate PKCE parameters\n    const codeVerifier = this.generateCodeVerifier();\n    const codeChallenge = this.generateCodeChallenge(codeVerifier);\n    const state = this.generateState();\n\n    const authorizationParams: any = {\n      redirect_uri: this.config.redirectUri,\n      scope: this.config.scopes.join(\' \'),\n      state,\n      code_challenge: codeChallenge,\n      code_challenge_method: \'S256\',\n      response_type: \'code\',\n      aud: this.extractAudience(this.config.authorizationUrl),\n    };\n\n    // Add launch parameter if provided (for EHR launch)\n    if (launch) {\n      authorizationParams.launch = launch;\n    }\n\n    const url = this.oauth2Client.authorizeURL(authorizationParams);\n\n    return {\n      url,\n      params: {\n        state,\n        codeVerifier,\n        codeChallenge,\n      },\n    };\n  }\n\n  /**\n   * Exchange authorization code for access token\n   */\n  async getAccessToken(\n    code: string,\n    codeVerifier: string\n  ): Promise<TokenResponse> {\n    try {\n      const tokenParams = {\n        code,\n        redirect_uri: this.config.redirectUri,\n        code_verifier: codeVerifier,\n      };\n\n      const result = await this.oauth2Client.getToken(tokenParams);\n      const token = result.token;\n\n      return {\n        accessToken: token.access_token as string,\n        refreshToken: token.refresh_token as string | undefined,\n        expiresIn: token.expires_in as number,\n        expiresAt: new Date(Date.now() + (token.expires_in as number) * 1000),\n        patientId: token.patient as string | undefined,\n        scope: token.scope as string | undefined,\n      };\n    } catch (error: any) {\n      throw new SMARTAuthError(\n        `Failed to exchange authorization code: ${error.message}`,\n        error\n      );\n    }\n  }\n\n  /**\n   * Refresh access token using refresh token\n   */\n  async refreshAccessToken(refreshToken: string): Promise<TokenResponse> {\n    try {\n      const accessToken = this.oauth2Client.createToken({\n        refresh_token: refreshToken,\n      });\n\n      const result = await accessToken.refresh();\n      const token = result.token;\n\n      return {\n        accessToken: token.access_token as string,\n        refreshToken: token.refresh_token as string | undefined,\n        expiresIn: token.expires_in as number,\n        expiresAt: new Date(Date.now() + (token.expires_in as number) * 1000),\n        patientId: token.patient as string | undefined,\n        scope: token.scope as string | undefined,\n      };\n    } catch (error: any) {\n      throw new SMARTAuthError(\n        `Failed to refresh access token: ${error.message}`,\n        error\n      );\n    }\n  }\n\n  /**\n   * Check if token is expired or will expire soon\n   */\n  isTokenExpired(expiresAt: Date, bufferSeconds: number = 300): boolean {\n    const now = new Date();\n    const expiryWithBuffer = new Date(expiresAt.getTime() - bufferSeconds * 1000);\n    return now >= expiryWithBuffer;\n  }\n\n  /**\n   * Generate PKCE code verifier\n   */\n  private generateCodeVerifier(): string {\n    return crypto.randomBytes(32).toString(\'base64url\');\n  }\n\n  /**\n   * Generate PKCE code challenge from verifier\n   */\n  private generateCodeChallenge(verifier: string): string {\n    return crypto\n      .createHash(\'sha256\')\n      .update(verifier)\n      .digest(\'base64url\');\n  }\n\n  /**\n   * Generate random state parameter\n   */\n  private generateState(): string {\n    return crypto.randomBytes(16).toString(\'hex\');\n  }\n\n  /**\n   * Extract audience (aud) parameter from authorization URL\n   */\n  private extractAudience(authUrl: string): string {\n    // For SMART on FHIR, the audience is typically the FHIR base URL\n    // Extract from the authorization URL\n    const url = new URL(authUrl);\n    return `${url.protocol}//${url.host}`;\n  }\n}\n\n/**\n * SMART Auth Error class\n */\nexport class SMARTAuthError extends Error {\n  constructor(message: string, public originalError?: any) {\n    super(message);\n    this.name = \'SMARTAuthError\';\n  }\n}\n\n/**\n * Helper function to parse SMART launch parameters\n */\nexport function parseLaunchParameters(launchParams: string): {\n  iss?: string;\n  launch?: string;\n} {\n  const params = new URLSearchParams(launchParams);\n  return {\n    iss: params.get(\'iss\') || undefined,\n    launch: params.get(\'launch\') || undefined,\n  };\n}\n\n/**\n * Standard SMART on FHIR scopes\n */\nexport const SMART_SCOPES = {\n  // Patient-level scopes\n  PATIENT_READ: \'patient/*.read\',\n  PATIENT_WRITE: \'patient/*.write\',\n  \n  // Specific resource scopes\n  PATIENT_PATIENT_READ: \'patient/Patient.read\',\n  PATIENT_OBSERVATION_READ: \'patient/Observation.read\',\n  PATIENT_CONDITION_READ: \'patient/Condition.read\',\n  PATIENT_MEDICATION_READ: \'patient/MedicationRequest.read\',\n  PATIENT_ALLERGY_READ: \'patient/AllergyIntolerance.read\',\n  PATIENT_IMMUNIZATION_READ: \'patient/Immunization.read\',\n  PATIENT_PROCEDURE_READ: \'patient/Procedure.read\',\n  PATIENT_DOCUMENT_READ: \'patient/DocumentReference.read\',\n  \n  // OpenID Connect\n  OPENID: \'openid\',\n  PROFILE: \'profile\',\n  \n  // Launch context\n  LAUNCH: \'launch\',\n  LAUNCH_PATIENT: \'launch/patient\',\n  \n  // Offline access\n  OFFLINE_ACCESS: \'offline_access\',\n};\n\n/**\n * Get default patient-facing scopes\n */\nexport function getDefaultPatientScopes(): string[] {\n  return [\n    SMART_SCOPES.OPENID,\n    SMART_SCOPES.PROFILE,\n    SMART_SCOPES.LAUNCH_PATIENT,\n    SMART_SCOPES.OFFLINE_ACCESS,\n    SMART_SCOPES.PATIENT_PATIENT_READ,\n    SMART_SCOPES.PATIENT_OBSERVATION_READ,\n    SMART_SCOPES.PATIENT_CONDITION_READ,\n    SMART_SCOPES.PATIENT_MEDICATION_READ,\n    SMART_SCOPES.PATIENT_ALLERGY_READ,\n    SMART_SCOPES.PATIENT_IMMUNIZATION_READ,\n    SMART_SCOPES.PATIENT_PROCEDURE_READ,\n    SMART_SCOPES.PATIENT_DOCUMENT_READ,\n  ];\n}\n</create-file>\n</function_calls>'}