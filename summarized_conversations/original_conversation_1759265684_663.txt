{'role': 'assistant', 'content': 'Now let\'s create a comprehensive test file:\n\n<function_calls>\n<create-file file_path="medical-analysis-platform/__tests__/services/LightweightChatbotService.test.ts">\n/**\n * Tests for LightweightChatbotService\n */\n\nimport { LightweightChatbotService } from \'@/lib/services/LightweightChatbotService\';\nimport { ChatRequest, MessageRole, QueryComplexity } from \'@/lib/types/chatbot\';\nimport { PrismaClient } from \'@prisma/client\';\n\n// Mock Prisma\njest.mock(\'@prisma/client\', () => ({\n  PrismaClient: jest.fn().mockImplementation(() => ({\n    chatConversation: {\n      create: jest.fn(),\n      findUnique: jest.fn(),\n      findMany: jest.fn(),\n      update: jest.fn(),\n      delete: jest.fn(),\n    },\n    chatMessage: {\n      create: jest.fn(),\n      findMany: jest.fn(),\n      deleteMany: jest.fn(),\n    },\n    aIInteraction: {\n      create: jest.fn(),\n    },\n    chatbotCost: {\n      create: jest.fn(),\n    },\n    $disconnect: jest.fn(),\n  })),\n}));\n\n// Mock OpenAI\njest.mock(\'@/lib/utils/openai\', () => ({\n  createChatCompletion: jest.fn().mockResolvedValue({\n    choices: [{ message: { content: \'Test response\' } }],\n    usage: {\n      prompt_tokens: 50,\n      completion_tokens: 20,\n      total_tokens: 70,\n    },\n  }),\n  createStreamingChatCompletion: jest.fn(),\n  calculateCost: jest.fn().mockReturnValue(0.001),\n  withRetry: jest.fn((fn) => fn()),\n}));\n\n// Mock token counter\njest.mock(\'@/lib/utils/tokenCounter\', () => ({\n  countMessageTokens: jest.fn().mockReturnValue(50),\n  truncateMessages: jest.fn((messages) => messages),\n  getAvailableCompletionTokens: jest.fn().mockReturnValue(500),\n  getContextWindowSize: jest.fn().mockReturnValue(4096),\n}));\n\n// Mock query classifier\njest.mock(\'@/lib/utils/queryClassifier\', () => ({\n  classifyQueryComplexity: jest.fn().mockReturnValue(\'SIMPLE\'),\n  shouldEscalate: jest.fn().mockReturnValue({\n    shouldEscalate: false,\n    confidence: 0.9,\n    complexity: \'SIMPLE\',\n  }),\n  getSuggestedFollowUps: jest.fn().mockReturnValue([\n    \'Would you like more information?\',\n  ]),\n  estimateClassificationConfidence: jest.fn().mockReturnValue(0.9),\n}));\n\ndescribe(\'LightweightChatbotService\', () => {\n  let service: LightweightChatbotService;\n  let mockPrisma: any;\n\n  beforeEach(() => {\n    service = new LightweightChatbotService();\n    mockPrisma = (service as any).prisma;\n    jest.clearAllMocks();\n  });\n\n  afterEach(async () => {\n    await service.cleanup();\n  });\n\n  describe(\'chat\', () => {\n    it(\'should process a simple chat request\', async () => {\n      const mockConversation = {\n        id: \'conv-123\',\n        userId: \'user-123\',\n        title: \'Test Conversation\',\n        totalTokens: 0,\n        totalCost: 0,\n        isActive: true,\n      };\n\n      const mockMessage = {\n        id: \'msg-123\',\n        conversationId: \'conv-123\',\n        role: MessageRole.ASSISTANT,\n        content: \'Test response\',\n        tokens: 20,\n      };\n\n      mockPrisma.chatConversation.create.mockResolvedValue(mockConversation);\n      mockPrisma.chatMessage.create.mockResolvedValue(mockMessage);\n      mockPrisma.chatConversation.findUnique.mockResolvedValue({\n        ...mockConversation,\n        messages: [],\n      });\n      mockPrisma.chatMessage.findMany.mockResolvedValue([]);\n\n      const request: ChatRequest = {\n        userId: \'user-123\',\n        message: \'What is my blood pressure?\',\n      };\n\n      const response = await service.chat(request);\n\n      expect(response).toBeDefined();\n      expect(response.content).toBe(\'Test response\');\n      expect(response.role).toBe(MessageRole.ASSISTANT);\n      expect(response.escalated).toBe(false);\n      expect(response.processingTime).toBeGreaterThan(0);\n      expect(mockPrisma.chatConversation.create).toHaveBeenCalled();\n      expect(mockPrisma.chatMessage.create).toHaveBeenCalledTimes(2);\n    });\n\n    it(\'should handle escalation for complex queries\', async () => {\n      const { shouldEscalate } = require(\'@/lib/utils/queryClassifier\');\n      shouldEscalate.mockReturnValueOnce({\n        shouldEscalate: true,\n        reason: \'COMPLEXITY\',\n        confidence: 0.9,\n        complexity: \'COMPLEX\',\n      });\n\n      const mockConversation = {\n        id: \'conv-123\',\n        userId: \'user-123\',\n        title: \'Test Conversation\',\n        totalTokens: 0,\n        totalCost: 0,\n        isActive: true,\n      };\n\n      const mockMessage = {\n        id: \'msg-123\',\n        conversationId: \'conv-123\',\n        role: MessageRole.ASSISTANT,\n        content: \'Escalation message\',\n        tokens: 20,\n      };\n\n      mockPrisma.chatConversation.create.mockResolvedValue(mockConversation);\n      mockPrisma.chatMessage.create.mockResolvedValue(mockMessage);\n\n      const request: ChatRequest = {\n        userId: \'user-123\',\n        message: \'Analyze all my lab results and compare trends over the past year\',\n      };\n\n      const response = await service.chat(request);\n\n      expect(response.escalated).toBe(true);\n      expect(response.escalationReason).toBe(\'COMPLEXITY\');\n      expect(response.cost).toBe(0); // No API cost for escalation\n    });\n\n    it(\'should use existing conversation if conversationId provided\', async () => {\n      const mockConversation = {\n        id: \'conv-existing\',\n        userId: \'user-123\',\n        title: \'Existing Conversation\',\n        totalTokens: 100,\n        totalCost: 0.01,\n        isActive: true,\n      };\n\n      mockPrisma.chatConversation.findUnique.mockResolvedValue({\n        ...mockConversation,\n        messages: [],\n      });\n      mockPrisma.chatMessage.create.mockResolvedValue({\n        id: \'msg-123\',\n        conversationId: \'conv-existing\',\n        role: MessageRole.ASSISTANT,\n        content: \'Test response\',\n        tokens: 20,\n      });\n      mockPrisma.chatMessage.findMany.mockResolvedValue([]);\n\n      const request: ChatRequest = {\n        conversationId: \'conv-existing\',\n        userId: \'user-123\',\n        message: \'Follow-up question\',\n      };\n\n      await service.chat(request);\n\n      expect(mockPrisma.chatConversation.findUnique).toHaveBeenCalledWith({\n        where: { id: \'conv-existing\' },\n      });\n      expect(mockPrisma.chatConversation.create).not.toHaveBeenCalled();\n    });\n\n    it(\'should include conversation history in context\', async () => {\n      const mockConversation = {\n        id: \'conv-123\',\n        userId: \'user-123\',\n        title: \'Test Conversation\',\n        totalTokens: 0,\n        totalCost: 0,\n        isActive: true,\n      };\n\n      const mockHistory = [\n        {\n          id: \'msg-1\',\n          conversationId: \'conv-123\',\n          role: \'USER\',\n          content: \'Previous question\',\n          tokens: 10,\n          createdAt: new Date(),\n        },\n        {\n          id: \'msg-2\',\n          conversationId: \'conv-123\',\n          role: \'ASSISTANT\',\n          content: \'Previous answer\',\n          tokens: 15,\n          createdAt: new Date(),\n        },\n      ];\n\n      mockPrisma.chatConversation.create.mockResolvedValue(mockConversation);\n      mockPrisma.chatMessage.findMany.mockResolvedValue(mockHistory);\n      mockPrisma.chatMessage.create.mockResolvedValue({\n        id: \'msg-123\',\n        conversationId: \'conv-123\',\n        role: MessageRole.ASSISTANT,\n        content: \'Test response\',\n        tokens: 20,\n      });\n      mockPrisma.chatConversation.findUnique.mockResolvedValue({\n        ...mockConversation,\n        messages: mockHistory,\n      });\n\n      const request: ChatRequest = {\n        userId: \'user-123\',\n        message: \'Follow-up question\',\n        context: { includeHistory: true },\n      };\n\n      await service.chat(request);\n\n      expect(mockPrisma.chatMessage.findMany).toHaveBeenCalledWith({\n        where: { conversationId: mockConversation.id },\n        orderBy: { createdAt: \'asc\' },\n        take: expect.any(Number),\n      });\n    });\n  });\n\n  describe(\'getConversationHistory\', () => {\n    it(\'should retrieve conversation with messages\', async () => {\n      const mockConversation = {\n        id: \'conv-123\',\n        userId: \'user-123\',\n        title: \'Test Conversation\',\n        messages: [\n          { id: \'msg-1\', content: \'Message 1\' },\n          { id: \'msg-2\', content: \'Message 2\' },\n        ],\n      };\n\n      mockPrisma.chatConversation.findUnique.mockResolvedValue(mockConversation);\n\n      const result = await service.getConversationHistory(\'conv-123\');\n\n      expect(result).toEqual(mockConversation);\n      expect(mockPrisma.chatConversation.findUnique).toHaveBeenCalledWith({\n        where: { id: \'conv-123\' },\n        include: {\n          messages: {\n            orderBy: { createdAt: \'asc\' },\n          },\n        },\n      });\n    });\n  });\n\n  describe(\'getUserConversations\', () => {\n    it(\'should retrieve all conversations for a user\', async () => {\n      const mockConversations = [\n        {\n          id: \'conv-1\',\n          userId: \'user-123\',\n          title: \'Conversation 1\',\n          messages: [{ id: \'msg-1\', content: \'Latest message\' }],\n        },\n        {\n          id: \'conv-2\',\n          userId: \'user-123\',\n          title: \'Conversation 2\',\n          messages: [{ id: \'msg-2\', content: \'Latest message\' }],\n        },\n      ];\n\n      mockPrisma.chatConversation.findMany.mockResolvedValue(mockConversations);\n\n      const result = await service.getUserConversations(\'user-123\');\n\n      expect(result).toEqual(mockConversations);\n      expect(mockPrisma.chatConversation.findMany).toHaveBeenCalledWith({\n        where: { userId: \'user-123\' },\n        orderBy: { updatedAt: \'desc\' },\n        include: {\n          messages: {\n            take: 1,\n            orderBy: { createdAt: \'desc\' },\n          },\n        },\n      });\n    });\n  });\n\n  describe(\'deleteConversation\', () => {\n    it(\'should delete conversation and all messages\', async () => {\n      mockPrisma.chatMessage.deleteMany.mockResolvedValue({ count: 5 });\n      mockPrisma.chatConversation.delete.mockResolvedValue({\n        id: \'conv-123\',\n      });\n\n      await service.deleteConversation(\'conv-123\');\n\n      expect(mockPrisma.chatMessage.deleteMany).toHaveBeenCalledWith({\n        where: { conversationId: \'conv-123\' },\n      });\n      expect(mockPrisma.chatConversation.delete).toHaveBeenCalledWith({\n        where: { id: \'conv-123\' },\n      });\n    });\n  });\n\n  describe(\'error handling\', () => {\n    it(\'should handle API errors gracefully\', async () => {\n      const { createChatCompletion } = require(\'@/lib/utils/openai\');\n      createChatCompletion.mockRejectedValueOnce(new Error(\'API Error\'));\n\n      mockPrisma.chatConversation.create.mockResolvedValue({\n        id: \'conv-123\',\n        userId: \'user-123\',\n      });\n      mockPrisma.chatMessage.findMany.mockResolvedValue([]);\n\n      const request: ChatRequest = {\n        userId: \'user-123\',\n        message: \'Test message\',\n      };\n\n      await expect(service.chat(request)).rejects.toThrow();\n    });\n  });\n});\n</create-file>\n</function_calls>'}