{'role': 'assistant', 'content': 'Now let\'s create a Provider Discovery Service that helps users find and connect to their healthcare providers:\n\n<function_calls>\n<create-file file_path="medical-analysis-platform/lib/services/ProviderDiscoveryService.ts">\n/**\n * Provider Discovery Service\n * \n * Helps users discover and connect to their healthcare providers\n */\n\nimport { PrismaClient } from \'@prisma/client\';\nimport {\n  EHRProvider,\n  ProviderConfig,\n  getProviderConfig,\n  getAllProviders,\n  getProvidersByMarketShare,\n  searchProviders,\n} from \'../config/ehr-providers\';\n\nconst prisma = new PrismaClient();\n\nexport interface ProviderSearchResult {\n  provider: ProviderConfig;\n  organizations: ProviderOrganization[];\n}\n\nexport interface ProviderOrganization {\n  id: string;\n  name: string;\n  location?: string;\n  fhirBaseUrl: string;\n  authorizationUrl: string;\n  tokenUrl: string;\n}\n\nexport class ProviderDiscoveryService {\n  /**\n   * Get all supported providers\n   */\n  static async getSupportedProviders(): Promise<ProviderConfig[]> {\n    return getAllProviders();\n  }\n\n  /**\n   * Get providers sorted by market share\n   */\n  static async getPopularProviders(): Promise<ProviderConfig[]> {\n    return getProvidersByMarketShare();\n  }\n\n  /**\n   * Search for providers by name\n   */\n  static async searchProvidersByName(query: string): Promise<ProviderConfig[]> {\n    return searchProviders(query);\n  }\n\n  /**\n   * Get provider configuration\n   */\n  static async getProvider(providerId: EHRProvider): Promise<ProviderConfig> {\n    return getProviderConfig(providerId);\n  }\n\n  /**\n   * Get provider by name (case-insensitive)\n   */\n  static async getProviderByName(name: string): Promise<ProviderConfig | null> {\n    const providers = getAllProviders();\n    const lowerName = name.toLowerCase();\n    \n    return providers.find(p =>\n      p.name.toLowerCase() === lowerName ||\n      p.displayName.toLowerCase() === lowerName\n    ) || null;\n  }\n\n  /**\n   * Seed provider configurations to database\n   */\n  static async seedProviderConfigurations(): Promise<void> {\n    const providers = getAllProviders();\n\n    for (const provider of providers) {\n      const existing = await prisma.providerConfiguration.findFirst({\n        where: {\n          provider: provider.id as any,\n          providerName: provider.displayName,\n        },\n      });\n\n      if (!existing) {\n        await prisma.providerConfiguration.create({\n          data: {\n            provider: provider.id as any,\n            providerName: provider.displayName,\n            fhirBaseUrl: provider.production.fhirBaseUrl,\n            authorizationUrl: provider.production.authorizationUrl,\n            tokenUrl: provider.production.tokenUrl,\n            scopes: provider.defaultScopes.join(\' \'),\n            supportsDocumentReference: provider.capabilities.supportsDocumentReference,\n            supportsObservation: provider.capabilities.supportsObservation,\n            supportsCondition: provider.capabilities.supportsCondition,\n            supportsMedication: provider.capabilities.supportsMedication,\n            supportsAllergy: provider.capabilities.supportsAllergy,\n            supportsImmunization: provider.capabilities.supportsImmunization,\n            supportsProcedure: provider.capabilities.supportsProcedure,\n            rateLimit: provider.rateLimit?.requestsPerMinute,\n            enabled: true,\n            isSandbox: false,\n            metadata: JSON.stringify({\n              description: provider.description,\n              color: provider.color,\n              patientPortalName: provider.patientPortalName,\n              marketShare: provider.marketShare,\n              setupInstructions: provider.setupInstructions,\n              documentationUrl: provider.production.documentationUrl,\n              registrationUrl: provider.production.registrationUrl,\n              requiresClientSecret: provider.requiresClientSecret,\n            }),\n          },\n        });\n      }\n\n      // Also seed sandbox configuration if available\n      if (provider.sandbox) {\n        const existingSandbox = await prisma.providerConfiguration.findFirst({\n          where: {\n            provider: provider.id as any,\n            providerName: `${provider.displayName} (Sandbox)`,\n          },\n        });\n\n        if (!existingSandbox) {\n          await prisma.providerConfiguration.create({\n            data: {\n              provider: provider.id as any,\n              providerName: `${provider.displayName} (Sandbox)`,\n              fhirBaseUrl: provider.sandbox.fhirBaseUrl,\n              authorizationUrl: provider.sandbox.authorizationUrl,\n              tokenUrl: provider.sandbox.tokenUrl,\n              scopes: provider.defaultScopes.join(\' \'),\n              supportsDocumentReference: provider.capabilities.supportsDocumentReference,\n              supportsObservation: provider.capabilities.supportsObservation,\n              supportsCondition: provider.capabilities.supportsCondition,\n              supportsMedication: provider.capabilities.supportsMedication,\n              supportsAllergy: provider.capabilities.supportsAllergy,\n              supportsImmunization: provider.capabilities.supportsImmunization,\n              supportsProcedure: provider.capabilities.supportsProcedure,\n              rateLimit: provider.rateLimit?.requestsPerMinute,\n              enabled: true,\n              isSandbox: true,\n              metadata: JSON.stringify({\n                description: `${provider.description} (Sandbox/Testing)`,\n                color: provider.color,\n                patientPortalName: provider.patientPortalName,\n                setupInstructions: provider.setupInstructions,\n                documentationUrl: provider.sandbox.documentationUrl,\n                requiresClientSecret: provider.requiresClientSecret,\n              }),\n            },\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Get provider configurations from database\n   */\n  static async getProviderConfigurations(\n    includeDisabled: boolean = false,\n    includeSandbox: boolean = false\n  ): Promise<any[]> {\n    const where: any = {};\n    \n    if (!includeDisabled) {\n      where.enabled = true;\n    }\n    \n    if (!includeSandbox) {\n      where.isSandbox = false;\n    }\n\n    return prisma.providerConfiguration.findMany({\n      where,\n      orderBy: { providerName: \'asc\' },\n    });\n  }\n\n  /**\n   * Get provider configuration by ID\n   */\n  static async getProviderConfigurationById(id: string): Promise<any> {\n    return prisma.providerConfiguration.findUnique({\n      where: { id },\n    });\n  }\n\n  /**\n   * Update provider configuration\n   */\n  static async updateProviderConfiguration(\n    id: string,\n    data: {\n      clientId?: string;\n      clientSecret?: string;\n      redirectUri?: string;\n      enabled?: boolean;\n    }\n  ): Promise<any> {\n    return prisma.providerConfiguration.update({\n      where: { id },\n      data,\n    });\n  }\n\n  /**\n   * Get provider statistics\n   */\n  static async getProviderStatistics(): Promise<{\n    totalProviders: number;\n    enabledProviders: number;\n    totalConnections: number;\n    activeConnections: number;\n    connectionsByProvider: Array<{\n      provider: string;\n      count: number;\n    }>;\n  }> {\n    const [\n      totalProviders,\n      enabledProviders,\n      totalConnections,\n      activeConnections,\n      connectionsByProvider,\n    ] = await Promise.all([\n      prisma.providerConfiguration.count(),\n      prisma.providerConfiguration.count({ where: { enabled: true } }),\n      prisma.eHRConnection.count(),\n      prisma.eHRConnection.count({ where: { status: \'ACTIVE\' } }),\n      prisma.eHRConnection.groupBy({\n        by: [\'provider\'],\n        _count: true,\n      }),\n    ]);\n\n    return {\n      totalProviders,\n      enabledProviders,\n      totalConnections,\n      activeConnections,\n      connectionsByProvider: connectionsByProvider.map(c => ({\n        provider: c.provider,\n        count: c._count,\n      })),\n    };\n  }\n\n  /**\n   * Validate provider endpoints\n   */\n  static async validateProviderEndpoints(\n    fhirBaseUrl: string\n  ): Promise<{\n    valid: boolean;\n    message: string;\n    metadata?: any;\n  }> {\n    try {\n      // Try to fetch capability statement\n      const response = await fetch(`${fhirBaseUrl}/metadata`, {\n        headers: {\n          \'Accept\': \'application/fhir+json\',\n        },\n      });\n\n      if (!response.ok) {\n        return {\n          valid: false,\n          message: `Failed to fetch capability statement: ${response.status} ${response.statusText}`,\n        };\n      }\n\n      const capabilityStatement = await response.json();\n\n      if (capabilityStatement.resourceType !== \'CapabilityStatement\') {\n        return {\n          valid: false,\n          message: \'Invalid response: Expected CapabilityStatement\',\n        };\n      }\n\n      return {\n        valid: true,\n        message: \'Provider endpoints validated successfully\',\n        metadata: {\n          fhirVersion: capabilityStatement.fhirVersion,\n          publisher: capabilityStatement.publisher,\n          software: capabilityStatement.software,\n          implementation: capabilityStatement.implementation,\n        },\n      };\n    } catch (error: any) {\n      return {\n        valid: false,\n        message: `Validation failed: ${error.message}`,\n      };\n    }\n  }\n\n  /**\n   * Get recommended providers based on user location or preferences\n   */\n  static async getRecommendedProviders(\n    location?: string,\n    preferences?: string[]\n  ): Promise<ProviderConfig[]> {\n    // For now, return popular providers\n    // In the future, this could use location data and user preferences\n    return getProvidersByMarketShare().slice(0, 5);\n  }\n}\n</create-file>\n</function_calls>'}