{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/services/HIPAAAuditService.ts">\n/**\n * HIPAA Audit Service\n * \n * Performs automated compliance audits including random log sampling,\n * PHI access pattern analysis, and consent compliance verification.\n */\n\nimport { PrismaClient, ComplianceAudit, AuditType, AuditStatus, AuditFinding, FindingSeverity, PHIAccessLog, AccessPattern } from \'@prisma/client\';\n\nconst prisma = new PrismaClient();\n\ninterface AuditConfig {\n  auditType: AuditType;\n  startDate: Date;\n  endDate: Date;\n  scope?: any;\n  samplingRate?: number;\n  triggeredBy: string;\n}\n\ninterface PatternAnalysisResult {\n  userId: string;\n  patterns: AccessPattern;\n  anomalies: string[];\n  riskScore: number;\n  requiresReview: boolean;\n}\n\nexport class HIPAAAuditService {\n  /**\n   * Perform compliance audit\n   */\n  async performAudit(config: AuditConfig): Promise<ComplianceAudit> {\n    // Create audit record\n    const audit = await prisma.complianceAudit.create({\n      data: {\n        auditType: config.auditType,\n        startDate: config.startDate,\n        endDate: config.endDate,\n        scope: config.scope || {},\n        samplingRate: config.samplingRate,\n        triggeredBy: config.triggeredBy,\n        status: AuditStatus.IN_PROGRESS,\n        startedAt: new Date(),\n      },\n    });\n\n    try {\n      let findings: AuditFinding[] = [];\n\n      // Perform audit based on type\n      switch (config.auditType) {\n        case AuditType.RANDOM_SAMPLING:\n          findings = await this.performRandomSampling(audit.id, config);\n          break;\n        case AuditType.PHI_ACCESS:\n          findings = await this.auditPHIAccess(audit.id, config);\n          break;\n        case AuditType.CONSENT_COMPLIANCE:\n          findings = await this.auditConsentCompliance(audit.id, config);\n          break;\n        case AuditType.AUTHENTICATION:\n          findings = await this.auditAuthentication(audit.id, config);\n          break;\n        case AuditType.AUTHORIZATION:\n          findings = await this.auditAuthorization(audit.id, config);\n          break;\n        case AuditType.DATA_RETENTION:\n          findings = await this.auditDataRetention(audit.id, config);\n          break;\n        case AuditType.ENCRYPTION:\n          findings = await this.auditEncryption(audit.id, config);\n          break;\n        case AuditType.BREACH_DETECTION:\n          findings = await this.detectBreaches(audit.id, config);\n          break;\n        case AuditType.SCHEDULED:\n          findings = await this.performComprehensiveAudit(audit.id, config);\n          break;\n      }\n\n      // Calculate compliance score\n      const complianceScore = this.calculateAuditScore(findings);\n\n      // Generate summary\n      const summary = this.generateAuditSummary(findings);\n\n      // Generate recommendations\n      const recommendations = this.generateRecommendations(findings);\n\n      // Update audit record\n      const completedAudit = await prisma.complianceAudit.update({\n        where: { id: audit.id },\n        data: {\n          status: AuditStatus.COMPLETED,\n          completedAt: new Date(),\n          duration: Math.floor((Date.now() - audit.startedAt!.getTime()) / 1000),\n          findingsCount: findings.length,\n          violationsCount: findings.filter(f => f.severity === FindingSeverity.CRITICAL || f.severity === FindingSeverity.HIGH).length,\n          complianceScore,\n          summary,\n          recommendations,\n        },\n      });\n\n      return completedAudit;\n    } catch (error: any) {\n      // Mark audit as failed\n      await prisma.complianceAudit.update({\n        where: { id: audit.id },\n        data: {\n          status: AuditStatus.FAILED,\n          completedAt: new Date(),\n        },\n      });\n\n      throw new Error(`Audit failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Perform random log sampling\n   */\n  async performRandomSampling(auditId: string, config: AuditConfig): Promise<AuditFinding[]> {\n    const findings: AuditFinding[] = [];\n    const samplingRate = config.samplingRate || 0.1; // Default 10%\n\n    // Get all PHI access logs in the period\n    const allLogs = await prisma.pHIAccessLog.findMany({\n      where: {\n        accessedAt: {\n          gte: config.startDate,\n          lte: config.endDate,\n        },\n      },\n    });\n\n    // Calculate sample size\n    const sampleSize = Math.ceil(allLogs.length * samplingRate);\n\n    // Random sampling\n    const sampledLogs = this.randomSample(allLogs, sampleSize);\n\n    // Audit each sampled log\n    for (const log of sampledLogs) {\n      const logFindings = await this.auditAccessLog(auditId, log);\n      findings.push(...logFindings);\n    }\n\n    // Update audit with sample info\n    await prisma.complianceAudit.update({\n      where: { id: auditId },\n      data: {\n        totalRecords: allLogs.length,\n        recordsAudited: sampledLogs.length,\n        sampleSize: sampledLogs.length,\n      },\n    });\n\n    return findings;\n  }\n\n  /**\n   * Audit PHI access patterns\n   */\n  async auditPHIAccess(auditId: string, config: AuditConfig): Promise<AuditFinding[]> {\n    const findings: AuditFinding[] = [];\n\n    // Get all PHI access logs in the period\n    const accessLogs = await prisma.pHIAccessLog.findMany({\n      where: {\n        accessedAt: {\n          gte: config.startDate,\n          lte: config.endDate,\n        },\n      },\n    });\n\n    // Group by user\n    const userAccess = this.groupByUser(accessLogs);\n\n    // Analyze patterns for each user\n    for (const [userId, logs] of Object.entries(userAccess)) {\n      const patternAnalysis = await this.analyzeAccessPattern(userId, logs as PHIAccessLog[]);\n\n      if (patternAnalysis.requiresReview) {\n        const finding = await prisma.auditFinding.create({\n          data: {\n            auditId,\n            findingType: \'SUSPICIOUS_ACCESS_PATTERN\',\n            severity: this.mapRiskScoreToSeverity(patternAnalysis.riskScore),\n            title: `Suspicious Access Pattern: ${userId}`,\n            description: `User ${userId} exhibits suspicious access patterns: ${patternAnalysis.anomalies.join(\', \')}`,\n            evidence: {\n              userId,\n              accessCount: logs.length,\n              anomalies: patternAnalysis.anomalies,\n              riskScore: patternAnalysis.riskScore,\n            },\n            relatedRules: [\'HIPAA-PR-001\', \'HIPAA-SR-001\'],\n            impact: `Potential unauthorized PHI access affecting ${new Set((logs as PHIAccessLog[]).map(l => l.patientId)).size} patients`,\n            affectedRecords: logs.length,\n            affectedUsers: new Set((logs as PHIAccessLog[]).map(l => l.patientId)).size,\n            recommendation: \'Review access logs and interview user to verify legitimate business need\',\n            requiredAction: \'Immediate review required for high-risk access patterns\',\n            priority: patternAnalysis.riskScore > 75 ? 1 : 2,\n          },\n        });\n\n        findings.push(finding);\n      }\n    }\n\n    return findings;\n  }\n\n  /**\n   * Audit consent compliance\n   */\n  async auditConsentCompliance(auditId: string, config: AuditConfig): Promise<AuditFinding[]> {\n    const findings: AuditFinding[] = [];\n\n    // Get all PHI access logs in the period\n    const accessLogs = await prisma.pHIAccessLog.findMany({\n      where: {\n        accessedAt: {\n          gte: config.startDate,\n          lte: config.endDate,\n        },\n      },\n    });\n\n    // Check each access for valid consent\n    for (const log of accessLogs) {\n      const consentCheck = await this.verifyConsent(log);\n\n      if (!consentCheck.valid) {\n        const finding = await prisma.auditFinding.create({\n          data: {\n            auditId,\n            findingType: \'CONSENT_VIOLATION\',\n            severity: FindingSeverity.HIGH,\n            title: `Access Without Valid Consent`,\n            description: `User ${log.userId} accessed patient ${log.patientId} without valid consent`,\n            evidence: {\n              accessLogId: log.id,\n              userId: log.userId,\n              patientId: log.patientId,\n              accessedAt: log.accessedAt,\n              consentStatus: consentCheck.reason,\n            },\n            relatedRules: [\'HIPAA-PR-001\'],\n            impact: \'Unauthorized PHI access - potential HIPAA violation\',\n            affectedRecords: 1,\n            affectedUsers: 1,\n            recommendation: \'Obtain valid consent or revoke access\',\n            requiredAction: \'Immediate action required - potential breach\',\n            priority: 1,\n          },\n        });\n\n        findings.push(finding);\n      }\n    }\n\n    return findings;\n  }\n\n  /**\n   * Audit authentication\n   */\n  async auditAuthentication(auditId: string, config: AuditConfig): Promise<AuditFinding[]> {\n    const findings: AuditFinding[] = [];\n\n    // Check for weak authentication\n    // TODO: Implement authentication audit\n    // - Check for MFA usage\n    // - Check for password strength\n    // - Check for session management\n    // - Check for failed login attempts\n\n    return findings;\n  }\n\n  /**\n   * Audit authorization\n   */\n  async auditAuthorization(auditId: string, config: AuditConfig): Promise<AuditFinding[]> {\n    const findings: AuditFinding[] = [];\n\n    // Check for proper authorization\n    // TODO: Implement authorization audit\n    // - Check role-based access control\n    // - Check minimum necessary\n    // - Check access justification\n\n    return findings;\n  }\n\n  /**\n   * Audit data retention\n   */\n  async auditDataRetention(auditId: string, config: AuditConfig): Promise<AuditFinding[]> {\n    const findings: AuditFinding[] = [];\n\n    // Check data retention policies\n    // TODO: Implement retention audit\n    // - Check for data past retention period\n    // - Check for proper disposal\n    // - Check for retention documentation\n\n    return findings;\n  }\n\n  /**\n   * Audit encryption\n   */\n  async auditEncryption(auditId: string, config: AuditConfig): Promise<AuditFinding[]> {\n    const findings: AuditFinding[] = [];\n\n    // Check encryption compliance\n    // TODO: Implement encryption audit\n    // - Check PHI encrypted at rest\n    // - Check PHI encrypted in transit\n    // - Check key management\n\n    return findings;\n  }\n\n  /**\n   * Detect potential breaches\n   */\n  async detectBreaches(auditId: string, config: AuditConfig): Promise<AuditFinding[]> {\n    const findings: AuditFinding[] = [];\n\n    // Detect potential breaches\n    // TODO: Implement breach detection\n    // - Check for unauthorized access\n    // - Check for data exfiltration\n    // - Check for suspicious patterns\n\n    return findings;\n  }\n\n  /**\n   * Perform comprehensive audit\n   */\n  async performComprehensiveAudit(auditId: string, config: AuditConfig): Promise<AuditFinding[]> {\n    const findings: AuditFinding[] = [];\n\n    // Run all audit types\n    const auditTypes = [\n      AuditType.PHI_ACCESS,\n      AuditType.CONSENT_COMPLIANCE,\n      AuditType.AUTHENTICATION,\n      AuditType.AUTHORIZATION,\n      AuditType.ENCRYPTION,\n    ];\n\n    for (const type of auditTypes) {\n      const typeFindings = await this.performAudit({\n        ...config,\n        auditType: type,\n      });\n\n      if (typeFindings.findings) {\n        findings.push(...typeFindings.findings);\n      }\n    }\n\n    return findings;\n  }\n\n  /**\n   * Analyze access pattern for a user\n   */\n  async analyzeAccessPattern(userId: string, logs: PHIAccessLog[]): Promise<PatternAnalysisResult> {\n    const anomalies: string[] = [];\n    let riskScore = 0;\n\n    // Calculate metrics\n    const accessCount = logs.length;\n    const uniquePatients = new Set(logs.map(l => l.patientId)).size;\n    const accessTimes = logs.map(l => l.accessedAt.getHours());\n    const averageAccessTime = accessTimes.reduce((a, b) => a + b, 0) / accessTimes.length;\n\n    // Check for unusual time access (2-5 AM)\n    const nightAccess = logs.filter(l => {\n      const hour = l.accessedAt.getHours();\n      return hour >= 2 && hour <= 5;\n    });\n\n    if (nightAccess.length > 0) {\n      anomalies.push(\'unusual_time\');\n      riskScore += 20;\n    }\n\n    // Check for unusual volume (>100 accesses per day)\n    const daysDiff = (logs[logs.length - 1].accessedAt.getTime() - logs[0].accessedAt.getTime()) / (1000 * 60 * 60 * 24);\n    const accessesPerDay = accessCount / Math.max(daysDiff, 1);\n\n    if (accessesPerDay > 100) {\n      anomalies.push(\'unusual_volume\');\n      riskScore += 30;\n    }\n\n    // Check for accessing many unrelated patients\n    if (uniquePatients > 50 && accessCount / uniquePatients < 2) {\n      anomalies.push(\'unusual_resources\');\n      riskScore += 25;\n    }\n\n    // Check for rapid sequential access\n    const rapidAccess = logs.filter((log, index) => {\n      if (index === 0) return false;\n      const timeDiff = log.accessedAt.getTime() - logs[index - 1].accessedAt.getTime();\n      return timeDiff < 1000; // Less than 1 second between accesses\n    });\n\n    if (rapidAccess.length > 10) {\n      anomalies.push(\'rapid_sequential_access\');\n      riskScore += 15;\n    }\n\n    // Check for geographic anomalies\n    const locations = new Set(logs.map(l => l.location).filter(l => l));\n    if (locations.size > 3) {\n      anomalies.push(\'geographic_anomaly\');\n      riskScore += 10;\n    }\n\n    // Create or update access pattern\n    const pattern = await prisma.accessPattern.upsert({\n      where: {\n        userId_analyzedAt: {\n          userId,\n          analyzedAt: new Date(),\n        },\n      },\n      create: {\n        userId,\n        userName: logs[0].userName,\n        patternType: riskScore > 50 ? \'ANOMALOUS\' : riskScore > 25 ? \'SUSPICIOUS\' : \'NORMAL\',\n        timeWindow: `${logs[0].accessedAt.toISOString()} - ${logs[logs.length - 1].accessedAt.toISOString()}`,\n        accessCount,\n        uniquePatients,\n        averageAccessTime,\n        accessFrequency: accessesPerDay,\n        anomalies: { anomalies },\n        riskScore,\n        unusualTime: anomalies.includes(\'unusual_time\'),\n        unusualVolume: anomalies.includes(\'unusual_volume\'),\n        unusualResources: anomalies.includes(\'unusual_resources\'),\n        geographicAnomaly: anomalies.includes(\'geographic_anomaly\'),\n        requiresReview: riskScore > 50,\n        periodStart: logs[0].accessedAt,\n        periodEnd: logs[logs.length - 1].accessedAt,\n      },\n      update: {\n        patternType: riskScore > 50 ? \'ANOMALOUS\' : riskScore > 25 ? \'SUSPICIOUS\' : \'NORMAL\',\n        accessCount,\n        uniquePatients,\n        averageAccessTime,\n        accessFrequency: accessesPerDay,\n        anomalies: { anomalies },\n        riskScore,\n        unusualTime: anomalies.includes(\'unusual_time\'),\n        unusualVolume: anomalies.includes(\'unusual_volume\'),\n        unusualResources: anomalies.includes(\'unusual_resources\'),\n        geographicAnomaly: anomalies.includes(\'geographic_anomaly\'),\n        requiresReview: riskScore > 50,\n      },\n    });\n\n    return {\n      userId,\n      patterns: pattern,\n      anomalies,\n      riskScore,\n      requiresReview: riskScore > 50,\n    };\n  }\n\n  /**\n   * Schedule automated audits\n   */\n  async scheduleAutomatedAudits(): Promise<void> {\n    const now = new Date();\n\n    // Daily random sampling\n    await this.performAudit({\n      auditType: AuditType.RANDOM_SAMPLING,\n      startDate: new Date(now.getTime() - 24 * 60 * 60 * 1000),\n      endDate: now,\n      samplingRate: 0.1,\n      triggeredBy: \'SYSTEM\',\n    });\n\n    // Weekly PHI access audit\n    if (now.getDay() === 1) { // Monday\n      await this.performAudit({\n        auditType: AuditType.PHI_ACCESS,\n        startDate: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000),\n        endDate: now,\n        triggeredBy: \'SYSTEM\',\n      });\n    }\n\n    // Monthly comprehensive audit\n    if (now.getDate() === 1) { // First of month\n      await this.performAudit({\n        auditType: AuditType.SCHEDULED,\n        startDate: new Date(now.getFullYear(), now.getMonth() - 1, 1),\n        endDate: new Date(now.getFullYear(), now.getMonth(), 0),\n        triggeredBy: \'SYSTEM\',\n      });\n    }\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  private randomSample<T>(array: T[], size: number): T[] {\n    const shuffled = [...array].sort(() => 0.5 - Math.random());\n    return shuffled.slice(0, size);\n  }\n\n  private groupByUser(logs: PHIAccessLog[]): { [userId: string]: PHIAccessLog[] } {\n    return logs.reduce((acc, log) => {\n      if (!acc[log.userId]) {\n        acc[log.userId] = [];\n      }\n      acc[log.userId].push(log);\n      return acc;\n    }, {} as { [userId: string]: PHIAccessLog[] });\n  }\n\n  private async auditAccessLog(auditId: string, log: PHIAccessLog): Promise<AuditFinding[]> {\n    const findings: AuditFinding[] = [];\n\n    // Check if access was authorized\n    if (!log.authorized) {\n      const finding = await prisma.auditFinding.create({\n        data: {\n          auditId,\n          findingType: \'UNAUTHORIZED_ACCESS\',\n          severity: FindingSeverity.CRITICAL,\n          title: \'Unauthorized PHI Access\',\n          description: `Unauthorized access to patient ${log.patientId} by user ${log.userId}`,\n          evidence: { accessLogId: log.id },\n          relatedRules: [\'HIPAA-PR-001\', \'HIPAA-SR-001\'],\n          impact: \'Potential HIPAA violation - unauthorized PHI access\',\n          affectedRecords: 1,\n          recommendation: \'Investigate and take corrective action\',\n          priority: 1,\n        },\n      });\n      findings.push(finding);\n    }\n\n    // Check if minimum necessary was applied\n    if (!log.minimumNecessary) {\n      const finding = await prisma.auditFinding.create({\n        data: {\n          auditId,\n          findingType: \'MINIMUM_NECESSARY_VIOLATION\',\n          severity: FindingSeverity.MEDIUM,\n          title: \'Minimum Necessary Not Applied\',\n          description: `Access to patient ${log.patientId} did not apply minimum necessary standard`,\n          evidence: { accessLogId: log.id },\n          relatedRules: [\'HIPAA-PR-001\'],\n          impact: \'Excessive PHI access\',\n          affectedRecords: 1,\n          recommendation: \'Implement minimum necessary controls\',\n          priority: 2,\n        },\n      });\n      findings.push(finding);\n    }\n\n    return findings;\n  }\n\n  private async verifyConsent(log: PHIAccessLog): Promise<{ valid: boolean; reason?: string }> {\n    // TODO: Implement actual consent verification\n    // This would check if valid consent exists for the access\n    if (!log.consentId) {\n      return { valid: false, reason: \'No consent ID provided\' };\n    }\n\n    return { valid: true };\n  }\n\n  private calculateAuditScore(findings: AuditFinding[]): number {\n    if (findings.length === 0) return 100;\n\n    const criticalCount = findings.filter(f => f.severity === FindingSeverity.CRITICAL).length;\n    const highCount = findings.filter(f => f.severity === FindingSeverity.HIGH).length;\n    const mediumCount = findings.filter(f => f.severity === FindingSeverity.MEDIUM).length;\n    const lowCount = findings.filter(f => f.severity === FindingSeverity.LOW).length;\n\n    const penalty = (criticalCount * 25) + (highCount * 15) + (mediumCount * 8) + (lowCount * 3);\n\n    return Math.max(0, 100 - penalty);\n  }\n\n  private generateAuditSummary(findings: AuditFinding[]): string {\n    const criticalCount = findings.filter(f => f.severity === FindingSeverity.CRITICAL).length;\n    const highCount = findings.filter(f => f.severity === FindingSeverity.HIGH).length;\n\n    if (criticalCount > 0) {\n      return `CRITICAL: ${criticalCount} critical findings require immediate attention. ${highCount} high-severity findings also identified.`;\n    } else if (highCount > 0) {\n      return `${highCount} high-severity findings identified requiring prompt action.`;\n    } else if (findings.length > 0) {\n      return `${findings.length} findings identified. Review and address as appropriate.`;\n    } else {\n      return \'No compliance issues identified. System is operating within HIPAA guidelines.\';\n    }\n  }\n\n  private generateRecommendations(findings: AuditFinding[]): string[] {\n    const recommendations = new Set<string>();\n\n    for (const finding of findings) {\n      recommendations.add(finding.recommendation);\n    }\n\n    return Array.from(recommendations);\n  }\n\n  private mapRiskScoreToSeverity(riskScore: number): FindingSeverity {\n    if (riskScore >= 75) return FindingSeverity.CRITICAL;\n    if (riskScore >= 50) return FindingSeverity.HIGH;\n    if (riskScore >= 25) return FindingSeverity.MEDIUM;\n    return FindingSeverity.LOW;\n  }\n}\n\nexport default HIPAAAuditService;\n</create-file>\n</function_calls>'}