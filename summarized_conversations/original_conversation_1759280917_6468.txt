{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/errors/errorHandler.ts">\n/**\n * Global Error Handler\n * Handles errors in API routes and returns appropriate responses\n */\n\nimport { NextRequest, NextResponse } from \'next/server\';\nimport { AppError, getUserFriendlyMessage } from \'./AppError\';\nimport { errorLogger } from \'./ErrorLogger\';\nimport { Prisma } from \'@prisma/client\';\n\n// ============================================================================\n// ERROR RESPONSE INTERFACE\n// ============================================================================\n\ninterface ErrorResponse {\n  error: {\n    message: string;\n    code?: string;\n    statusCode: number;\n    details?: any;\n    timestamp: string;\n    requestId?: string;\n  };\n}\n\n// ============================================================================\n// GLOBAL ERROR HANDLER\n// ============================================================================\n\nexport async function handleError(\n  error: Error,\n  req?: NextRequest,\n  context?: {\n    userId?: string;\n    requestId?: string;\n  }\n): Promise<NextResponse<ErrorResponse>> {\n  // Extract request context\n  const endpoint = req?.nextUrl.pathname;\n  const method = req?.method;\n  const userAgent = req?.headers.get(\'user-agent\') || undefined;\n  const ipAddress = req?.ip || req?.headers.get(\'x-forwarded-for\') || undefined;\n\n  // Log the error\n  await errorLogger.logError(error, {\n    userId: context?.userId,\n    requestId: context?.requestId,\n    endpoint,\n    method,\n    userAgent,\n    ipAddress,\n  });\n\n  // Handle different error types\n  if (error instanceof AppError) {\n    return handleAppError(error, context?.requestId);\n  }\n\n  if (error instanceof Prisma.PrismaClientKnownRequestError) {\n    return handlePrismaError(error, context?.requestId);\n  }\n\n  if (error instanceof Prisma.PrismaClientValidationError) {\n    return handlePrismaValidationError(error, context?.requestId);\n  }\n\n  // Handle unknown errors\n  return handleUnknownError(error, context?.requestId);\n}\n\n// ============================================================================\n// SPECIFIC ERROR HANDLERS\n// ============================================================================\n\n/**\n * Handle AppError instances\n */\nfunction handleAppError(\n  error: AppError,\n  requestId?: string\n): NextResponse<ErrorResponse> {\n  const response: ErrorResponse = {\n    error: {\n      message: error.message,\n      code: error.code,\n      statusCode: error.statusCode,\n      details: error.details,\n      timestamp: error.timestamp.toISOString(),\n      requestId,\n    },\n  };\n\n  return NextResponse.json(response, { status: error.statusCode });\n}\n\n/**\n * Handle Prisma database errors\n */\nfunction handlePrismaError(\n  error: Prisma.PrismaClientKnownRequestError,\n  requestId?: string\n): NextResponse<ErrorResponse> {\n  let message = \'Database operation failed\';\n  let statusCode = 500;\n  let code = \'DATABASE_ERROR\';\n\n  switch (error.code) {\n    case \'P2002\':\n      // Unique constraint violation\n      message = \'A record with this value already exists\';\n      statusCode = 409;\n      code = \'DUPLICATE_RECORD\';\n      break;\n\n    case \'P2025\':\n      // Record not found\n      message = \'Record not found\';\n      statusCode = 404;\n      code = \'NOT_FOUND\';\n      break;\n\n    case \'P2003\':\n      // Foreign key constraint violation\n      message = \'Related record not found\';\n      statusCode = 400;\n      code = \'FOREIGN_KEY_VIOLATION\';\n      break;\n\n    case \'P2014\':\n      // Required relation violation\n      message = \'Required relation missing\';\n      statusCode = 400;\n      code = \'RELATION_VIOLATION\';\n      break;\n\n    case \'P2021\':\n      // Table does not exist\n      message = \'Database table not found\';\n      statusCode = 500;\n      code = \'TABLE_NOT_FOUND\';\n      break;\n\n    case \'P2024\':\n      // Connection timeout\n      message = \'Database connection timeout\';\n      statusCode = 503;\n      code = \'DB_TIMEOUT\';\n      break;\n  }\n\n  const response: ErrorResponse = {\n    error: {\n      message,\n      code,\n      statusCode,\n      details: {\n        prismaCode: error.code,\n        meta: error.meta,\n      },\n      timestamp: new Date().toISOString(),\n      requestId,\n    },\n  };\n\n  return NextResponse.json(response, { status: statusCode });\n}\n\n/**\n * Handle Prisma validation errors\n */\nfunction handlePrismaValidationError(\n  error: Prisma.PrismaClientValidationError,\n  requestId?: string\n): NextResponse<ErrorResponse> {\n  const response: ErrorResponse = {\n    error: {\n      message: \'Invalid data provided\',\n      code: \'VALIDATION_ERROR\',\n      statusCode: 400,\n      details: {\n        validationError: error.message,\n      },\n      timestamp: new Date().toISOString(),\n      requestId,\n    },\n  };\n\n  return NextResponse.json(response, { status: 400 });\n}\n\n/**\n * Handle unknown errors\n */\nfunction handleUnknownError(\n  error: Error,\n  requestId?: string\n): NextResponse<ErrorResponse> {\n  // Don\'t expose internal error details in production\n  const isDevelopment = process.env.NODE_ENV === \'development\';\n\n  const response: ErrorResponse = {\n    error: {\n      message: isDevelopment\n        ? error.message\n        : \'An unexpected error occurred. Please try again later.\',\n      code: \'INTERNAL_ERROR\',\n      statusCode: 500,\n      details: isDevelopment\n        ? {\n            name: error.name,\n            stack: error.stack,\n          }\n        : undefined,\n      timestamp: new Date().toISOString(),\n      requestId,\n    },\n  };\n\n  return NextResponse.json(response, { status: 500 });\n}\n\n// ============================================================================\n// ERROR HANDLER WRAPPER FOR API ROUTES\n// ============================================================================\n\n/**\n * Wraps an API route handler with error handling\n */\nexport function withErrorHandler<T = any>(\n  handler: (req: NextRequest, context?: any) => Promise<NextResponse<T>>\n) {\n  return async (req: NextRequest, context?: any): Promise<NextResponse> => {\n    try {\n      return await handler(req, context);\n    } catch (error) {\n      // Generate request ID\n      const requestId = req.headers.get(\'x-request-id\') || generateRequestId();\n\n      // Extract user ID from request headers (set by auth middleware)\n      const userId = req.headers.get(\'x-user-id\') || undefined;\n\n      return handleError(error as Error, req, { userId, requestId });\n    }\n  };\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Generate unique request ID\n */\nfunction generateRequestId(): string {\n  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Create error response for client\n */\nexport function createErrorResponse(\n  message: string,\n  statusCode: number = 500,\n  code?: string,\n  details?: any\n): NextResponse<ErrorResponse> {\n  const response: ErrorResponse = {\n    error: {\n      message,\n      code,\n      statusCode,\n      details,\n      timestamp: new Date().toISOString(),\n    },\n  };\n\n  return NextResponse.json(response, { status: statusCode });\n}\n\n/**\n * Check if error should be retried\n */\nexport function isRetryableError(error: Error): boolean {\n  if (error instanceof AppError) {\n    // Retry on service unavailable, timeout, rate limit\n    return (\n      error.statusCode === 503 ||\n      error.statusCode === 504 ||\n      error.statusCode === 429 ||\n      error.code === \'DB_TIMEOUT\' ||\n      error.code === \'EXTERNAL_SERVICE_ERROR\'\n    );\n  }\n\n  return false;\n}\n\n/**\n * Get retry delay based on attempt number\n */\nexport function getRetryDelay(attempt: number): number {\n  // Exponential backoff: 1s, 2s, 4s, 8s, 16s\n  return Math.min(1000 * Math.pow(2, attempt), 16000);\n}\n</create-file>\n</function_calls>'}