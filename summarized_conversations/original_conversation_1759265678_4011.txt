{'role': 'assistant', 'content': 'Now let\'s create the query classifier utility:\n\n<function_calls>\n<create-file file_path="medical-analysis-platform/lib/utils/queryClassifier.ts">\n/**\n * Query Classifier Utility\n * \n * Classifies user queries by complexity and determines if escalation\n * to heavy-duty analysis is needed.\n */\n\nimport {\n  QueryComplexity,\n  EscalationReason,\n  EscalationTrigger,\n  COMPLEXITY_INDICATORS,\n  ESCALATION_TRIGGERS\n} from \'@/lib/types/chatbot\';\n\n/**\n * Classify query complexity\n */\nexport function classifyQueryComplexity(query: string): QueryComplexity {\n  const lowerQuery = query.toLowerCase();\n\n  // Check for critical indicators first\n  const hasCritical = COMPLEXITY_INDICATORS.critical.some(indicator =>\n    lowerQuery.includes(indicator)\n  );\n  if (hasCritical) {\n    return QueryComplexity.CRITICAL;\n  }\n\n  // Check for complex indicators\n  const complexCount = COMPLEXITY_INDICATORS.complex.filter(indicator =>\n    lowerQuery.includes(indicator)\n  ).length;\n  if (complexCount >= 2) {\n    return QueryComplexity.COMPLEX;\n  }\n\n  // Check for moderate indicators\n  const moderateCount = COMPLEXITY_INDICATORS.moderate.filter(indicator =>\n    lowerQuery.includes(indicator)\n  ).length;\n  if (moderateCount >= 2) {\n    return QueryComplexity.MODERATE;\n  }\n\n  // Check for simple indicators\n  const simpleCount = COMPLEXITY_INDICATORS.simple.filter(indicator =>\n    lowerQuery.includes(indicator)\n  ).length;\n  if (simpleCount >= 1) {\n    return QueryComplexity.SIMPLE;\n  }\n\n  // Default to moderate if no clear indicators\n  return QueryComplexity.MODERATE;\n}\n\n/**\n * Calculate complexity score (0-1)\n */\nexport function calculateComplexityScore(query: string): number {\n  const lowerQuery = query.toLowerCase();\n  let score = 0;\n\n  // Base score on query length\n  const wordCount = query.split(/\\s+/).length;\n  if (wordCount > 50) score += 0.3;\n  else if (wordCount > 20) score += 0.2;\n  else if (wordCount > 10) score += 0.1;\n\n  // Check for medical terms (simplified - in production, use medical dictionary)\n  const medicalTerms = [\n    \'diagnosis\', \'prognosis\', \'treatment\', \'medication\', \'symptom\',\n    \'disease\', \'condition\', \'syndrome\', \'disorder\', \'infection\',\n    \'inflammation\', \'chronic\', \'acute\', \'malignant\', \'benign\'\n  ];\n  const medicalTermCount = medicalTerms.filter(term =>\n    lowerQuery.includes(term)\n  ).length;\n  score += Math.min(medicalTermCount * 0.1, 0.4);\n\n  // Check for analysis keywords\n  const analysisKeywords = [\n    \'analyze\', \'compare\', \'correlate\', \'predict\', \'trend\',\n    \'pattern\', \'relationship\', \'cause\', \'effect\', \'risk\'\n  ];\n  const analysisCount = analysisKeywords.filter(keyword =>\n    lowerQuery.includes(keyword)\n  ).length;\n  score += Math.min(analysisCount * 0.15, 0.3);\n\n  // Check for temporal indicators\n  const temporalIndicators = [\n    \'over time\', \'history\', \'trend\', \'change\', \'progression\',\n    \'improvement\', \'deterioration\', \'since\', \'before\', \'after\'\n  ];\n  const hasTemporalAnalysis = temporalIndicators.some(indicator =>\n    lowerQuery.includes(indicator)\n  );\n  if (hasTemporalAnalysis) score += 0.2;\n\n  return Math.min(score, 1);\n}\n\n/**\n * Determine if query should be escalated\n */\nexport function shouldEscalate(\n  query: string,\n  context?: {\n    documentCount?: number;\n    hasTemporalData?: boolean;\n    userRequestedDetailed?: boolean;\n    previousEscalations?: number;\n  }\n): EscalationTrigger {\n  const complexity = classifyQueryComplexity(query);\n  const complexityScore = calculateComplexityScore(query);\n\n  // Critical queries always escalate\n  if (complexity === QueryComplexity.CRITICAL) {\n    return {\n      shouldEscalate: true,\n      reason: EscalationReason.COMPLEXITY,\n      confidence: 1.0,\n      complexity,\n      metadata: { criticalIndicators: true }\n    };\n  }\n\n  // Check document count\n  if (context?.documentCount && context.documentCount >= ESCALATION_TRIGGERS.multipleDocuments) {\n    return {\n      shouldEscalate: true,\n      reason: EscalationReason.MULTIPLE_DOCUMENTS,\n      confidence: 0.9,\n      complexity,\n      metadata: { documentCount: context.documentCount }\n    };\n  }\n\n  // Check for temporal analysis\n  if (context?.hasTemporalData && ESCALATION_TRIGGERS.temporalAnalysis) {\n    return {\n      shouldEscalate: true,\n      reason: EscalationReason.TREND_ANALYSIS,\n      confidence: 0.85,\n      complexity,\n      metadata: { temporalAnalysis: true }\n    };\n  }\n\n  // Check user request\n  if (context?.userRequestedDetailed) {\n    return {\n      shouldEscalate: true,\n      reason: EscalationReason.USER_REQUEST,\n      confidence: 1.0,\n      complexity,\n      metadata: { userRequested: true }\n    };\n  }\n\n  // Check complexity threshold\n  if (complexityScore >= ESCALATION_TRIGGERS.complexityThreshold) {\n    return {\n      shouldEscalate: true,\n      reason: EscalationReason.COMPLEXITY,\n      confidence: complexityScore,\n      complexity,\n      metadata: { complexityScore }\n    };\n  }\n\n  // Check for medical analysis keywords\n  const medicalAnalysisKeywords = [\n    \'diagnose\', \'diagnosis\', \'what could\', \'might be\', \'could indicate\',\n    \'risk of\', \'probability\', \'likelihood\', \'prognosis\'\n  ];\n  const hasMedicalAnalysis = medicalAnalysisKeywords.some(keyword =>\n    query.toLowerCase().includes(keyword)\n  );\n  if (hasMedicalAnalysis) {\n    return {\n      shouldEscalate: true,\n      reason: EscalationReason.MEDICAL_ANALYSIS,\n      confidence: 0.8,\n      complexity,\n      metadata: { medicalAnalysisDetected: true }\n    };\n  }\n\n  // No escalation needed\n  return {\n    shouldEscalate: false,\n    confidence: 1 - complexityScore,\n    complexity,\n    metadata: { complexityScore }\n  };\n}\n\n/**\n * Extract key medical terms from query\n */\nexport function extractMedicalTerms(query: string): string[] {\n  // Simplified medical term extraction\n  // In production, use a proper medical terminology database\n  const medicalTermPatterns = [\n    /\\b[A-Z][a-z]+itis\\b/g,        // Conditions ending in -itis\n    /\\b[A-Z][a-z]+osis\\b/g,        // Conditions ending in -osis\n    /\\b[A-Z][a-z]+emia\\b/g,        // Blood conditions\n    /\\b[A-Z][a-z]+pathy\\b/g,       // Disease conditions\n    /\\b\\d+\\s*mg\\b/gi,              // Medication dosages\n    /\\b\\d+\\s*ml\\b/gi,              // Volume measurements\n  ];\n\n  const terms: string[] = [];\n  for (const pattern of medicalTermPatterns) {\n    const matches = query.match(pattern);\n    if (matches) {\n      terms.push(...matches);\n    }\n  }\n\n  return [...new Set(terms)]; // Remove duplicates\n}\n\n/**\n * Detect if query requires cross-document analysis\n */\nexport function requiresCrossDocumentAnalysis(query: string): boolean {\n  const crossDocumentIndicators = [\n    \'compare\', \'difference\', \'between\', \'versus\', \'vs\',\n    \'all\', \'multiple\', \'different\', \'various\', \'across\'\n  ];\n\n  const lowerQuery = query.toLowerCase();\n  return crossDocumentIndicators.some(indicator =>\n    lowerQuery.includes(indicator)\n  );\n}\n\n/**\n * Detect if query requires temporal analysis\n */\nexport function requiresTemporalAnalysis(query: string): boolean {\n  const temporalIndicators = [\n    \'over time\', \'trend\', \'change\', \'progression\', \'history\',\n    \'since\', \'before\', \'after\', \'improvement\', \'deterioration\',\n    \'increasing\', \'decreasing\', \'stable\', \'fluctuating\'\n  ];\n\n  const lowerQuery = query.toLowerCase();\n  return temporalIndicators.some(indicator =>\n    lowerQuery.includes(indicator)\n  );\n}\n\n/**\n * Get suggested follow-up questions\n */\nexport function getSuggestedFollowUps(\n  query: string,\n  complexity: QueryComplexity\n): string[] {\n  const suggestions: string[] = [];\n\n  if (complexity === QueryComplexity.SIMPLE) {\n    suggestions.push(\n      \'Would you like more detailed information?\',\n      \'Do you have any specific questions about this?\',\n      \'Would you like to see related information?\'\n    );\n  } else if (complexity === QueryComplexity.MODERATE) {\n    suggestions.push(\n      \'Would you like a more detailed analysis?\',\n      \'Should I compare this with your previous results?\',\n      \'Would you like to see trends over time?\'\n    );\n  } else {\n    suggestions.push(\n      \'Would you like me to create a comprehensive analysis report?\',\n      \'Should I analyze all related documents?\',\n      \'Would you like to schedule a detailed review?\'\n    );\n  }\n\n  return suggestions;\n}\n\n/**\n * Estimate confidence in classification\n */\nexport function estimateClassificationConfidence(\n  query: string,\n  complexity: QueryComplexity\n): number {\n  const complexityScore = calculateComplexityScore(query);\n  const indicators = COMPLEXITY_INDICATORS[complexity.toLowerCase() as keyof typeof COMPLEXITY_INDICATORS] || [];\n  \n  const lowerQuery = query.toLowerCase();\n  const matchCount = indicators.filter(indicator =>\n    lowerQuery.includes(indicator)\n  ).length;\n\n  // Base confidence on indicator matches and complexity score alignment\n  let confidence = 0.5;\n  \n  if (matchCount > 0) {\n    confidence += Math.min(matchCount * 0.15, 0.3);\n  }\n\n  // Adjust based on complexity score alignment\n  if (complexity === QueryComplexity.SIMPLE && complexityScore < 0.3) {\n    confidence += 0.2;\n  } else if (complexity === QueryComplexity.COMPLEX && complexityScore > 0.7) {\n    confidence += 0.2;\n  }\n\n  return Math.min(confidence, 1);\n}\n</create-file>\n</function_calls>'}