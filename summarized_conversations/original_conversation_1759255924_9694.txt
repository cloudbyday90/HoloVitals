{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/services/ServiceHealthMonitor.ts">\n/**\n * Service Health Monitor\n * \n * Continuously monitors service health, detects issues, and triggers\n * automated recovery when needed.\n */\n\nimport { PrismaClient, ServiceHealth, HealthStatus } from \'@prisma/client\';\nimport IncidentManagementService from \'./IncidentManagementService\';\nimport AIErrorDiagnosisService from \'./AIErrorDiagnosisService\';\n\nconst prisma = new PrismaClient();\n\ninterface HealthCheckResult {\n  serviceName: string;\n  status: HealthStatus;\n  metrics: {\n    uptime?: number;\n    responseTime?: number;\n    errorRate?: number;\n    requestRate?: number;\n  };\n  resources: {\n    cpuUsage?: number;\n    memoryUsage?: number;\n    diskUsage?: number;\n    networkUsage?: number;\n  };\n  checks: {\n    name: string;\n    passed: boolean;\n    message: string;\n  }[];\n  issues: string[];\n}\n\ninterface AlertThresholds {\n  responseTime: number;      // ms\n  errorRate: number;          // percentage\n  cpuUsage: number;           // percentage\n  memoryUsage: number;        // percentage\n  diskUsage: number;          // percentage\n}\n\nconst DEFAULT_THRESHOLDS: AlertThresholds = {\n  responseTime: 1000,         // 1 second\n  errorRate: 1,               // 1%\n  cpuUsage: 80,               // 80%\n  memoryUsage: 85,            // 85%\n  diskUsage: 90,              // 90%\n};\n\nexport class ServiceHealthMonitor {\n  private incidentService: IncidentManagementService;\n  private diagnosisService: AIErrorDiagnosisService;\n  private monitoringInterval: NodeJS.Timeout | null = null;\n\n  constructor() {\n    this.incidentService = new IncidentManagementService();\n    this.diagnosisService = new AIErrorDiagnosisService();\n  }\n\n  /**\n   * Start continuous monitoring\n   */\n  startMonitoring(intervalSeconds: number = 30): void {\n    if (this.monitoringInterval) {\n      console.log(\'Monitoring already running\');\n      return;\n    }\n\n    console.log(`Starting health monitoring (interval: ${intervalSeconds}s)`);\n\n    this.monitoringInterval = setInterval(async () => {\n      await this.performHealthChecks();\n    }, intervalSeconds * 1000);\n\n    // Perform initial check\n    this.performHealthChecks();\n  }\n\n  /**\n   * Stop monitoring\n   */\n  stopMonitoring(): void {\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = null;\n      console.log(\'Health monitoring stopped\');\n    }\n  }\n\n  /**\n   * Perform health checks on all services\n   */\n  async performHealthChecks(): Promise<void> {\n    const services = [\n      \'api-gateway\',\n      \'authentication\',\n      \'patient-repository\',\n      \'ai-analysis\',\n      \'consent-management\',\n      \'database\',\n      \'cache\',\n    ];\n\n    const environments = [\'PRODUCTION\', \'STAGING\'];\n\n    for (const environment of environments) {\n      for (const service of services) {\n        try {\n          const result = await this.checkServiceHealth(service, environment);\n          await this.updateServiceHealth(result, environment);\n          await this.analyzeHealthStatus(result, environment);\n        } catch (error) {\n          console.error(`Health check failed for ${service} in ${environment}:`, error);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check health of a specific service\n   */\n  async checkServiceHealth(serviceName: string, environment: string): Promise<HealthCheckResult> {\n    const checks = [];\n    const issues = [];\n    let status: HealthStatus = HealthStatus.HEALTHY;\n\n    // 1. Availability Check\n    const availabilityCheck = await this.checkAvailability(serviceName);\n    checks.push(availabilityCheck);\n    if (!availabilityCheck.passed) {\n      status = HealthStatus.DOWN;\n      issues.push(`Service unavailable: ${availabilityCheck.message}`);\n    }\n\n    // 2. Response Time Check\n    const responseTimeCheck = await this.checkResponseTime(serviceName);\n    checks.push(responseTimeCheck);\n    if (!responseTimeCheck.passed) {\n      if (status === HealthStatus.HEALTHY) {\n        status = HealthStatus.DEGRADED;\n      }\n      issues.push(`Slow response time: ${responseTimeCheck.message}`);\n    }\n\n    // 3. Error Rate Check\n    const errorRateCheck = await this.checkErrorRate(serviceName);\n    checks.push(errorRateCheck);\n    if (!errorRateCheck.passed) {\n      if (status === HealthStatus.HEALTHY) {\n        status = HealthStatus.DEGRADED;\n      }\n      issues.push(`High error rate: ${errorRateCheck.message}`);\n    }\n\n    // 4. Resource Usage Check\n    const resourceCheck = await this.checkResourceUsage(serviceName);\n    checks.push(resourceCheck);\n    if (!resourceCheck.passed) {\n      if (status === HealthStatus.HEALTHY) {\n        status = HealthStatus.DEGRADED;\n      }\n      issues.push(`Resource usage high: ${resourceCheck.message}`);\n    }\n\n    // 5. Dependency Check\n    const dependencyCheck = await this.checkDependencies(serviceName);\n    checks.push(dependencyCheck);\n    if (!dependencyCheck.passed) {\n      if (status === HealthStatus.HEALTHY) {\n        status = HealthStatus.DEGRADED;\n      }\n      issues.push(`Dependency issue: ${dependencyCheck.message}`);\n    }\n\n    // Get metrics\n    const metrics = await this.getServiceMetrics(serviceName);\n    const resources = await this.getResourceMetrics(serviceName);\n\n    return {\n      serviceName,\n      status,\n      metrics,\n      resources,\n      checks,\n      issues,\n    };\n  }\n\n  /**\n   * Update service health in database\n   */\n  async updateServiceHealth(result: HealthCheckResult, environment: string): Promise<void> {\n    const existing = await prisma.serviceHealth.findUnique({\n      where: {\n        serviceName_environment: {\n          serviceName: result.serviceName,\n          environment,\n        },\n      },\n    });\n\n    const data = {\n      status: result.status,\n      previousStatus: existing?.status,\n      statusChangedAt: existing?.status !== result.status ? new Date() : existing?.statusChangedAt,\n      uptime: result.metrics.uptime,\n      responseTime: result.metrics.responseTime,\n      errorRate: result.metrics.errorRate,\n      requestRate: result.metrics.requestRate,\n      cpuUsage: result.resources.cpuUsage,\n      memoryUsage: result.resources.memoryUsage,\n      diskUsage: result.resources.diskUsage,\n      networkUsage: result.resources.networkUsage,\n      lastCheckAt: new Date(),\n      checksPerformed: result.checks.map(c => c.name),\n      failedChecks: result.checks.filter(c => !c.passed).map(c => c.name),\n      activeIssues: result.issues,\n      warningCount: result.checks.filter(c => !c.passed && result.status === HealthStatus.DEGRADED).length,\n      errorCount: result.checks.filter(c => !c.passed && result.status === HealthStatus.DOWN).length,\n    };\n\n    await prisma.serviceHealth.upsert({\n      where: {\n        serviceName_environment: {\n          serviceName: result.serviceName,\n          environment,\n        },\n      },\n      create: {\n        serviceName: result.serviceName,\n        environment,\n        ...data,\n      },\n      update: data,\n    });\n  }\n\n  /**\n   * Analyze health status and trigger alerts/incidents\n   */\n  async analyzeHealthStatus(result: HealthCheckResult, environment: string): Promise<void> {\n    // Only trigger incidents for production\n    if (environment !== \'PRODUCTION\') return;\n\n    // Service is down - create SEV1 incident\n    if (result.status === HealthStatus.DOWN) {\n      await this.handleServiceDown(result);\n    }\n\n    // Service is degraded - create SEV2 incident if persistent\n    if (result.status === HealthStatus.DEGRADED) {\n      await this.handleServiceDegraded(result);\n    }\n\n    // Check for threshold violations\n    await this.checkThresholds(result);\n  }\n\n  /**\n   * Handle service down scenario\n   */\n  async handleServiceDown(result: HealthCheckResult): Promise<void> {\n    // Check if incident already exists\n    const existingIncident = await prisma.incident.findFirst({\n      where: {\n        affectedServices: { has: result.serviceName },\n        status: {\n          in: [\'DETECTED\', \'ACKNOWLEDGED\', \'INVESTIGATING\', \'IDENTIFIED\', \'RESOLVING\'],\n        },\n      },\n    });\n\n    if (existingIncident) {\n      // Update existing incident\n      await this.incidentService.addStatusUpdate(existingIncident.id, {\n        status: existingIncident.status,\n        message: `Service still down. Issues: ${result.issues.join(\', \')}`,\n        updatedBy: \'SYSTEM\',\n      });\n      return;\n    }\n\n    // Create new SEV1 incident\n    const incident = await this.incidentService.createIncident({\n      severity: \'SEV1\',\n      title: `Service Down: ${result.serviceName}`,\n      description: `${result.serviceName} is completely unavailable. Issues detected: ${result.issues.join(\', \')}`,\n      affectedServices: [result.serviceName],\n      detectedBy: \'SYSTEM\',\n      detectionMethod: \'HEALTH_MONITORING\',\n    });\n\n    // Trigger automated incident response\n    await this.incidentService.automatedIncidentResponse(incident.id);\n  }\n\n  /**\n   * Handle service degraded scenario\n   */\n  async handleServiceDegraded(result: HealthCheckResult): Promise<void> {\n    // Check if service has been degraded for > 5 minutes\n    const serviceHealth = await prisma.serviceHealth.findUnique({\n      where: {\n        serviceName_environment: {\n          serviceName: result.serviceName,\n          environment: \'PRODUCTION\',\n        },\n      },\n    });\n\n    if (!serviceHealth || !serviceHealth.statusChangedAt) return;\n\n    const degradedDuration = Date.now() - serviceHealth.statusChangedAt.getTime();\n    const fiveMinutes = 5 * 60 * 1000;\n\n    if (degradedDuration > fiveMinutes) {\n      // Check if incident already exists\n      const existingIncident = await prisma.incident.findFirst({\n        where: {\n          affectedServices: { has: result.serviceName },\n          status: {\n            in: [\'DETECTED\', \'ACKNOWLEDGED\', \'INVESTIGATING\', \'IDENTIFIED\', \'RESOLVING\'],\n          },\n        },\n      });\n\n      if (!existingIncident) {\n        // Create SEV2 incident\n        await this.incidentService.createIncident({\n          severity: \'SEV2\',\n          title: `Service Degraded: ${result.serviceName}`,\n          description: `${result.serviceName} has been degraded for ${Math.floor(degradedDuration / 60000)} minutes. Issues: ${result.issues.join(\', \')}`,\n          affectedServices: [result.serviceName],\n          detectedBy: \'SYSTEM\',\n          detectionMethod: \'HEALTH_MONITORING\',\n        });\n      }\n    }\n  }\n\n  /**\n   * Check for threshold violations\n   */\n  async checkThresholds(result: HealthCheckResult): Promise<void> {\n    const thresholds = DEFAULT_THRESHOLDS;\n\n    // Response time threshold\n    if (result.metrics.responseTime && result.metrics.responseTime > thresholds.responseTime) {\n      await this.diagnosisService.reportAndDiagnoseError({\n        severity: \'MEDIUM\',\n        category: \'PERFORMANCE\',\n        errorMessage: `Response time (${result.metrics.responseTime}ms) exceeds threshold (${thresholds.responseTime}ms)`,\n        service: result.serviceName,\n        environment: \'PRODUCTION\',\n      });\n    }\n\n    // Error rate threshold\n    if (result.metrics.errorRate && result.metrics.errorRate > thresholds.errorRate) {\n      await this.diagnosisService.reportAndDiagnoseError({\n        severity: \'HIGH\',\n        category: \'SERVICE_FAILURE\',\n        errorMessage: `Error rate (${result.metrics.errorRate}%) exceeds threshold (${thresholds.errorRate}%)`,\n        service: result.serviceName,\n        environment: \'PRODUCTION\',\n      });\n    }\n\n    // CPU usage threshold\n    if (result.resources.cpuUsage && result.resources.cpuUsage > thresholds.cpuUsage) {\n      await this.diagnosisService.reportAndDiagnoseError({\n        severity: \'MEDIUM\',\n        category: \'PERFORMANCE\',\n        errorMessage: `CPU usage (${result.resources.cpuUsage}%) exceeds threshold (${thresholds.cpuUsage}%)`,\n        service: result.serviceName,\n        environment: \'PRODUCTION\',\n      });\n    }\n\n    // Memory usage threshold\n    if (result.resources.memoryUsage && result.resources.memoryUsage > thresholds.memoryUsage) {\n      await this.diagnosisService.reportAndDiagnoseError({\n        severity: \'HIGH\',\n        category: \'PERFORMANCE\',\n        errorMessage: `Memory usage (${result.resources.memoryUsage}%) exceeds threshold (${thresholds.memoryUsage}%)`,\n        service: result.serviceName,\n        environment: \'PRODUCTION\',\n      });\n    }\n  }\n\n  /**\n   * Get overall system health\n   */\n  async getSystemHealth(): Promise<any> {\n    const services = await prisma.serviceHealth.findMany({\n      where: { environment: \'PRODUCTION\' },\n    });\n\n    const healthyCount = services.filter(s => s.status === HealthStatus.HEALTHY).length;\n    const degradedCount = services.filter(s => s.status === HealthStatus.DEGRADED).length;\n    const downCount = services.filter(s => s.status === HealthStatus.DOWN).length;\n\n    let overallStatus: HealthStatus = HealthStatus.HEALTHY;\n    if (downCount > 0) {\n      overallStatus = HealthStatus.DOWN;\n    } else if (degradedCount > 0) {\n      overallStatus = HealthStatus.DEGRADED;\n    }\n\n    return {\n      overallStatus,\n      totalServices: services.length,\n      healthy: healthyCount,\n      degraded: degradedCount,\n      down: downCount,\n      services: services.map(s => ({\n        name: s.serviceName,\n        status: s.status,\n        uptime: s.uptime,\n        responseTime: s.responseTime,\n        errorRate: s.errorRate,\n        issues: s.activeIssues,\n      })),\n    };\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  private async checkAvailability(serviceName: string): Promise<any> {\n    // TODO: Implement actual availability check\n    // This would ping the service endpoint\n    return {\n      name: \'Availability\',\n      passed: true,\n      message: \'Service is available\',\n    };\n  }\n\n  private async checkResponseTime(serviceName: string): Promise<any> {\n    // TODO: Implement actual response time check\n    const responseTime = Math.random() * 500; // Simulated\n    const passed = responseTime < DEFAULT_THRESHOLDS.responseTime;\n    \n    return {\n      name: \'Response Time\',\n      passed,\n      message: passed ? `Response time: ${responseTime.toFixed(0)}ms` : `Slow response: ${responseTime.toFixed(0)}ms`,\n    };\n  }\n\n  private async checkErrorRate(serviceName: string): Promise<any> {\n    // TODO: Implement actual error rate check\n    const errorRate = Math.random() * 2; // Simulated\n    const passed = errorRate < DEFAULT_THRESHOLDS.errorRate;\n    \n    return {\n      name: \'Error Rate\',\n      passed,\n      message: passed ? `Error rate: ${errorRate.toFixed(2)}%` : `High error rate: ${errorRate.toFixed(2)}%`,\n    };\n  }\n\n  private async checkResourceUsage(serviceName: string): Promise<any> {\n    // TODO: Implement actual resource check\n    const cpuUsage = Math.random() * 100;\n    const memoryUsage = Math.random() * 100;\n    const passed = cpuUsage < DEFAULT_THRESHOLDS.cpuUsage && memoryUsage < DEFAULT_THRESHOLDS.memoryUsage;\n    \n    return {\n      name: \'Resource Usage\',\n      passed,\n      message: passed ? \'Resources within limits\' : `High resource usage: CPU ${cpuUsage.toFixed(0)}%, Memory ${memoryUsage.toFixed(0)}%`,\n    };\n  }\n\n  private async checkDependencies(serviceName: string): Promise<any> {\n    // TODO: Implement actual dependency check\n    return {\n      name: \'Dependencies\',\n      passed: true,\n      message: \'All dependencies available\',\n    };\n  }\n\n  private async getServiceMetrics(serviceName: string): Promise<any> {\n    // TODO: Get actual metrics from monitoring system\n    return {\n      uptime: 99.9,\n      responseTime: Math.random() * 500,\n      errorRate: Math.random() * 2,\n      requestRate: Math.random() * 1000,\n    };\n  }\n\n  private async getResourceMetrics(serviceName: string): Promise<any> {\n    // TODO: Get actual resource metrics\n    return {\n      cpuUsage: Math.random() * 100,\n      memoryUsage: Math.random() * 100,\n      diskUsage: Math.random() * 100,\n      networkUsage: Math.random() * 100,\n    };\n  }\n}\n\nexport default ServiceHealthMonitor;\n</create-file>\n</function_calls>'}