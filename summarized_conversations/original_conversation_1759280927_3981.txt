{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/utils/errorUtils.ts">\n/**\n * Error Utility Functions\n * Helper functions for error handling\n */\n\nimport { AppError } from \'../errors/AppError\';\nimport { error as toastError } from \'@/hooks/useToast\';\n\n// ============================================================================\n// ERROR HANDLING UTILITIES\n// ============================================================================\n\n/**\n * Handle API errors and show toast notifications\n */\nexport async function handleApiError(error: any): Promise<void> {\n  if (error instanceof AppError) {\n    toastError(error.message, error.details?.message);\n  } else if (error.response) {\n    // HTTP error response\n    const data = await error.response.json().catch(() => ({}));\n    toastError(\n      data.error?.message || \'An error occurred\',\n      data.error?.details?.message\n    );\n  } else if (error.message) {\n    toastError(\'Error\', error.message);\n  } else {\n    toastError(\'Error\', \'An unexpected error occurred\');\n  }\n}\n\n/**\n * Retry function with exponential backoff\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  maxRetries: number = 3,\n  baseDelay: number = 1000\n): Promise<T> {\n  let lastError: Error;\n\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error as Error;\n\n      // Don\'t retry on client errors (4xx)\n      if (error instanceof AppError && error.statusCode >= 400 && error.statusCode < 500) {\n        throw error;\n      }\n\n      // Calculate delay with exponential backoff\n      const delay = baseDelay * Math.pow(2, attempt);\n      \n      // Wait before retrying\n      if (attempt < maxRetries - 1) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n\n  throw lastError!;\n}\n\n/**\n * Safe async function wrapper\n */\nexport function safeAsync<T extends any[], R>(\n  fn: (...args: T) => Promise<R>\n): (...args: T) => Promise<R | null> {\n  return async (...args: T): Promise<R | null> => {\n    try {\n      return await fn(...args);\n    } catch (error) {\n      console.error(\'Safe async error:\', error);\n      handleApiError(error);\n      return null;\n    }\n  };\n}\n\n/**\n * Validate response status\n */\nexport function validateResponse(response: Response): void {\n  if (!response.ok) {\n    throw new AppError(\n      `HTTP ${response.status}: ${response.statusText}`,\n      response.status,\n      true,\n      \'HTTP_ERROR\'\n    );\n  }\n}\n\n/**\n * Parse error from fetch response\n */\nexport async function parseErrorResponse(response: Response): Promise<AppError> {\n  try {\n    const data = await response.json();\n    return new AppError(\n      data.error?.message || \'Request failed\',\n      response.status,\n      true,\n      data.error?.code,\n      data.error?.details\n    );\n  } catch {\n    return new AppError(\n      `HTTP ${response.status}: ${response.statusText}`,\n      response.status,\n      true,\n      \'HTTP_ERROR\'\n    );\n  }\n}\n\n/**\n * Create error from unknown type\n */\nexport function createError(error: unknown): Error {\n  if (error instanceof Error) {\n    return error;\n  }\n\n  if (typeof error === \'string\') {\n    return new Error(error);\n  }\n\n  if (error && typeof error === \'object\' && \'message\' in error) {\n    return new Error(String(error.message));\n  }\n\n  return new Error(\'An unknown error occurred\');\n}\n\n/**\n * Check if error is network error\n */\nexport function isNetworkError(error: Error): boolean {\n  return (\n    error.message.includes(\'fetch\') ||\n    error.message.includes(\'network\') ||\n    error.message.includes(\'Failed to fetch\') ||\n    error.message.includes(\'NetworkError\')\n  );\n}\n\n/**\n * Check if error is timeout error\n */\nexport function isTimeoutError(error: Error): boolean {\n  return (\n    error.message.includes(\'timeout\') ||\n    error.message.includes(\'timed out\') ||\n    (error instanceof AppError && error.code === \'TIMEOUT_ERROR\')\n  );\n}\n\n/**\n * Format error for display\n */\nexport function formatErrorMessage(error: Error): string {\n  if (error instanceof AppError) {\n    return error.message;\n  }\n\n  if (isNetworkError(error)) {\n    return \'Network error. Please check your connection and try again.\';\n  }\n\n  if (isTimeoutError(error)) {\n    return \'Request timed out. Please try again.\';\n  }\n\n  return error.message || \'An unexpected error occurred\';\n}\n\n/**\n * Get error severity\n */\nexport function getErrorSeverity(error: Error): \'low\' | \'medium\' | \'high\' | \'critical\' {\n  if (error instanceof AppError) {\n    if (error.statusCode >= 500) return \'critical\';\n    if (error.statusCode === 403 || error.code === \'HIPAA_VIOLATION\') return \'high\';\n    if (error.statusCode === 400 || error.statusCode === 404) return \'medium\';\n    return \'low\';\n  }\n\n  return \'critical\';\n}\n\n// ============================================================================\n// FORM ERROR UTILITIES\n// ============================================================================\n\n/**\n * Extract field errors from validation error\n */\nexport function extractFieldErrors(error: AppError): Record<string, string> {\n  if (error.code !== \'VALIDATION_ERROR\' || !error.details) {\n    return {};\n  }\n\n  const fieldErrors: Record<string, string> = {};\n\n  if (Array.isArray(error.details.errors)) {\n    error.details.errors.forEach((err: any) => {\n      if (err.field && err.message) {\n        fieldErrors[err.field] = err.message;\n      }\n    });\n  }\n\n  return fieldErrors;\n}\n\n/**\n * Create validation error from field errors\n */\nexport function createValidationError(\n  fieldErrors: Record<string, string>\n): AppError {\n  const errors = Object.entries(fieldErrors).map(([field, message]) => ({\n    field,\n    message,\n  }));\n\n  return new AppError(\n    \'Validation failed\',\n    400,\n    true,\n    \'VALIDATION_ERROR\',\n    { errors }\n  );\n}\n\n// ============================================================================\n// ASYNC ERROR BOUNDARY\n// ============================================================================\n\n/**\n * Wrap async function with error boundary\n */\nexport function withErrorBoundary<T extends any[], R>(\n  fn: (...args: T) => Promise<R>,\n  onError?: (error: Error) => void\n): (...args: T) => Promise<R | undefined> {\n  return async (...args: T): Promise<R | undefined> => {\n    try {\n      return await fn(...args);\n    } catch (error) {\n      const err = createError(error);\n      console.error(\'Error boundary caught:\', err);\n      \n      if (onError) {\n        onError(err);\n      } else {\n        handleApiError(err);\n      }\n      \n      return undefined;\n    }\n  };\n}\n</create-file>\n</function_calls>'}