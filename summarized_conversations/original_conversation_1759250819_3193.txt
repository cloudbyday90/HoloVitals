{'role': 'assistant', 'content': 'Now let me create a repository coordinator that manages all three repositories together:\n\n<function_calls>\n<create-file file_path="medical-analysis-platform/lib/repositories/RepositoryCoordinator.ts">\n/**\n * Repository Coordinator\n * \n * Coordinates the three core repositories:\n * 1. AI Analysis Repository - Active analysis tasks\n * 2. AI Prompt Optimization Repository - Optimized prompts\n * 3. AI Context Cache Repository - HIPAA-compliant context\n * \n * This coordinator ensures proper data flow and synchronization between repositories.\n */\n\nimport { aiAnalysisRepository, AnalysisTask, AnalysisResult } from \'./AIAnalysisRepository\';\nimport { aiPromptOptimizationRepository, PromptTemplate } from \'./AIPromptOptimizationRepository\';\nimport { aiContextCacheRepository, ContextEntry } from \'./AIContextCacheRepository\';\nimport { HIPAASanitizer } from \'../utils/hipaa/sanitizer\';\n\nexport interface AnalysisRequest {\n  patientId: string;\n  documentIds: string[];\n  query: string;\n  analysisType?: string;\n  priority?: number;\n}\n\nexport interface AnalysisResponse {\n  taskId: string;\n  status: string;\n  result?: AnalysisResult;\n  missingPieces?: any[];\n  contextUsed: ContextSummary;\n  promptUsed: PromptSummary;\n}\n\nexport interface ContextSummary {\n  entriesUsed: number;\n  types: string[];\n  averageImportance: number;\n  sanitizationCompliant: boolean;\n}\n\nexport interface PromptSummary {\n  templateId: string;\n  templateName: string;\n  tokensEstimated: number;\n  optimizationScore: number;\n}\n\nexport interface SystemHealth {\n  overall: \'healthy\' | \'degraded\' | \'unhealthy\';\n  repositories: {\n    analysis: any;\n    promptOptimization: any;\n    contextCache: any;\n  };\n  timestamp: Date;\n}\n\nexport class RepositoryCoordinator {\n  private static instance: RepositoryCoordinator;\n  private initialized: boolean = false;\n\n  private constructor() {}\n\n  static getInstance(): RepositoryCoordinator {\n    if (!RepositoryCoordinator.instance) {\n      RepositoryCoordinator.instance = new RepositoryCoordinator();\n    }\n    return RepositoryCoordinator.instance;\n  }\n\n  /**\n   * Initialize all repositories\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      console.log(\'[RepositoryCoordinator] Already initialized\');\n      return;\n    }\n\n    console.log(\'[RepositoryCoordinator] Initializing all repositories...\');\n\n    try {\n      await Promise.all([\n        aiAnalysisRepository.initialize(),\n        aiPromptOptimizationRepository.initialize(),\n        aiContextCacheRepository.initialize()\n      ]);\n\n      this.initialized = true;\n      console.log(\'[RepositoryCoordinator] All repositories initialized successfully\');\n    } catch (error) {\n      console.error(\'[RepositoryCoordinator] Initialization failed:\', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Submit a new analysis request\n   * This orchestrates all three repositories\n   */\n  async submitAnalysis(request: AnalysisRequest): Promise<AnalysisResponse> {\n    await this.ensureInitialized();\n\n    console.log(`[RepositoryCoordinator] Processing analysis request for patient ${request.patientId}`);\n\n    // Step 1: Get relevant context from Context Cache Repository\n    const context = await this.gatherContext(request);\n    \n    // Step 2: Get optimized prompt from Prompt Optimization Repository\n    const prompt = await this.getOptimizedPrompt(request, context);\n    \n    // Step 3: Create analysis task in Analysis Repository\n    const task = await aiAnalysisRepository.createTask(\n      request.patientId,\n      request.documentIds,\n      request.query\n    );\n\n    // Step 4: Update task with context and prompt\n    await aiAnalysisRepository.update(task.id, {\n      context: {\n        relevantDocuments: context.map(c => c.id),\n        historicalData: context.filter(c => c.type === \'test_results\').map(c => c.data),\n        relatedFindings: context.filter(c => c.type === \'trends\').map(c => c.data),\n        temporalContext: {\n          dateRange: this.calculateDateRange(context),\n          documentCount: request.documentIds.length\n        },\n        medicalContext: this.extractMedicalContext(context)\n      },\n      prompt: {\n        id: prompt.id,\n        template: prompt.template,\n        variables: this.buildPromptVariables(request, context),\n        optimizationScore: prompt.optimizationMetrics.overallScore,\n        estimatedTokens: prompt.optimizationMetrics.averageTokenCount,\n        version: prompt.version\n      }\n    });\n\n    return {\n      taskId: task.id,\n      status: task.status,\n      missingPieces: task.missingPieces,\n      contextUsed: {\n        entriesUsed: context.length,\n        types: [...new Set(context.map(c => c.type))],\n        averageImportance: context.reduce((sum, c) => sum + c.importance, 0) / context.length,\n        sanitizationCompliant: context.every(c => \n          HIPAASanitizer.validate(c.data).isValid\n        )\n      },\n      promptUsed: {\n        templateId: prompt.id,\n        templateName: prompt.name,\n        tokensEstimated: prompt.optimizationMetrics.averageTokenCount,\n        optimizationScore: prompt.optimizationMetrics.overallScore\n      }\n    };\n  }\n\n  /**\n   * Execute analysis task\n   */\n  async executeAnalysis(taskId: string): Promise<AnalysisResult> {\n    await this.ensureInitialized();\n\n    const task = await aiAnalysisRepository.retrieve(taskId);\n    if (!task) {\n      throw new Error(`Task ${taskId} not found`);\n    }\n\n    console.log(`[RepositoryCoordinator] Executing analysis task ${taskId}`);\n\n    try {\n      // Process the task\n      await aiAnalysisRepository.processNextTask();\n\n      // Simulate AI analysis (in production, this calls OpenAI)\n      const result = await this.performAIAnalysis(task);\n\n      // Record prompt performance\n      await aiPromptOptimizationRepository.recordPerformance(\n        task.prompt.id,\n        {\n          timestamp: new Date(),\n          tokensUsed: result.tokensUsed,\n          responseTime: result.processingTime,\n          success: true\n        }\n      );\n\n      // Complete the task\n      await aiAnalysisRepository.completeTask(taskId, result);\n\n      // Update context cache with new insights\n      await this.updateContextWithResults(task.patientId, result);\n\n      return result;\n    } catch (error) {\n      console.error(`[RepositoryCoordinator] Analysis failed:`, error);\n      await aiAnalysisRepository.failTask(taskId, error instanceof Error ? error.message : \'Unknown error\');\n      throw error;\n    }\n  }\n\n  /**\n   * Add new patient data to context cache\n   */\n  async addPatientData(\n    patientId: string,\n    documentId: string,\n    extractedData: any,\n    documentType: string\n  ): Promise<void> {\n    await this.ensureInitialized();\n\n    console.log(`[RepositoryCoordinator] Adding patient data to context cache`);\n\n    // Determine context type from document type\n    const contextType = this.mapDocumentTypeToContextType(documentType);\n\n    // Add to context cache (will be automatically sanitized)\n    await aiContextCacheRepository.addPatientContext(\n      patientId,\n      contextType,\n      extractedData,\n      {\n        source: documentId,\n        documentIds: [documentId],\n        tags: [documentType, \'extracted\']\n      }\n    );\n\n    // Trigger context reanalysis\n    await aiContextCacheRepository.reanalyzeImportance();\n  }\n\n  /**\n   * Get system health across all repositories\n   */\n  async getSystemHealth(): Promise<SystemHealth> {\n    await this.ensureInitialized();\n\n    const [analysisHealth, promptHealth, cacheHealth] = await Promise.all([\n      aiAnalysisRepository.getHealth(),\n      aiPromptOptimizationRepository.getHealth(),\n      aiContextCacheRepository.getHealth()\n    ]);\n\n    const statuses = [analysisHealth.status, promptHealth.status, cacheHealth.status];\n    const overall = statuses.includes(\'unhealthy\') ? \'unhealthy\' :\n                   statuses.includes(\'degraded\') ? \'degraded\' : \'healthy\';\n\n    return {\n      overall,\n      repositories: {\n        analysis: analysisHealth,\n        promptOptimization: promptHealth,\n        contextCache: cacheHealth\n      },\n      timestamp: new Date()\n    };\n  }\n\n  /**\n   * Get analysis status\n   */\n  async getAnalysisStatus(taskId: string): Promise<AnalysisResponse> {\n    await this.ensureInitialized();\n\n    const task = await aiAnalysisRepository.retrieve(taskId);\n    if (!task) {\n      throw new Error(`Task ${taskId} not found`);\n    }\n\n    return {\n      taskId: task.id,\n      status: task.status,\n      result: task.result,\n      missingPieces: task.missingPieces,\n      contextUsed: {\n        entriesUsed: task.context.relevantDocuments.length,\n        types: Object.keys(task.context.medicalContext),\n        averageImportance: 0,\n        sanitizationCompliant: true\n      },\n      promptUsed: {\n        templateId: task.prompt.id,\n        templateName: \'Analysis Prompt\',\n        tokensEstimated: task.prompt.estimatedTokens,\n        optimizationScore: task.prompt.optimizationScore\n      }\n    };\n  }\n\n  // Private helper methods\n\n  private async ensureInitialized(): Promise<void> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n  }\n\n  private async gatherContext(request: AnalysisRequest): Promise<ContextEntry[]> {\n    // Get relevant context from cache\n    const context = await aiContextCacheRepository.getContextForAnalysis(\n      request.patientId,\n      request.analysisType || \'general\',\n      20 // Max 20 context entries\n    );\n\n    console.log(`[RepositoryCoordinator] Gathered ${context.length} context entries`);\n    return context;\n  }\n\n  private async getOptimizedPrompt(\n    request: AnalysisRequest,\n    context: ContextEntry[]\n  ): Promise<PromptTemplate> {\n    // Determine prompt category\n    const category = this.determinePromptCategory(request.query, request.analysisType);\n\n    // Get best prompt for category\n    const prompt = await aiPromptOptimizationRepository.getBestPrompt(category);\n\n    if (!prompt) {\n      throw new Error(`No prompt template found for category: ${category}`);\n    }\n\n    console.log(`[RepositoryCoordinator] Using prompt template: ${prompt.name}`);\n    return prompt;\n  }\n\n  private determinePromptCategory(query: string, analysisType?: string): any {\n    const queryLower = query.toLowerCase();\n\n    if (analysisType === \'trend\' || queryLower.includes(\'trend\') || queryLower.includes(\'over time\')) {\n      return \'trend_analysis\';\n    }\n    if (queryLower.includes(\'abnormal\') || queryLower.includes(\'unusual\')) {\n      return \'anomaly_detection\';\n    }\n    if (queryLower.includes(\'summarize\') || queryLower.includes(\'summary\')) {\n      return \'summarization\';\n    }\n    if (queryLower.includes(\'compare\') || queryLower.includes(\'difference\')) {\n      return \'comparison\';\n    }\n    if (queryLower.includes(\'risk\') || queryLower.includes(\'danger\')) {\n      return \'risk_assessment\';\n    }\n\n    return \'document_analysis\';\n  }\n\n  private buildPromptVariables(request: AnalysisRequest, context: ContextEntry[]): Record<string, any> {\n    return {\n      query: request.query,\n      documentIds: request.documentIds,\n      contextData: context.map(c => ({\n        type: c.type,\n        data: c.data,\n        importance: c.importance\n      })),\n      patientContext: this.extractMedicalContext(context)\n    };\n  }\n\n  private calculateDateRange(context: ContextEntry[]): { start: Date; end: Date } {\n    const dates = context.map(c => c.timestamp);\n    return {\n      start: new Date(Math.min(...dates.map(d => d.getTime()))),\n      end: new Date(Math.max(...dates.map(d => d.getTime())))\n    };\n  }\n\n  private extractMedicalContext(context: ContextEntry[]): any {\n    const conditions = context\n      .filter(c => c.type === \'conditions\')\n      .flatMap(c => c.data.conditions || []);\n\n    const medications = context\n      .filter(c => c.type === \'medications\')\n      .flatMap(c => c.data.medications || []);\n\n    const allergies = context\n      .filter(c => c.type === \'allergies\')\n      .flatMap(c => c.data.allergies || []);\n\n    return { conditions, medications, allergies };\n  }\n\n  private async performAIAnalysis(task: AnalysisTask): Promise<AnalysisResult> {\n    // This is a placeholder - in production, this would call OpenAI API\n    const startTime = Date.now();\n\n    // Simulate processing\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    return {\n      answer: `Analysis complete for query: "${task.query}". Based on the provided context and documents, here are the findings...`,\n      confidence: 0.85,\n      sources: task.documentIds,\n      insights: [\n        {\n          type: \'trend\',\n          description: \'Sample insight from analysis\',\n          severity: \'medium\',\n          evidence: [\'Document 1\', \'Document 2\'],\n          confidence: 0.8\n        }\n      ],\n      recommendations: [\n        \'Follow up with healthcare provider\',\n        \'Monitor specific values\'\n      ],\n      flags: [],\n      tokensUsed: task.prompt.estimatedTokens,\n      processingTime: Date.now() - startTime\n    };\n  }\n\n  private async updateContextWithResults(patientId: string, result: AnalysisResult): Promise<void> {\n    // Add insights to context cache\n    if (result.insights.length > 0) {\n      await aiContextCacheRepository.addPatientContext(\n        patientId,\n        \'trends\',\n        { insights: result.insights },\n        {\n          source: \'ai_analysis\',\n          documentIds: result.sources,\n          tags: [\'ai_generated\', \'insights\']\n        }\n      );\n    }\n  }\n\n  private mapDocumentTypeToContextType(documentType: string): any {\n    const mapping: Record<string, any> = {\n      \'bloodwork\': \'test_results\',\n      \'imaging\': \'imaging_results\',\n      \'prescription\': \'medications\',\n      \'aftercare\': \'clinical_notes\',\n      \'discharge\': \'clinical_notes\'\n    };\n\n    return mapping[documentType] || \'medical_history\';\n  }\n}\n\nexport const repositoryCoordinator = RepositoryCoordinator.getInstance();\n</create-file>\n</function_calls>'}