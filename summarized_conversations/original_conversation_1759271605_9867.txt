{'role': 'assistant', 'content': '\n<function_calls>\n<str-replace file_path="medical-analysis-platform/lib/services/ContextOptimizerService.ts">\n    <old_str>  /**\n   * Apply optimization strategy\n   */\n  private applyStrategy(\n    segments: ContextSegment[],\n    strategy: OptimizationStrategy,\n    targetTokens?: number\n  ): ContextSegment[] {\n    // Sort by relevance (highest first)\n    const sorted = [...segments].sort((a, b) => \n      b.relevanceScore - a.relevanceScore\n    );\n\n    // Determine threshold based on strategy\n    let threshold: number;\n    switch (strategy) {\n      case OptimizationStrategy.AGGRESSIVE:\n        threshold = 0.6;\n        break;\n      case OptimizationStrategy.BALANCED:\n        threshold = 0.4;\n        break;\n      case OptimizationStrategy.CONSERVATIVE:\n        threshold = 0.3;\n        break;\n      case OptimizationStrategy.MINIMAL:\n        threshold = 0.2;\n        break;\n    }\n\n    // Filter segments above threshold\n    let filtered = sorted.filter(s => s.relevanceScore >= threshold);\n\n    // If target tokens specified, trim to fit\n    if (targetTokens) {\n      let totalTokens = filtered.reduce((sum, s) => sum + s.tokenCount, 0);\n      \n      while (totalTokens > targetTokens && filtered.length > 1) {\n        // Remove lowest scoring segment\n        filtered = filtered.slice(0, -1);\n        totalTokens = filtered.reduce((sum, s) => sum + s.tokenCount, 0);\n      }\n    }\n\n    // Compress remaining segments\n    return filtered.map(segment => ({\n      ...segment,\n      content: this.compressSegment(segment.content, strategy)\n    }));\n  }</old_str>\n    <new_str>  /**\n   * Apply optimization strategy\n   */\n  private applyStrategy(\n    segments: ContextSegment[],\n    strategy: OptimizationStrategy,\n    targetTokens?: number\n  ): ContextSegment[] {\n    // Sort by relevance (highest first)\n    const sorted = [...segments].sort((a, b) => \n      b.relevanceScore - a.relevanceScore\n    );\n\n    // Determine threshold based on strategy (more aggressive)\n    let threshold: number;\n    switch (strategy) {\n      case OptimizationStrategy.AGGRESSIVE:\n        threshold = 0.7; // Higher threshold = fewer segments kept\n        break;\n      case OptimizationStrategy.BALANCED:\n        threshold = 0.5;\n        break;\n      case OptimizationStrategy.CONSERVATIVE:\n        threshold = 0.35;\n        break;\n      case OptimizationStrategy.MINIMAL:\n        threshold = 0.25;\n        break;\n    }\n\n    // Filter segments above threshold\n    let filtered = sorted.filter(s => s.relevanceScore >= threshold);\n\n    // Ensure at least one segment remains\n    if (filtered.length === 0 && sorted.length > 0) {\n      filtered = [sorted[0]];\n    }\n\n    // If target tokens specified, trim to fit\n    if (targetTokens) {\n      let totalTokens = filtered.reduce((sum, s) => sum + s.tokenCount, 0);\n      \n      while (totalTokens > targetTokens && filtered.length > 1) {\n        // Remove lowest scoring segment\n        filtered = filtered.slice(0, -1);\n        totalTokens = filtered.reduce((sum, s) => sum + s.tokenCount, 0);\n      }\n    }\n\n    // Compress remaining segments\n    return filtered.map(segment => ({\n      ...segment,\n      content: this.compressSegment(segment.content, strategy)\n    }));\n  }</new_str>\n</str-replace>\n</function_calls>\n</function_calls>'}