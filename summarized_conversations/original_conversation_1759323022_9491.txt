{'role': 'assistant', 'content': '# Medical Standardization Repository Implementation\n\nI\'ll create a comprehensive Medical Standardization Repository using Mayo Clinic LOINC codes to standardize lab results and other medical data across the HoloVitals platform.\n\n## Plan\n\n1. **Create Medical Standardization Repository Service** with LOINC code management\n2. **Database schema** for LOINC codes, units, reference ranges\n3. **API endpoints** for code lookup, validation, and mapping\n4. **Integration points** for other repositories to reference\n5. **Mayo Clinic LOINC dataset** seeding\n6. **Documentation** and usage guides\n\nLet me start implementing this system.\n\n<function_calls>\n<create-file file_path="lib/services/MedicalStandardizationRepository.ts">\n/**\n * Medical Standardization Repository\n * \n * Centralized repository for medical terminology standardization using LOINC codes.\n * Provides standardized lab results, units, reference ranges, and medical coding\n * that other repositories can reference.\n * \n * Key Features:\n * - LOINC code management (Mayo Clinic dataset)\n * - Unit standardization (UCUM)\n * - Reference range management\n * - Code mapping and validation\n * - Multi-language support\n * - Version tracking\n */\n\nimport { PrismaClient } from \'@prisma/client\';\n\nconst prisma = new PrismaClient();\n\n// LOINC Code Categories\nexport enum LOINCCategory {\n  LABORATORY = \'LABORATORY\',\n  CLINICAL = \'CLINICAL\',\n  SURVEY = \'SURVEY\',\n  CLAIMS = \'CLAIMS\',\n  DOCUMENT = \'DOCUMENT\',\n  RADIOLOGY = \'RADIOLOGY\',\n}\n\n// LOINC Component Types\nexport enum ComponentType {\n  CHEMISTRY = \'CHEMISTRY\',\n  HEMATOLOGY = \'HEMATOLOGY\',\n  MICROBIOLOGY = \'MICROBIOLOGY\',\n  IMMUNOLOGY = \'IMMUNOLOGY\',\n  TOXICOLOGY = \'TOXICOLOGY\',\n  GENETICS = \'GENETICS\',\n  PATHOLOGY = \'PATHOLOGY\',\n  VITAL_SIGNS = \'VITAL_SIGNS\',\n  OTHER = \'OTHER\',\n}\n\n// Unit Systems\nexport enum UnitSystem {\n  UCUM = \'UCUM\', // Unified Code for Units of Measure\n  SI = \'SI\', // International System of Units\n  CONVENTIONAL = \'CONVENTIONAL\',\n}\n\n// Reference Range Types\nexport enum ReferenceRangeType {\n  NORMAL = \'NORMAL\',\n  CRITICAL_LOW = \'CRITICAL_LOW\',\n  CRITICAL_HIGH = \'CRITICAL_HIGH\',\n  THERAPEUTIC = \'THERAPEUTIC\',\n  TOXIC = \'TOXIC\',\n}\n\n// LOINC Code Interface\nexport interface LOINCCode {\n  id: string;\n  loincNumber: string; // e.g., "2345-7"\n  component: string; // e.g., "Glucose"\n  property: string; // e.g., "MCnc" (Mass Concentration)\n  timeAspect: string; // e.g., "Pt" (Point in time)\n  system: string; // e.g., "Ser/Plas" (Serum or Plasma)\n  scale: string; // e.g., "Qn" (Quantitative)\n  method?: string; // e.g., "Enzymatic"\n  category: LOINCCategory;\n  componentType: ComponentType;\n  commonName: string;\n  shortName: string;\n  longName: string;\n  relatedNames?: string[];\n  units: LOINCUnit[];\n  referenceRanges: ReferenceRange[];\n  status: \'ACTIVE\' | \'DEPRECATED\' | \'TRIAL\';\n  version: string;\n  effectiveDate: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// LOINC Unit Interface\nexport interface LOINCUnit {\n  id: string;\n  loincCodeId: string;\n  unit: string; // e.g., "mg/dL"\n  ucumCode: string; // e.g., "mg/dL"\n  unitSystem: UnitSystem;\n  conversionFactor?: number; // For unit conversion\n  isPrimary: boolean;\n  createdAt: Date;\n}\n\n// Reference Range Interface\nexport interface ReferenceRange {\n  id: string;\n  loincCodeId: string;\n  type: ReferenceRangeType;\n  lowValue?: number;\n  highValue?: number;\n  unit: string;\n  ageMin?: number; // Age in years\n  ageMax?: number;\n  gender?: \'MALE\' | \'FEMALE\' | \'OTHER\' | \'ALL\';\n  condition?: string; // e.g., "Pregnant", "Fasting"\n  population?: string; // e.g., "Adult", "Pediatric"\n  source: string; // e.g., "Mayo Clinic"\n  effectiveDate: Date;\n  createdAt: Date;\n}\n\n// Code Mapping Interface (for mapping between different coding systems)\nexport interface CodeMapping {\n  id: string;\n  loincCode: string;\n  targetSystem: string; // e.g., "SNOMED-CT", "CPT", "ICD-10"\n  targetCode: string;\n  relationship: \'EQUIVALENT\' | \'BROADER\' | \'NARROWER\' | \'RELATED\';\n  confidence: number; // 0-1\n  source: string;\n  createdAt: Date;\n}\n\n// Validation Result Interface\nexport interface ValidationResult {\n  isValid: boolean;\n  loincCode?: LOINCCode;\n  errors: string[];\n  warnings: string[];\n  suggestions: LOINCCode[];\n}\n\n// Standardization Result Interface\nexport interface StandardizationResult {\n  originalValue: any;\n  standardizedValue: any;\n  loincCode: LOINCCode;\n  unit: LOINCUnit;\n  referenceRange?: ReferenceRange;\n  isWithinRange: boolean;\n  interpretation?: string;\n  flags: string[]; // e.g., "HIGH", "LOW", "CRITICAL"\n}\n\nexport class MedicalStandardizationRepository {\n  /**\n   * Search for LOINC codes by various criteria\n   */\n  async searchLOINCCodes(params: {\n    query?: string;\n    category?: LOINCCategory;\n    componentType?: ComponentType;\n    component?: string;\n    system?: string;\n    limit?: number;\n    offset?: number;\n  }): Promise<{ codes: LOINCCode[]; total: number }> {\n    const {\n      query,\n      category,\n      componentType,\n      component,\n      system,\n      limit = 50,\n      offset = 0,\n    } = params;\n\n    const where: any = { status: \'ACTIVE\' };\n\n    if (query) {\n      where.OR = [\n        { loincNumber: { contains: query, mode: \'insensitive\' } },\n        { component: { contains: query, mode: \'insensitive\' } },\n        { commonName: { contains: query, mode: \'insensitive\' } },\n        { shortName: { contains: query, mode: \'insensitive\' } },\n      ];\n    }\n\n    if (category) where.category = category;\n    if (componentType) where.componentType = componentType;\n    if (component) where.component = { contains: component, mode: \'insensitive\' };\n    if (system) where.system = { contains: system, mode: \'insensitive\' };\n\n    const [codes, total] = await Promise.all([\n      prisma.lOINCCode.findMany({\n        where,\n        include: {\n          units: true,\n          referenceRanges: true,\n        },\n        take: limit,\n        skip: offset,\n        orderBy: { commonName: \'asc\' },\n      }),\n      prisma.lOINCCode.count({ where }),\n    ]);\n\n    return { codes: codes as any, total };\n  }\n\n  /**\n   * Get LOINC code by LOINC number\n   */\n  async getLOINCCode(loincNumber: string): Promise<LOINCCode | null> {\n    const code = await prisma.lOINCCode.findUnique({\n      where: { loincNumber },\n      include: {\n        units: true,\n        referenceRanges: true,\n      },\n    });\n\n    return code as any;\n  }\n\n  /**\n   * Get LOINC code by ID\n   */\n  async getLOINCCodeById(id: string): Promise<LOINCCode | null> {\n    const code = await prisma.lOINCCode.findUnique({\n      where: { id },\n      include: {\n        units: true,\n        referenceRanges: true,\n      },\n    });\n\n    return code as any;\n  }\n\n  /**\n   * Validate a lab result against LOINC standards\n   */\n  async validateLabResult(params: {\n    loincNumber?: string;\n    testName?: string;\n    value: any;\n    unit?: string;\n    patientAge?: number;\n    patientGender?: \'MALE\' | \'FEMALE\' | \'OTHER\';\n  }): Promise<ValidationResult> {\n    const { loincNumber, testName, value, unit, patientAge, patientGender } = params;\n\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const suggestions: LOINCCode[] = [];\n\n    // Find LOINC code\n    let loincCode: LOINCCode | null = null;\n\n    if (loincNumber) {\n      loincCode = await this.getLOINCCode(loincNumber);\n      if (!loincCode) {\n        errors.push(`LOINC code ${loincNumber} not found`);\n      }\n    } else if (testName) {\n      const searchResult = await this.searchLOINCCodes({\n        query: testName,\n        limit: 5,\n      });\n      if (searchResult.codes.length === 0) {\n        errors.push(`No LOINC codes found for test name: ${testName}`);\n      } else if (searchResult.codes.length === 1) {\n        loincCode = searchResult.codes[0];\n      } else {\n        warnings.push(`Multiple LOINC codes found for test name: ${testName}`);\n        suggestions.push(...searchResult.codes);\n        loincCode = searchResult.codes[0]; // Use first match\n      }\n    } else {\n      errors.push(\'Either loincNumber or testName must be provided\');\n    }\n\n    // Validate unit\n    if (loincCode && unit) {\n      const validUnit = loincCode.units.find(u => \n        u.unit.toLowerCase() === unit.toLowerCase() ||\n        u.ucumCode.toLowerCase() === unit.toLowerCase()\n      );\n      if (!validUnit) {\n        warnings.push(`Unit ${unit} is not standard for this test. Expected: ${loincCode.units.map(u => u.unit).join(\', \')}`);\n      }\n    }\n\n    // Validate value type\n    if (loincCode && value !== null && value !== undefined) {\n      if (loincCode.scale === \'Qn\') {\n        // Quantitative - should be numeric\n        if (isNaN(Number(value))) {\n          errors.push(`Value should be numeric for quantitative test`);\n        }\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      loincCode: loincCode || undefined,\n      errors,\n      warnings,\n      suggestions,\n    };\n  }\n\n  /**\n   * Standardize a lab result\n   */\n  async standardizeLabResult(params: {\n    loincNumber: string;\n    value: any;\n    unit: string;\n    patientAge?: number;\n    patientGender?: \'MALE\' | \'FEMALE\' | \'OTHER\';\n    condition?: string;\n  }): Promise<StandardizationResult> {\n    const { loincNumber, value, unit, patientAge, patientGender, condition } = params;\n\n    // Get LOINC code\n    const loincCode = await this.getLOINCCode(loincNumber);\n    if (!loincCode) {\n      throw new Error(`LOINC code ${loincNumber} not found`);\n    }\n\n    // Find matching unit\n    const loincUnit = loincCode.units.find(u => \n      u.unit.toLowerCase() === unit.toLowerCase() ||\n      u.ucumCode.toLowerCase() === unit.toLowerCase()\n    );\n\n    if (!loincUnit) {\n      throw new Error(`Unit ${unit} not found for LOINC code ${loincNumber}`);\n    }\n\n    // Convert to primary unit if needed\n    let standardizedValue = Number(value);\n    const primaryUnit = loincCode.units.find(u => u.isPrimary);\n    \n    if (primaryUnit && loincUnit.id !== primaryUnit.id && loincUnit.conversionFactor) {\n      standardizedValue = standardizedValue * loincUnit.conversionFactor;\n    }\n\n    // Find applicable reference range\n    const referenceRange = this.findApplicableReferenceRange(\n      loincCode.referenceRanges,\n      patientAge,\n      patientGender,\n      condition\n    );\n\n    // Determine if within range\n    let isWithinRange = true;\n    const flags: string[] = [];\n    let interpretation: string | undefined;\n\n    if (referenceRange) {\n      if (referenceRange.lowValue !== null && standardizedValue < referenceRange.lowValue) {\n        isWithinRange = false;\n        flags.push(\'LOW\');\n        if (referenceRange.type === ReferenceRangeType.CRITICAL_LOW) {\n          flags.push(\'CRITICAL\');\n          interpretation = \'Critically low value\';\n        } else {\n          interpretation = \'Below normal range\';\n        }\n      }\n      if (referenceRange.highValue !== null && standardizedValue > referenceRange.highValue) {\n        isWithinRange = false;\n        flags.push(\'HIGH\');\n        if (referenceRange.type === ReferenceRangeType.CRITICAL_HIGH) {\n          flags.push(\'CRITICAL\');\n          interpretation = \'Critically high value\';\n        } else {\n          interpretation = \'Above normal range\';\n        }\n      }\n      if (isWithinRange) {\n        interpretation = \'Within normal range\';\n      }\n    }\n\n    return {\n      originalValue: value,\n      standardizedValue,\n      loincCode,\n      unit: primaryUnit || loincUnit,\n      referenceRange,\n      isWithinRange,\n      interpretation,\n      flags,\n    };\n  }\n\n  /**\n   * Find applicable reference range based on patient demographics\n   */\n  private findApplicableReferenceRange(\n    ranges: ReferenceRange[],\n    age?: number,\n    gender?: \'MALE\' | \'FEMALE\' | \'OTHER\',\n    condition?: string\n  ): ReferenceRange | undefined {\n    // Filter by normal ranges first\n    let applicableRanges = ranges.filter(r => r.type === ReferenceRangeType.NORMAL);\n\n    // Filter by age\n    if (age !== undefined) {\n      applicableRanges = applicableRanges.filter(r => {\n        if (r.ageMin !== null && age < r.ageMin) return false;\n        if (r.ageMax !== null && age > r.ageMax) return false;\n        return true;\n      });\n    }\n\n    // Filter by gender\n    if (gender) {\n      applicableRanges = applicableRanges.filter(r => \n        r.gender === gender || r.gender === \'ALL\' || r.gender === null\n      );\n    }\n\n    // Filter by condition\n    if (condition) {\n      const conditionRanges = applicableRanges.filter(r => \n        r.condition?.toLowerCase() === condition.toLowerCase()\n      );\n      if (conditionRanges.length > 0) {\n        applicableRanges = conditionRanges;\n      }\n    }\n\n    // Return most specific range (prefer with condition, then gender, then age)\n    return applicableRanges.sort((a, b) => {\n      let scoreA = 0;\n      let scoreB = 0;\n      if (a.condition) scoreA += 4;\n      if (b.condition) scoreB += 4;\n      if (a.gender && a.gender !== \'ALL\') scoreA += 2;\n      if (b.gender && b.gender !== \'ALL\') scoreB += 2;\n      if (a.ageMin !== null || a.ageMax !== null) scoreA += 1;\n      if (b.ageMin !== null || b.ageMax !== null) scoreB += 1;\n      return scoreB - scoreA;\n    })[0];\n  }\n\n  /**\n   * Get code mappings for a LOINC code\n   */\n  async getCodeMappings(loincNumber: string): Promise<CodeMapping[]> {\n    const mappings = await prisma.codeMapping.findMany({\n      where: { loincCode: loincNumber },\n      orderBy: { confidence: \'desc\' },\n    });\n\n    return mappings as any;\n  }\n\n  /**\n   * Map LOINC code to another coding system\n   */\n  async mapToSystem(\n    loincNumber: string,\n    targetSystem: string\n  ): Promise<CodeMapping[]> {\n    const mappings = await prisma.codeMapping.findMany({\n      where: {\n        loincCode: loincNumber,\n        targetSystem,\n      },\n      orderBy: { confidence: \'desc\' },\n    });\n\n    return mappings as any;\n  }\n\n  /**\n   * Get popular LOINC codes by category\n   */\n  async getPopularCodes(\n    category: LOINCCategory,\n    limit: number = 20\n  ): Promise<LOINCCode[]> {\n    const codes = await prisma.lOINCCode.findMany({\n      where: {\n        category,\n        status: \'ACTIVE\',\n      },\n      include: {\n        units: true,\n        referenceRanges: true,\n      },\n      take: limit,\n      orderBy: { commonName: \'asc\' },\n    });\n\n    return codes as any;\n  }\n\n  /**\n   * Get statistics about the LOINC database\n   */\n  async getStatistics(): Promise<{\n    totalCodes: number;\n    activeCodesByCategory: Record<LOINCCategory, number>;\n    activeCodesByType: Record<ComponentType, number>;\n    totalUnits: number;\n    totalReferenceRanges: number;\n    totalMappings: number;\n  }> {\n    const [\n      totalCodes,\n      activeCodesByCategory,\n      activeCodesByType,\n      totalUnits,\n      totalReferenceRanges,\n      totalMappings,\n    ] = await Promise.all([\n      prisma.lOINCCode.count(),\n      prisma.lOINCCode.groupBy({\n        by: [\'category\'],\n        where: { status: \'ACTIVE\' },\n        _count: true,\n      }),\n      prisma.lOINCCode.groupBy({\n        by: [\'componentType\'],\n        where: { status: \'ACTIVE\' },\n        _count: true,\n      }),\n      prisma.lOINCUnit.count(),\n      prisma.referenceRange.count(),\n      prisma.codeMapping.count(),\n    ]);\n\n    return {\n      totalCodes,\n      activeCodesByCategory: activeCodesByCategory.reduce((acc, item) => {\n        acc[item.category as LOINCCategory] = item._count;\n        return acc;\n      }, {} as Record<LOINCCategory, number>),\n      activeCodesByType: activeCodesByType.reduce((acc, item) => {\n        acc[item.componentType as ComponentType] = item._count;\n        return acc;\n      }, {} as Record<ComponentType, number>),\n      totalUnits,\n      totalReferenceRanges,\n      totalMappings,\n    };\n  }\n\n  /**\n   * Batch standardize lab results\n   */\n  async batchStandardize(\n    results: Array<{\n      loincNumber: string;\n      value: any;\n      unit: string;\n      patientAge?: number;\n      patientGender?: \'MALE\' | \'FEMALE\' | \'OTHER\';\n      condition?: string;\n    }>\n  ): Promise<StandardizationResult[]> {\n    return Promise.all(\n      results.map(result => this.standardizeLabResult(result))\n    );\n  }\n\n  /**\n   * Convert between units\n   */\n  async convertUnit(\n    loincNumber: string,\n    value: number,\n    fromUnit: string,\n    toUnit: string\n  ): Promise<{ value: number; unit: string }> {\n    const loincCode = await this.getLOINCCode(loincNumber);\n    if (!loincCode) {\n      throw new Error(`LOINC code ${loincNumber} not found`);\n    }\n\n    const fromUnitObj = loincCode.units.find(u => \n      u.unit.toLowerCase() === fromUnit.toLowerCase() ||\n      u.ucumCode.toLowerCase() === fromUnit.toLowerCase()\n    );\n\n    const toUnitObj = loincCode.units.find(u => \n      u.unit.toLowerCase() === toUnit.toLowerCase() ||\n      u.ucumCode.toLowerCase() === toUnit.toLowerCase()\n    );\n\n    if (!fromUnitObj || !toUnitObj) {\n      throw new Error(`Unit conversion not available`);\n    }\n\n    // Convert to primary unit first, then to target unit\n    const primaryUnit = loincCode.units.find(u => u.isPrimary);\n    if (!primaryUnit) {\n      throw new Error(`No primary unit defined for LOINC code ${loincNumber}`);\n    }\n\n    let convertedValue = value;\n\n    // Convert from source to primary\n    if (fromUnitObj.id !== primaryUnit.id && fromUnitObj.conversionFactor) {\n      convertedValue = convertedValue * fromUnitObj.conversionFactor;\n    }\n\n    // Convert from primary to target\n    if (toUnitObj.id !== primaryUnit.id && toUnitObj.conversionFactor) {\n      convertedValue = convertedValue / toUnitObj.conversionFactor;\n    }\n\n    return {\n      value: convertedValue,\n      unit: toUnitObj.unit,\n    };\n  }\n}\n\n// Export singleton instance\nlet instance: MedicalStandardizationRepository | null = null;\n\nexport function getMedicalStandardizationRepository(): MedicalStandardizationRepository {\n  if (!instance) {\n    instance = new MedicalStandardizationRepository();\n  }\n  return instance;\n}\n</create-file>\n</function_calls>'}