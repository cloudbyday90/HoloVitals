{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/repositories/AIAnalysisRepository.ts">\n/**\n * AI Analysis Repository\n * \n * This repository actively analyzes data and seeks the missing pieces of the "puzzle"\n * that need to be analyzed. It stores:\n * - Patient info (sanitized)\n * - Data to be analyzed\n * - Context from Context Cache Repository\n * - AI prompts from Prompt Optimization Repository\n * - Analysis results and status\n */\n\nimport { IRepository, RepositoryHealth } from \'./interfaces/IRepository\';\nimport { PrismaClient } from \'@prisma/client\';\n\nconst prisma = new PrismaClient();\n\nexport interface AnalysisTask {\n  id: string;\n  patientId: string;\n  documentIds: string[];\n  query: string;\n  context: AnalysisContext;\n  prompt: OptimizedPrompt;\n  status: AnalysisStatus;\n  priority: number;\n  createdAt: Date;\n  updatedAt: Date;\n  completedAt?: Date;\n  result?: AnalysisResult;\n  missingPieces?: MissingPiece[];\n}\n\nexport interface AnalysisContext {\n  relevantDocuments: string[];\n  historicalData: any[];\n  relatedFindings: any[];\n  temporalContext: {\n    dateRange: { start: Date; end: Date };\n    documentCount: number;\n  };\n  medicalContext: {\n    conditions: string[];\n    medications: string[];\n    allergies: string[];\n  };\n}\n\nexport interface OptimizedPrompt {\n  id: string;\n  template: string;\n  variables: Record<string, any>;\n  optimizationScore: number;\n  estimatedTokens: number;\n  version: string;\n}\n\nexport type AnalysisStatus = \n  | \'pending\'           // Waiting to be processed\n  | \'gathering_context\' // Collecting context from cache\n  | \'optimizing_prompt\' // Getting optimized prompt\n  | \'analyzing\'         // AI is analyzing\n  | \'completed\'         // Analysis complete\n  | \'failed\'            // Analysis failed\n  | \'missing_data\';     // Missing required data\n\nexport interface AnalysisResult {\n  answer: string;\n  confidence: number;\n  sources: string[];\n  insights: Insight[];\n  recommendations: string[];\n  flags: AnalysisFlag[];\n  tokensUsed: number;\n  processingTime: number;\n}\n\nexport interface Insight {\n  type: \'trend\' | \'anomaly\' | \'correlation\' | \'risk\' | \'improvement\';\n  description: string;\n  severity: \'low\' | \'medium\' | \'high\' | \'critical\';\n  evidence: string[];\n  confidence: number;\n}\n\nexport interface AnalysisFlag {\n  type: \'abnormal_value\' | \'missing_data\' | \'inconsistency\' | \'urgent\' | \'follow_up\';\n  description: string;\n  severity: \'info\' | \'warning\' | \'error\' | \'critical\';\n  affectedFields: string[];\n}\n\nexport interface MissingPiece {\n  type: \'document\' | \'data_point\' | \'context\' | \'historical_data\';\n  description: string;\n  importance: \'required\' | \'recommended\' | \'optional\';\n  suggestedAction: string;\n}\n\nexport class AIAnalysisRepository implements IRepository<AnalysisTask> {\n  readonly name = \'AIAnalysisRepository\';\n  readonly version = \'1.0.0\';\n  \n  private tasks: Map<string, AnalysisTask> = new Map();\n  private processingQueue: string[] = [];\n\n  async initialize(): Promise<void> {\n    console.log(`[${this.name}] Initializing...`);\n    \n    // Load pending tasks from database\n    const pendingTasks = await prisma.analysisSession.findMany({\n      where: {\n        sessionType: \'ai_analysis\'\n      },\n      include: {\n        interactions: true\n      }\n    });\n\n    console.log(`[${this.name}] Loaded ${pendingTasks.length} pending tasks`);\n  }\n\n  /**\n   * Create a new analysis task\n   */\n  async createTask(\n    patientId: string,\n    documentIds: string[],\n    query: string\n  ): Promise<AnalysisTask> {\n    const taskId = this.generateTaskId();\n    \n    const task: AnalysisTask = {\n      id: taskId,\n      patientId,\n      documentIds,\n      query,\n      context: await this.gatherInitialContext(documentIds),\n      prompt: await this.getOptimizedPrompt(query),\n      status: \'pending\',\n      priority: this.calculatePriority(query, documentIds),\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      missingPieces: []\n    };\n\n    await this.store(taskId, task);\n    this.addToQueue(taskId);\n\n    return task;\n  }\n\n  /**\n   * Store analysis task\n   */\n  async store(key: string, data: AnalysisTask): Promise<void> {\n    this.tasks.set(key, data);\n    \n    // Persist to database\n    await prisma.analysisSession.upsert({\n      where: { id: key },\n      create: {\n        id: key,\n        userId: data.patientId,\n        sessionType: \'ai_analysis\',\n        createdAt: data.createdAt\n      },\n      update: {\n        updatedAt: data.updatedAt\n      }\n    });\n  }\n\n  /**\n   * Retrieve analysis task\n   */\n  async retrieve(key: string): Promise<AnalysisTask | null> {\n    return this.tasks.get(key) || null;\n  }\n\n  /**\n   * Update analysis task\n   */\n  async update(key: string, data: Partial<AnalysisTask>): Promise<void> {\n    const existing = await this.retrieve(key);\n    if (!existing) {\n      throw new Error(`Task ${key} not found`);\n    }\n\n    const updated = {\n      ...existing,\n      ...data,\n      updatedAt: new Date()\n    };\n\n    await this.store(key, updated);\n  }\n\n  /**\n   * Delete analysis task\n   */\n  async delete(key: string): Promise<void> {\n    this.tasks.delete(key);\n    await prisma.analysisSession.delete({\n      where: { id: key }\n    });\n  }\n\n  /**\n   * Check if task exists\n   */\n  async exists(key: string): Promise<boolean> {\n    return this.tasks.has(key);\n  }\n\n  /**\n   * Clear all tasks\n   */\n  async clear(): Promise<void> {\n    this.tasks.clear();\n    this.processingQueue = [];\n  }\n\n  /**\n   * Get repository health\n   */\n  async getHealth(): Promise<RepositoryHealth> {\n    const taskCount = this.tasks.size;\n    const queueLength = this.processingQueue.length;\n    \n    const statusCounts = {\n      pending: 0,\n      processing: 0,\n      completed: 0,\n      failed: 0\n    };\n\n    for (const task of this.tasks.values()) {\n      if (task.status === \'pending\') statusCounts.pending++;\n      else if (task.status === \'analyzing\') statusCounts.processing++;\n      else if (task.status === \'completed\') statusCounts.completed++;\n      else if (task.status === \'failed\') statusCounts.failed++;\n    }\n\n    const issues: string[] = [];\n    if (queueLength > 100) {\n      issues.push(`High queue length: ${queueLength} tasks pending`);\n    }\n    if (statusCounts.failed > 10) {\n      issues.push(`High failure rate: ${statusCounts.failed} failed tasks`);\n    }\n\n    return {\n      status: issues.length === 0 ? \'healthy\' : issues.length < 3 ? \'degraded\' : \'unhealthy\',\n      lastCheck: new Date(),\n      metrics: {\n        itemCount: taskCount,\n        storageUsed: this.estimateStorageUsed(),\n        averageResponseTime: await this.calculateAverageResponseTime()\n      },\n      issues: issues.length > 0 ? issues : undefined\n    };\n  }\n\n  /**\n   * Identify missing pieces for analysis\n   */\n  async identifyMissingPieces(taskId: string): Promise<MissingPiece[]> {\n    const task = await this.retrieve(taskId);\n    if (!task) return [];\n\n    const missing: MissingPiece[] = [];\n\n    // Check for missing documents\n    if (task.documentIds.length === 0) {\n      missing.push({\n        type: \'document\',\n        description: \'No documents provided for analysis\',\n        importance: \'required\',\n        suggestedAction: \'Upload relevant medical documents\'\n      });\n    }\n\n    // Check for missing context\n    if (!task.context.historicalData || task.context.historicalData.length === 0) {\n      missing.push({\n        type: \'historical_data\',\n        description: \'No historical data available for trend analysis\',\n        importance: \'recommended\',\n        suggestedAction: \'Upload previous test results for comparison\'\n      });\n    }\n\n    // Check for missing medical context\n    if (task.context.medicalContext.conditions.length === 0) {\n      missing.push({\n        type: \'context\',\n        description: \'No medical conditions recorded\',\n        importance: \'optional\',\n        suggestedAction: \'Add known medical conditions for better context\'\n      });\n    }\n\n    // Update task with missing pieces\n    await this.update(taskId, { missingPieces: missing });\n\n    return missing;\n  }\n\n  /**\n   * Process next task in queue\n   */\n  async processNextTask(): Promise<AnalysisTask | null> {\n    if (this.processingQueue.length === 0) {\n      return null;\n    }\n\n    const taskId = this.processingQueue.shift()!;\n    const task = await this.retrieve(taskId);\n    \n    if (!task) {\n      return null;\n    }\n\n    // Check for missing pieces\n    const missingPieces = await this.identifyMissingPieces(taskId);\n    \n    if (missingPieces.some(p => p.importance === \'required\')) {\n      await this.update(taskId, { \n        status: \'missing_data\',\n        missingPieces \n      });\n      return task;\n    }\n\n    // Update status to analyzing\n    await this.update(taskId, { status: \'analyzing\' });\n\n    return task;\n  }\n\n  /**\n   * Complete analysis task with result\n   */\n  async completeTask(taskId: string, result: AnalysisResult): Promise<void> {\n    await this.update(taskId, {\n      status: \'completed\',\n      result,\n      completedAt: new Date()\n    });\n\n    // Store result in database\n    await prisma.aiInteraction.create({\n      data: {\n        sessionId: taskId,\n        query: (await this.retrieve(taskId))!.query,\n        response: result.answer,\n        contextDocuments: (await this.retrieve(taskId))!.documentIds,\n        createdAt: new Date()\n      }\n    });\n  }\n\n  /**\n   * Mark task as failed\n   */\n  async failTask(taskId: string, error: string): Promise<void> {\n    await this.update(taskId, {\n      status: \'failed\',\n      result: {\n        answer: `Analysis failed: ${error}`,\n        confidence: 0,\n        sources: [],\n        insights: [],\n        recommendations: [],\n        flags: [{\n          type: \'urgent\',\n          description: error,\n          severity: \'error\',\n          affectedFields: []\n        }],\n        tokensUsed: 0,\n        processingTime: 0\n      }\n    });\n  }\n\n  /**\n   * Get all tasks by status\n   */\n  async getTasksByStatus(status: AnalysisStatus): Promise<AnalysisTask[]> {\n    const tasks: AnalysisTask[] = [];\n    for (const task of this.tasks.values()) {\n      if (task.status === status) {\n        tasks.push(task);\n      }\n    }\n    return tasks;\n  }\n\n  /**\n   * Get tasks for a specific patient\n   */\n  async getPatientTasks(patientId: string): Promise<AnalysisTask[]> {\n    const tasks: AnalysisTask[] = [];\n    for (const task of this.tasks.values()) {\n      if (task.patientId === patientId) {\n        tasks.push(task);\n      }\n    }\n    return tasks.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n  }\n\n  // Private helper methods\n\n  private generateTaskId(): string {\n    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async gatherInitialContext(documentIds: string[]): Promise<AnalysisContext> {\n    // This will be enhanced to pull from Context Cache Repository\n    return {\n      relevantDocuments: documentIds,\n      historicalData: [],\n      relatedFindings: [],\n      temporalContext: {\n        dateRange: { start: new Date(), end: new Date() },\n        documentCount: documentIds.length\n      },\n      medicalContext: {\n        conditions: [],\n        medications: [],\n        allergies: []\n      }\n    };\n  }\n\n  private async getOptimizedPrompt(query: string): Promise<OptimizedPrompt> {\n    // This will be enhanced to pull from Prompt Optimization Repository\n    return {\n      id: `prompt_${Date.now()}`,\n      template: \'Analyze the following medical data: {{query}}\',\n      variables: { query },\n      optimizationScore: 0.8,\n      estimatedTokens: 100,\n      version: \'1.0\'\n    };\n  }\n\n  private calculatePriority(query: string, documentIds: string[]): number {\n    // Higher priority for urgent keywords\n    const urgentKeywords = [\'urgent\', \'emergency\', \'critical\', \'abnormal\', \'severe\'];\n    const hasUrgent = urgentKeywords.some(keyword => \n      query.toLowerCase().includes(keyword)\n    );\n\n    return hasUrgent ? 10 : 5;\n  }\n\n  private addToQueue(taskId: string): void {\n    this.processingQueue.push(taskId);\n    // Sort by priority\n    this.processingQueue.sort((a, b) => {\n      const taskA = this.tasks.get(a);\n      const taskB = this.tasks.get(b);\n      return (taskB?.priority || 0) - (taskA?.priority || 0);\n    });\n  }\n\n  private estimateStorageUsed(): number {\n    // Rough estimate in bytes\n    return this.tasks.size * 10000; // ~10KB per task\n  }\n\n  private async calculateAverageResponseTime(): Promise<number> {\n    const completedTasks = await this.getTasksByStatus(\'completed\');\n    if (completedTasks.length === 0) return 0;\n\n    const totalTime = completedTasks.reduce((sum, task) => {\n      if (task.result) {\n        return sum + task.result.processingTime;\n      }\n      return sum;\n    }, 0);\n\n    return totalTime / completedTasks.length;\n  }\n}\n\nexport const aiAnalysisRepository = new AIAnalysisRepository();\n</create-file>\n</function_calls>'}