{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/auth/AuthService.ts">\n/**\n * Authentication Service for HoloVitals\n * \n * Implements secure authentication with:\n * - Password hashing with bcrypt\n * - JWT token management\n * - Multi-Factor Authentication (MFA) with TOTP\n * - Session management\n * - Account lockout protection\n */\n\nimport bcrypt from \'bcryptjs\';\nimport jwt from \'jsonwebtoken\';\nimport speakeasy from \'speakeasy\';\nimport qrcode from \'qrcode\';\nimport { PrismaClient } from \'@prisma/client\';\n\nconst prisma = new PrismaClient();\n\nexport interface AuthUser {\n  id: string;\n  email: string;\n  role: UserRole;\n  mfaEnabled: boolean;\n  mfaVerified?: boolean;\n}\n\nexport type UserRole = \'patient\' | \'specialist\' | \'admin\';\n\nexport interface LoginCredentials {\n  email: string;\n  password: string;\n  mfaToken?: string;\n}\n\nexport interface RegisterData {\n  email: string;\n  password: string;\n  firstName: string;\n  lastName: string;\n  dateOfBirth: Date;\n}\n\nexport interface AuthTokens {\n  accessToken: string;\n  refreshToken: string;\n  expiresIn: number;\n}\n\nexport interface MFASetup {\n  secret: string;\n  qrCode: string;\n  backupCodes: string[];\n}\n\nexport interface SessionInfo {\n  userId: string;\n  email: string;\n  role: UserRole;\n  sessionId: string;\n  createdAt: Date;\n  expiresAt: Date;\n  ipAddress?: string;\n  userAgent?: string;\n}\n\nexport class AuthService {\n  private readonly JWT_SECRET = process.env.JWT_SECRET || \'your-secret-key-change-in-production\';\n  private readonly JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || \'your-refresh-secret-change-in-production\';\n  private readonly ACCESS_TOKEN_EXPIRY = \'15m\'; // 15 minutes\n  private readonly REFRESH_TOKEN_EXPIRY = \'7d\'; // 7 days\n  private readonly SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes\n  private readonly MAX_LOGIN_ATTEMPTS = 5;\n  private readonly LOCKOUT_DURATION = 15 * 60 * 1000; // 15 minutes\n\n  /**\n   * Register a new patient account\n   */\n  async register(data: RegisterData): Promise<AuthUser> {\n    // Check if user already exists\n    const existingUser = await prisma.user.findUnique({\n      where: { email: data.email }\n    });\n\n    if (existingUser) {\n      throw new Error(\'User with this email already exists\');\n    }\n\n    // Validate password strength\n    this.validatePasswordStrength(data.password);\n\n    // Hash password\n    const passwordHash = await bcrypt.hash(data.password, 12);\n\n    // Create user\n    const user = await prisma.user.create({\n      data: {\n        email: data.email,\n        passwordHash,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      }\n    });\n\n    // Create patient profile\n    await prisma.patient.create({\n      data: {\n        userId: user.id,\n        firstName: data.firstName,\n        lastName: data.lastName,\n        dateOfBirth: data.dateOfBirth,\n        createdAt: new Date()\n      }\n    });\n\n    return {\n      id: user.id,\n      email: user.email,\n      role: \'patient\',\n      mfaEnabled: false\n    };\n  }\n\n  /**\n   * Login with email and password\n   */\n  async login(credentials: LoginCredentials, ipAddress?: string, userAgent?: string): Promise<AuthTokens> {\n    // Get user\n    const user = await prisma.user.findUnique({\n      where: { email: credentials.email }\n    });\n\n    if (!user) {\n      throw new Error(\'Invalid credentials\');\n    }\n\n    // Check if account is locked\n    await this.checkAccountLockout(user.id);\n\n    // Verify password\n    const isValidPassword = await bcrypt.compare(credentials.password, user.passwordHash);\n\n    if (!isValidPassword) {\n      await this.recordFailedLogin(user.id);\n      throw new Error(\'Invalid credentials\');\n    }\n\n    // Check MFA if enabled\n    const mfaEnabled = await this.isMFAEnabled(user.id);\n    \n    if (mfaEnabled) {\n      if (!credentials.mfaToken) {\n        throw new Error(\'MFA token required\');\n      }\n\n      const isValidMFA = await this.verifyMFAToken(user.id, credentials.mfaToken);\n      if (!isValidMFA) {\n        await this.recordFailedLogin(user.id);\n        throw new Error(\'Invalid MFA token\');\n      }\n    }\n\n    // Reset failed login attempts\n    await this.resetFailedLoginAttempts(user.id);\n\n    // Get user role\n    const role = await this.getUserRole(user.id);\n\n    // Create session\n    const sessionId = await this.createSession(user.id, ipAddress, userAgent);\n\n    // Generate tokens\n    const tokens = this.generateTokens({\n      id: user.id,\n      email: user.email,\n      role,\n      mfaEnabled,\n      mfaVerified: true\n    }, sessionId);\n\n    return tokens;\n  }\n\n  /**\n   * Refresh access token\n   */\n  async refreshToken(refreshToken: string): Promise<AuthTokens> {\n    try {\n      const decoded = jwt.verify(refreshToken, this.JWT_REFRESH_SECRET) as any;\n\n      // Verify session is still valid\n      const session = await this.getSession(decoded.sessionId);\n      if (!session || session.expiresAt < new Date()) {\n        throw new Error(\'Session expired\');\n      }\n\n      // Get user\n      const user = await prisma.user.findUnique({\n        where: { id: decoded.userId }\n      });\n\n      if (!user) {\n        throw new Error(\'User not found\');\n      }\n\n      // Get user role\n      const role = await this.getUserRole(user.id);\n\n      // Generate new tokens\n      return this.generateTokens({\n        id: user.id,\n        email: user.email,\n        role,\n        mfaEnabled: decoded.mfaEnabled,\n        mfaVerified: decoded.mfaVerified\n      }, decoded.sessionId);\n    } catch (error) {\n      throw new Error(\'Invalid refresh token\');\n    }\n  }\n\n  /**\n   * Logout user\n   */\n  async logout(sessionId: string): Promise<void> {\n    await this.destroySession(sessionId);\n  }\n\n  /**\n   * Setup MFA for user\n   */\n  async setupMFA(userId: string): Promise<MFASetup> {\n    const user = await prisma.user.findUnique({\n      where: { id: userId }\n    });\n\n    if (!user) {\n      throw new Error(\'User not found\');\n    }\n\n    // Generate secret\n    const secret = speakeasy.generateSecret({\n      name: `HoloVitals (${user.email})`,\n      issuer: \'HoloVitals\'\n    });\n\n    // Generate QR code\n    const qrCode = await qrcode.toDataURL(secret.otpauth_url!);\n\n    // Generate backup codes\n    const backupCodes = this.generateBackupCodes(10);\n\n    // Store MFA secret (encrypted in production)\n    await prisma.$executeRaw`\n      UPDATE users \n      SET mfa_secret = ${secret.base32},\n          mfa_backup_codes = ${JSON.stringify(backupCodes)},\n          updated_at = NOW()\n      WHERE id = ${userId}\n    `;\n\n    return {\n      secret: secret.base32,\n      qrCode,\n      backupCodes\n    };\n  }\n\n  /**\n   * Enable MFA after verification\n   */\n  async enableMFA(userId: string, token: string): Promise<void> {\n    const isValid = await this.verifyMFAToken(userId, token);\n    \n    if (!isValid) {\n      throw new Error(\'Invalid MFA token\');\n    }\n\n    await prisma.$executeRaw`\n      UPDATE users \n      SET mfa_enabled = true,\n          updated_at = NOW()\n      WHERE id = ${userId}\n    `;\n  }\n\n  /**\n   * Disable MFA\n   */\n  async disableMFA(userId: string, password: string): Promise<void> {\n    const user = await prisma.user.findUnique({\n      where: { id: userId }\n    });\n\n    if (!user) {\n      throw new Error(\'User not found\');\n    }\n\n    // Verify password\n    const isValidPassword = await bcrypt.compare(password, user.passwordHash);\n    if (!isValidPassword) {\n      throw new Error(\'Invalid password\');\n    }\n\n    await prisma.$executeRaw`\n      UPDATE users \n      SET mfa_enabled = false,\n          mfa_secret = NULL,\n          mfa_backup_codes = NULL,\n          updated_at = NOW()\n      WHERE id = ${userId}\n    `;\n  }\n\n  /**\n   * Verify MFA token\n   */\n  async verifyMFAToken(userId: string, token: string): Promise<boolean> {\n    const result = await prisma.$queryRaw<any[]>`\n      SELECT mfa_secret, mfa_backup_codes \n      FROM users \n      WHERE id = ${userId}\n    `;\n\n    if (!result || result.length === 0) {\n      return false;\n    }\n\n    const { mfa_secret, mfa_backup_codes } = result[0];\n\n    if (!mfa_secret) {\n      return false;\n    }\n\n    // Verify TOTP token\n    const isValidTOTP = speakeasy.totp.verify({\n      secret: mfa_secret,\n      encoding: \'base32\',\n      token,\n      window: 2 // Allow 2 time steps before/after\n    });\n\n    if (isValidTOTP) {\n      return true;\n    }\n\n    // Check backup codes\n    if (mfa_backup_codes) {\n      const backupCodes = JSON.parse(mfa_backup_codes);\n      const codeIndex = backupCodes.indexOf(token);\n      \n      if (codeIndex !== -1) {\n        // Remove used backup code\n        backupCodes.splice(codeIndex, 1);\n        await prisma.$executeRaw`\n          UPDATE users \n          SET mfa_backup_codes = ${JSON.stringify(backupCodes)}\n          WHERE id = ${userId}\n        `;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Change password\n   */\n  async changePassword(userId: string, currentPassword: string, newPassword: string): Promise<void> {\n    const user = await prisma.user.findUnique({\n      where: { id: userId }\n    });\n\n    if (!user) {\n      throw new Error(\'User not found\');\n    }\n\n    // Verify current password\n    const isValidPassword = await bcrypt.compare(currentPassword, user.passwordHash);\n    if (!isValidPassword) {\n      throw new Error(\'Invalid current password\');\n    }\n\n    // Validate new password strength\n    this.validatePasswordStrength(newPassword);\n\n    // Hash new password\n    const newPasswordHash = await bcrypt.hash(newPassword, 12);\n\n    // Update password\n    await prisma.user.update({\n      where: { id: userId },\n      data: {\n        passwordHash: newPasswordHash,\n        updatedAt: new Date()\n      }\n    });\n\n    // Invalidate all sessions except current\n    await this.invalidateAllSessions(userId);\n  }\n\n  /**\n   * Verify JWT token\n   */\n  verifyToken(token: string): AuthUser {\n    try {\n      const decoded = jwt.verify(token, this.JWT_SECRET) as any;\n      return {\n        id: decoded.userId,\n        email: decoded.email,\n        role: decoded.role,\n        mfaEnabled: decoded.mfaEnabled,\n        mfaVerified: decoded.mfaVerified\n      };\n    } catch (error) {\n      throw new Error(\'Invalid token\');\n    }\n  }\n\n  // Private helper methods\n\n  private generateTokens(user: AuthUser, sessionId: string): AuthTokens {\n    const accessToken = jwt.sign(\n      {\n        userId: user.id,\n        email: user.email,\n        role: user.role,\n        mfaEnabled: user.mfaEnabled,\n        mfaVerified: user.mfaVerified,\n        sessionId\n      },\n      this.JWT_SECRET,\n      { expiresIn: this.ACCESS_TOKEN_EXPIRY }\n    );\n\n    const refreshToken = jwt.sign(\n      {\n        userId: user.id,\n        sessionId,\n        mfaEnabled: user.mfaEnabled,\n        mfaVerified: user.mfaVerified\n      },\n      this.JWT_REFRESH_SECRET,\n      { expiresIn: this.REFRESH_TOKEN_EXPIRY }\n    );\n\n    return {\n      accessToken,\n      refreshToken,\n      expiresIn: 15 * 60 // 15 minutes in seconds\n    };\n  }\n\n  private async createSession(userId: string, ipAddress?: string, userAgent?: string): Promise<string> {\n    const sessionId = this.generateSessionId();\n    const expiresAt = new Date(Date.now() + this.SESSION_TIMEOUT);\n\n    await prisma.$executeRaw`\n      INSERT INTO user_sessions (id, user_id, expires_at, ip_address, user_agent, created_at)\n      VALUES (${sessionId}, ${userId}, ${expiresAt}, ${ipAddress}, ${userAgent}, NOW())\n    `;\n\n    return sessionId;\n  }\n\n  private async getSession(sessionId: string): Promise<SessionInfo | null> {\n    const result = await prisma.$queryRaw<any[]>`\n      SELECT * FROM user_sessions WHERE id = ${sessionId}\n    `;\n\n    if (!result || result.length === 0) {\n      return null;\n    }\n\n    const session = result[0];\n    return {\n      userId: session.user_id,\n      email: session.email,\n      role: session.role,\n      sessionId: session.id,\n      createdAt: session.created_at,\n      expiresAt: session.expires_at,\n      ipAddress: session.ip_address,\n      userAgent: session.user_agent\n    };\n  }\n\n  private async destroySession(sessionId: string): Promise<void> {\n    await prisma.$executeRaw`\n      DELETE FROM user_sessions WHERE id = ${sessionId}\n    `;\n  }\n\n  private async invalidateAllSessions(userId: string): Promise<void> {\n    await prisma.$executeRaw`\n      DELETE FROM user_sessions WHERE user_id = ${userId}\n    `;\n  }\n\n  private async getUserRole(userId: string): Promise<UserRole> {\n    // Check if patient\n    const patient = await prisma.patient.findFirst({\n      where: { userId }\n    });\n\n    if (patient) {\n      return \'patient\';\n    }\n\n    // Check if specialist (would be in a specialists table)\n    // For now, default to patient\n    return \'patient\';\n  }\n\n  private async isMFAEnabled(userId: string): Promise<boolean> {\n    const result = await prisma.$queryRaw<any[]>`\n      SELECT mfa_enabled FROM users WHERE id = ${userId}\n    `;\n\n    return result && result.length > 0 && result[0].mfa_enabled;\n  }\n\n  private async checkAccountLockout(userId: string): Promise<void> {\n    const result = await prisma.$queryRaw<any[]>`\n      SELECT failed_login_attempts, last_failed_login \n      FROM users \n      WHERE id = ${userId}\n    `;\n\n    if (!result || result.length === 0) {\n      return;\n    }\n\n    const { failed_login_attempts, last_failed_login } = result[0];\n\n    if (failed_login_attempts >= this.MAX_LOGIN_ATTEMPTS) {\n      const lockoutEnd = new Date(last_failed_login.getTime() + this.LOCKOUT_DURATION);\n      \n      if (new Date() < lockoutEnd) {\n        const minutesLeft = Math.ceil((lockoutEnd.getTime() - Date.now()) / 60000);\n        throw new Error(`Account locked. Try again in ${minutesLeft} minutes.`);\n      } else {\n        // Lockout period expired, reset attempts\n        await this.resetFailedLoginAttempts(userId);\n      }\n    }\n  }\n\n  private async recordFailedLogin(userId: string): Promise<void> {\n    await prisma.$executeRaw`\n      UPDATE users \n      SET failed_login_attempts = failed_login_attempts + 1,\n          last_failed_login = NOW()\n      WHERE id = ${userId}\n    `;\n  }\n\n  private async resetFailedLoginAttempts(userId: string): Promise<void> {\n    await prisma.$executeRaw`\n      UPDATE users \n      SET failed_login_attempts = 0,\n          last_failed_login = NULL\n      WHERE id = ${userId}\n    `;\n  }\n\n  private validatePasswordStrength(password: string): void {\n    if (password.length < 12) {\n      throw new Error(\'Password must be at least 12 characters long\');\n    }\n\n    const hasUpperCase = /[A-Z]/.test(password);\n    const hasLowerCase = /[a-z]/.test(password);\n    const hasNumbers = /\\d/.test(password);\n    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);\n\n    if (!hasUpperCase || !hasLowerCase || !hasNumbers || !hasSpecialChar) {\n      throw new Error(\'Password must contain uppercase, lowercase, numbers, and special characters\');\n    }\n  }\n\n  private generateSessionId(): string {\n    return `sess_${Date.now()}_${Math.random().toString(36).substr(2, 16)}`;\n  }\n\n  private generateBackupCodes(count: number): string[] {\n    const codes: string[] = [];\n    for (let i = 0; i < count; i++) {\n      const code = Math.random().toString(36).substr(2, 8).toUpperCase();\n      codes.push(code);\n    }\n    return codes;\n  }\n}\n\nexport const authService = new AuthService();\n</create-file>\n</function_calls>'}