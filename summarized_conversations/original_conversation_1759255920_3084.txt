{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/services/AIErrorDiagnosisService.ts">\n/**\n * AI Error Diagnosis Service\n * \n * Uses AI to analyze errors, detect patterns, identify root causes, and suggest fixes.\n * Provides automated diagnosis and recovery recommendations.\n */\n\nimport { PrismaClient, ErrorEvent, ErrorSeverity, ErrorCategory, ErrorDiagnosis, ErrorPattern } from \'@prisma/client\';\nimport OpenAI from \'openai\';\n\nconst prisma = new PrismaClient();\nconst openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n\ninterface ErrorEventData {\n  severity: ErrorSeverity;\n  category: ErrorCategory;\n  errorCode?: string;\n  errorMessage: string;\n  stackTrace?: string;\n  service: string;\n  environment: string;\n  endpoint?: string;\n  userId?: string;\n  metadata?: any;\n}\n\ninterface DiagnosisResult {\n  rootCause: string;\n  rootCauseCategory: string;\n  affectedComponents: string[];\n  suggestedFixes: SuggestedFix[];\n  confidence: number;\n  similarIncidents: string[];\n  kbArticles: string[];\n}\n\ninterface SuggestedFix {\n  action: string;\n  description: string;\n  priority: number;\n  estimatedTime: number; // minutes\n  risk: \'LOW\' | \'MEDIUM\' | \'HIGH\';\n  commands?: string[];\n  rollbackProcedure?: string;\n}\n\ninterface PatternAnalysis {\n  isRecurring: boolean;\n  frequency: string;\n  pattern: ErrorPattern | null;\n  relatedErrors: string[];\n}\n\nexport class AIErrorDiagnosisService {\n  /**\n   * Report and diagnose an error\n   */\n  async reportAndDiagnoseError(data: ErrorEventData): Promise<{ error: ErrorEvent; diagnosis: ErrorDiagnosis }> {\n    // Create error event\n    const errorEvent = await this.createErrorEvent(data);\n\n    // Perform AI diagnosis\n    const diagnosis = await this.diagnoseError(errorEvent.id);\n\n    // Check for patterns\n    await this.analyzeErrorPatterns(errorEvent.id);\n\n    return { error: errorEvent, diagnosis };\n  }\n\n  /**\n   * Create error event\n   */\n  async createErrorEvent(data: ErrorEventData): Promise<ErrorEvent> {\n    // Check if similar error exists\n    const existingError = await this.findSimilarError(data);\n\n    if (existingError) {\n      // Update existing error occurrence count\n      return await prisma.errorEvent.update({\n        where: { id: existingError.id },\n        data: {\n          occurrenceCount: existingError.occurrenceCount + 1,\n          lastOccurrence: new Date(),\n        },\n      });\n    }\n\n    // Create new error event\n    return await prisma.errorEvent.create({\n      data: {\n        severity: data.severity,\n        category: data.category,\n        errorCode: data.errorCode,\n        errorMessage: data.errorMessage,\n        stackTrace: data.stackTrace,\n        service: data.service,\n        environment: data.environment,\n        endpoint: data.endpoint,\n        userId: data.userId,\n        detectedBy: \'SYSTEM\',\n        metadata: data.metadata,\n        diagnosisStatus: \'PENDING\',\n      },\n    });\n  }\n\n  /**\n   * Diagnose error using AI\n   */\n  async diagnoseError(errorEventId: string): Promise<ErrorDiagnosis> {\n    const errorEvent = await prisma.errorEvent.findUnique({\n      where: { id: errorEventId },\n    });\n\n    if (!errorEvent) {\n      throw new Error(\'Error event not found\');\n    }\n\n    // Update diagnosis status\n    await prisma.errorEvent.update({\n      where: { id: errorEventId },\n      data: { diagnosisStatus: \'IN_PROGRESS\' },\n    });\n\n    try {\n      // Get similar historical incidents\n      const similarIncidents = await this.findSimilarIncidents(errorEvent);\n\n      // Get relevant KB articles\n      const kbArticles = await this.findRelevantKBArticles(errorEvent);\n\n      // Perform AI analysis\n      const aiAnalysis = await this.performAIAnalysis(errorEvent, similarIncidents, kbArticles);\n\n      // Create diagnosis record\n      const diagnosis = await prisma.errorDiagnosis.create({\n        data: {\n          errorEventId,\n          aiModel: \'gpt-4\',\n          modelVersion: \'2024-01\',\n          confidence: aiAnalysis.confidence,\n          rootCause: aiAnalysis.rootCause,\n          rootCauseCategory: aiAnalysis.rootCauseCategory,\n          affectedComponents: aiAnalysis.affectedComponents,\n          suggestedFixes: aiAnalysis.suggestedFixes,\n          recommendedFix: aiAnalysis.suggestedFixes[0]?.action,\n          similarIncidents: similarIncidents.map(i => i.id),\n          kbArticles: kbArticles.map(kb => kb.id),\n        },\n      });\n\n      // Update error event\n      await prisma.errorEvent.update({\n        where: { id: errorEventId },\n        data: {\n          diagnosisStatus: \'COMPLETED\',\n          rootCause: aiAnalysis.rootCause,\n          rootCauseService: aiAnalysis.affectedComponents[0],\n          diagnosisConfidence: aiAnalysis.confidence,\n        },\n      });\n\n      return diagnosis;\n    } catch (error: any) {\n      // Mark diagnosis as failed\n      await prisma.errorEvent.update({\n        where: { id: errorEventId },\n        data: { diagnosisStatus: \'PENDING\' },\n      });\n\n      throw new Error(`Diagnosis failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Perform AI analysis using OpenAI\n   */\n  private async performAIAnalysis(\n    errorEvent: ErrorEvent,\n    similarIncidents: any[],\n    kbArticles: any[]\n  ): Promise<DiagnosisResult> {\n    const prompt = this.buildDiagnosisPrompt(errorEvent, similarIncidents, kbArticles);\n\n    const response = await openai.chat.completions.create({\n      model: \'gpt-4\',\n      messages: [\n        {\n          role: \'system\',\n          content: `You are an expert system administrator and DevOps engineer specializing in diagnosing and resolving system errors. \n          Analyze the error information provided and provide a detailed diagnosis with actionable solutions.\n          Return your response in JSON format with the following structure:\n          {\n            "rootCause": "detailed explanation of the root cause",\n            "rootCauseCategory": "category of the root cause",\n            "affectedComponents": ["list", "of", "affected", "components"],\n            "confidence": 0.95,\n            "suggestedFixes": [\n              {\n                "action": "brief action description",\n                "description": "detailed description",\n                "priority": 1,\n                "estimatedTime": 10,\n                "risk": "LOW",\n                "commands": ["command1", "command2"],\n                "rollbackProcedure": "how to rollback if needed"\n              }\n            ]\n          }`,\n        },\n        {\n          role: \'user\',\n          content: prompt,\n        },\n      ],\n      temperature: 0.3,\n      response_format: { type: \'json_object\' },\n    });\n\n    const analysis = JSON.parse(response.choices[0].message.content || \'{}\');\n\n    return {\n      rootCause: analysis.rootCause,\n      rootCauseCategory: analysis.rootCauseCategory,\n      affectedComponents: analysis.affectedComponents,\n      suggestedFixes: analysis.suggestedFixes,\n      confidence: analysis.confidence,\n      similarIncidents: similarIncidents.map(i => i.id),\n      kbArticles: kbArticles.map(kb => kb.id),\n    };\n  }\n\n  /**\n   * Build diagnosis prompt for AI\n   */\n  private buildDiagnosisPrompt(\n    errorEvent: ErrorEvent,\n    similarIncidents: any[],\n    kbArticles: any[]\n  ): string {\n    let prompt = `Analyze the following error and provide a diagnosis:\\n\\n`;\n    \n    prompt += `ERROR DETAILS:\\n`;\n    prompt += `- Severity: ${errorEvent.severity}\\n`;\n    prompt += `- Category: ${errorEvent.category}\\n`;\n    prompt += `- Service: ${errorEvent.service}\\n`;\n    prompt += `- Environment: ${errorEvent.environment}\\n`;\n    prompt += `- Error Message: ${errorEvent.errorMessage}\\n`;\n    \n    if (errorEvent.errorCode) {\n      prompt += `- Error Code: ${errorEvent.errorCode}\\n`;\n    }\n    \n    if (errorEvent.endpoint) {\n      prompt += `- Endpoint: ${errorEvent.endpoint}\\n`;\n    }\n    \n    if (errorEvent.stackTrace) {\n      prompt += `\\nSTACK TRACE:\\n${errorEvent.stackTrace}\\n`;\n    }\n    \n    if (similarIncidents.length > 0) {\n      prompt += `\\nSIMILAR PAST INCIDENTS:\\n`;\n      similarIncidents.forEach((incident, index) => {\n        prompt += `${index + 1}. ${incident.title}\\n`;\n        prompt += `   Resolution: ${incident.resolutionSummary || \'N/A\'}\\n`;\n      });\n    }\n    \n    if (kbArticles.length > 0) {\n      prompt += `\\nRELEVANT KNOWLEDGE BASE ARTICLES:\\n`;\n      kbArticles.forEach((article, index) => {\n        prompt += `${index + 1}. ${article.title}\\n`;\n        prompt += `   Resolution: ${article.resolution}\\n`;\n      });\n    }\n    \n    prompt += `\\nProvide a comprehensive diagnosis with actionable solutions.`;\n    \n    return prompt;\n  }\n\n  /**\n   * Analyze error patterns\n   */\n  async analyzeErrorPatterns(errorEventId: string): Promise<PatternAnalysis> {\n    const errorEvent = await prisma.errorEvent.findUnique({\n      where: { id: errorEventId },\n    });\n\n    if (!errorEvent) {\n      throw new Error(\'Error event not found\');\n    }\n\n    // Find similar errors in the last 24 hours\n    const recentSimilarErrors = await prisma.errorEvent.findMany({\n      where: {\n        category: errorEvent.category,\n        service: errorEvent.service,\n        detectedAt: {\n          gte: new Date(Date.now() - 24 * 60 * 60 * 1000),\n        },\n      },\n    });\n\n    const isRecurring = recentSimilarErrors.length > 3;\n\n    if (isRecurring) {\n      // Check if pattern already exists\n      let pattern = await prisma.errorPattern.findFirst({\n        where: {\n          errorCategory: errorEvent.category,\n          services: { has: errorEvent.service },\n        },\n      });\n\n      if (pattern) {\n        // Update existing pattern\n        pattern = await prisma.errorPattern.update({\n          where: { id: pattern.id },\n          data: {\n            lastDetected: new Date(),\n            occurrences: pattern.occurrences + 1,\n          },\n        });\n      } else {\n        // Create new pattern\n        pattern = await prisma.errorPattern.create({\n          data: {\n            patternName: `Recurring ${errorEvent.category} in ${errorEvent.service}`,\n            patternType: \'RECURRING\',\n            description: `Pattern detected: ${errorEvent.errorMessage}`,\n            errorCategory: errorEvent.category,\n            services: [errorEvent.service],\n            frequency: \'HOURLY\',\n            severity: errorEvent.severity,\n          },\n        });\n      }\n\n      return {\n        isRecurring: true,\n        frequency: \'HOURLY\',\n        pattern,\n        relatedErrors: recentSimilarErrors.map(e => e.id),\n      };\n    }\n\n    return {\n      isRecurring: false,\n      frequency: \'NONE\',\n      pattern: null,\n      relatedErrors: [],\n    };\n  }\n\n  /**\n   * Get error diagnosis\n   */\n  async getErrorDiagnosis(errorEventId: string): Promise<ErrorDiagnosis | null> {\n    return await prisma.errorDiagnosis.findUnique({\n      where: { errorEventId },\n    });\n  }\n\n  /**\n   * Validate diagnosis (after resolution)\n   */\n  async validateDiagnosis(diagnosisId: string, wasCorrect: boolean, actualRootCause?: string): Promise<void> {\n    await prisma.errorDiagnosis.update({\n      where: { id: diagnosisId },\n      data: {\n        diagnosisCorrect: wasCorrect,\n        actualRootCause,\n        validatedAt: new Date(),\n      },\n    });\n\n    // Update KB if diagnosis was correct\n    if (wasCorrect) {\n      const diagnosis = await prisma.errorDiagnosis.findUnique({\n        where: { id: diagnosisId },\n        include: { errorEvent: true },\n      });\n\n      if (diagnosis) {\n        await this.updateKnowledgeBase(diagnosis);\n      }\n    }\n  }\n\n  /**\n   * Create or update knowledge base article\n   */\n  async updateKnowledgeBase(diagnosis: any): Promise<void> {\n    const errorEvent = diagnosis.errorEvent;\n\n    // Check if KB article exists\n    const existingArticle = await prisma.errorKnowledgeBase.findFirst({\n      where: {\n        category: errorEvent.category,\n        errorCode: errorEvent.errorCode,\n      },\n    });\n\n    if (existingArticle) {\n      // Update existing article\n      await prisma.errorKnowledgeBase.update({\n        where: { id: existingArticle.id },\n        data: {\n          timesReferenced: existingArticle.timesReferenced + 1,\n          lastUsed: new Date(),\n        },\n      });\n    } else {\n      // Create new article\n      await prisma.errorKnowledgeBase.create({\n        data: {\n          title: `${errorEvent.category}: ${errorEvent.errorMessage.substring(0, 100)}`,\n          category: errorEvent.category,\n          errorCode: errorEvent.errorCode,\n          description: errorEvent.errorMessage,\n          symptoms: errorEvent.errorMessage,\n          rootCause: diagnosis.rootCause,\n          resolution: JSON.stringify(diagnosis.suggestedFixes),\n          severity: errorEvent.severity,\n          affectedServices: [errorEvent.service],\n          tags: [errorEvent.category, errorEvent.service],\n          createdBy: \'SYSTEM\',\n          verified: true,\n          verifiedBy: \'AI_DIAGNOSIS\',\n          verifiedAt: new Date(),\n        },\n      });\n    }\n  }\n\n  /**\n   * Get error statistics\n   */\n  async getErrorStatistics(): Promise<any> {\n    const [\n      totalErrors,\n      criticalErrors,\n      unresolvedErrors,\n      errorsBySeverity,\n      errorsByCategory,\n      errorsByService,\n      averageDiagnosisTime,\n      averageResolutionTime,\n      diagnosisAccuracy,\n    ] = await Promise.all([\n      prisma.errorEvent.count(),\n      prisma.errorEvent.count({ where: { severity: ErrorSeverity.CRITICAL } }),\n      prisma.errorEvent.count({ where: { resolved: false } }),\n      this.getErrorCountBySeverity(),\n      this.getErrorCountByCategory(),\n      this.getErrorCountByService(),\n      this.calculateAverageDiagnosisTime(),\n      this.calculateAverageResolutionTime(),\n      this.calculateDiagnosisAccuracy(),\n    ]);\n\n    return {\n      total: totalErrors,\n      critical: criticalErrors,\n      unresolved: unresolvedErrors,\n      bySeverity: errorsBySeverity,\n      byCategory: errorsByCategory,\n      byService: errorsByService,\n      averageDiagnosisTime,\n      averageResolutionTime,\n      diagnosisAccuracy,\n    };\n  }\n\n  /**\n   * Get active error patterns\n   */\n  async getActivePatterns(): Promise<ErrorPattern[]> {\n    return await prisma.errorPattern.findMany({\n      where: {\n        lastDetected: {\n          gte: new Date(Date.now() - 24 * 60 * 60 * 1000), // Last 24 hours\n        },\n      },\n      orderBy: {\n        occurrences: \'desc\',\n      },\n    });\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  private async findSimilarError(data: ErrorEventData): Promise<ErrorEvent | null> {\n    return await prisma.errorEvent.findFirst({\n      where: {\n        errorMessage: data.errorMessage,\n        service: data.service,\n        environment: data.environment,\n        resolved: false,\n        detectedAt: {\n          gte: new Date(Date.now() - 60 * 60 * 1000), // Last hour\n        },\n      },\n    });\n  }\n\n  private async findSimilarIncidents(errorEvent: ErrorEvent): Promise<any[]> {\n    // TODO: Implement similarity search\n    // This would use vector embeddings or text similarity\n    return [];\n  }\n\n  private async findRelevantKBArticles(errorEvent: ErrorEvent): Promise<any[]> {\n    return await prisma.errorKnowledgeBase.findMany({\n      where: {\n        category: errorEvent.category,\n        affectedServices: { has: errorEvent.service },\n      },\n      orderBy: {\n        timesReferenced: \'desc\',\n      },\n      take: 3,\n    });\n  }\n\n  private async getErrorCountBySeverity(): Promise<any> {\n    const counts = await prisma.errorEvent.groupBy({\n      by: [\'severity\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.severity] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async getErrorCountByCategory(): Promise<any> {\n    const counts = await prisma.errorEvent.groupBy({\n      by: [\'category\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.category] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async getErrorCountByService(): Promise<any> {\n    const counts = await prisma.errorEvent.groupBy({\n      by: [\'service\'],\n      _count: true,\n    });\n    return counts.reduce((acc, curr) => {\n      acc[curr.service] = curr._count;\n      return acc;\n    }, {} as any);\n  }\n\n  private async calculateAverageDiagnosisTime(): Promise<number> {\n    const diagnoses = await prisma.errorDiagnosis.findMany({\n      include: {\n        errorEvent: true,\n      },\n    });\n\n    if (diagnoses.length === 0) return 0;\n\n    const totalTime = diagnoses.reduce((sum, diagnosis) => {\n      const diagnosisTime = diagnosis.diagnosedAt.getTime() - diagnosis.errorEvent.detectedAt.getTime();\n      return sum + diagnosisTime;\n    }, 0);\n\n    // Return average in seconds\n    return Math.round(totalTime / diagnoses.length / 1000);\n  }\n\n  private async calculateAverageResolutionTime(): Promise<number> {\n    const resolvedErrors = await prisma.errorEvent.findMany({\n      where: {\n        resolved: true,\n        resolvedAt: { not: null },\n      },\n    });\n\n    if (resolvedErrors.length === 0) return 0;\n\n    const totalTime = resolvedErrors.reduce((sum, error) => {\n      const resolutionTime = error.resolvedAt!.getTime() - error.detectedAt.getTime();\n      return sum + resolutionTime;\n    }, 0);\n\n    // Return average in minutes\n    return Math.round(totalTime / resolvedErrors.length / (1000 * 60));\n  }\n\n  private async calculateDiagnosisAccuracy(): Promise<number> {\n    const validatedDiagnoses = await prisma.errorDiagnosis.findMany({\n      where: {\n        diagnosisCorrect: { not: null },\n      },\n    });\n\n    if (validatedDiagnoses.length === 0) return 0;\n\n    const correctDiagnoses = validatedDiagnoses.filter(d => d.diagnosisCorrect).length;\n\n    return Math.round((correctDiagnoses / validatedDiagnoses.length) * 100);\n  }\n}\n\nexport default AIErrorDiagnosisService;\n</create-file>\n</function_calls>'}