{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/audit/AuditLogger.ts">\n/**\n * Audit Logger for HoloVitals\n * \n * Comprehensive audit logging system for HIPAA compliance.\n * Logs all access to PHI/PII data with:\n * - Who accessed (user ID)\n * - What was accessed (resource)\n * - When (timestamp)\n * - Where (IP address, location)\n * - Why (action, reason)\n * - Result (success/failure)\n */\n\nimport { PrismaClient } from \'@prisma/client\';\n\nconst prisma = new PrismaClient();\n\nexport interface AuditLogEntry {\n  userId: string;\n  action: AuditAction;\n  resource: string;\n  resourceId: string;\n  details?: any;\n  ipAddress?: string;\n  userAgent?: string;\n  sessionId?: string;\n  severity: AuditSeverity;\n  requiresReview?: boolean;\n  consentId?: string;\n}\n\nexport type AuditAction = \n  // Authentication\n  | \'login_success\'\n  | \'login_failed\'\n  | \'logout\'\n  | \'mfa_enabled\'\n  | \'mfa_disabled\'\n  | \'password_changed\'\n  | \'account_locked\'\n  \n  // Data Access\n  | \'data_viewed\'\n  | \'data_created\'\n  | \'data_updated\'\n  | \'data_deleted\'\n  | \'data_exported\'\n  | \'data_printed\'\n  \n  // Consent\n  | \'consent_requested\'\n  | \'consent_approved\'\n  | \'consent_denied\'\n  | \'consent_revoked\'\n  \n  // Specialist Access\n  | \'specialist_access_granted\'\n  | \'specialist_access_denied\'\n  | \'specialist_data_viewed\'\n  | \'specialist_data_corrected\'\n  \n  // System\n  | \'system_error\'\n  | \'security_violation\'\n  | \'unauthorized_access_attempt\'\n  | \'suspicious_activity\';\n\nexport type AuditSeverity = \'low\' | \'medium\' | \'high\' | \'critical\';\n\nexport interface AuditQuery {\n  userId?: string;\n  action?: AuditAction;\n  resource?: string;\n  startDate?: Date;\n  endDate?: Date;\n  severity?: AuditSeverity;\n  requiresReview?: boolean;\n  limit?: number;\n}\n\nexport interface AuditReport {\n  totalEntries: number;\n  entriesBySeverity: Record<AuditSeverity, number>;\n  entriesByAction: Record<string, number>;\n  suspiciousActivities: AuditLogEntry[];\n  requiresReview: AuditLogEntry[];\n  dateRange: { start: Date; end: Date };\n}\n\nexport class AuditLogger {\n  /**\n   * Log an audit event\n   */\n  async log(entry: AuditLogEntry): Promise<string> {\n    const logId = this.generateLogId();\n    const timestamp = new Date();\n\n    try {\n      await prisma.$executeRaw`\n        INSERT INTO audit_logs (\n          id, user_id, action, resource, resource_id, details,\n          ip_address, user_agent, session_id, severity, \n          requires_review, consent_id, timestamp, created_at\n        ) VALUES (\n          ${logId}, ${entry.userId}, ${entry.action}, ${entry.resource},\n          ${entry.resourceId}, ${JSON.stringify(entry.details || {})},\n          ${entry.ipAddress}, ${entry.userAgent}, ${entry.sessionId},\n          ${entry.severity}, ${entry.requiresReview || false},\n          ${entry.consentId}, ${timestamp}, NOW()\n        )\n      `;\n\n      // Check for suspicious patterns\n      await this.checkSuspiciousActivity(entry);\n\n      // Alert if critical\n      if (entry.severity === \'critical\') {\n        await this.sendCriticalAlert(entry);\n      }\n\n      return logId;\n    } catch (error) {\n      console.error(\'[AuditLogger] Failed to log audit entry:\', error);\n      // In production, this should never fail - use fallback logging\n      throw error;\n    }\n  }\n\n  /**\n   * Log PHI/PII access\n   */\n  async logPHIAccess(\n    userId: string,\n    patientId: string,\n    dataType: string,\n    action: \'view\' | \'edit\' | \'delete\',\n    consentId?: string,\n    ipAddress?: string,\n    userAgent?: string\n  ): Promise<string> {\n    return await this.log({\n      userId,\n      action: action === \'view\' ? \'data_viewed\' : \n              action === \'edit\' ? \'data_updated\' : \'data_deleted\',\n      resource: \'patient_phi\',\n      resourceId: patientId,\n      details: {\n        dataType,\n        patientId,\n        consentId\n      },\n      ipAddress,\n      userAgent,\n      severity: \'high\',\n      requiresReview: true,\n      consentId\n    });\n  }\n\n  /**\n   * Log specialist access\n   */\n  async logSpecialistAccess(\n    specialistId: string,\n    patientId: string,\n    action: string,\n    consentId: string,\n    details: any,\n    ipAddress?: string,\n    userAgent?: string\n  ): Promise<string> {\n    return await this.log({\n      userId: specialistId,\n      action: \'specialist_data_viewed\',\n      resource: \'patient_data\',\n      resourceId: patientId,\n      details: {\n        ...details,\n        consentId,\n        specialistAccess: true\n      },\n      ipAddress,\n      userAgent,\n      severity: \'high\',\n      requiresReview: true,\n      consentId\n    });\n  }\n\n  /**\n   * Log security violation\n   */\n  async logSecurityViolation(\n    userId: string,\n    violation: string,\n    details: any,\n    ipAddress?: string,\n    userAgent?: string\n  ): Promise<string> {\n    return await this.log({\n      userId,\n      action: \'security_violation\',\n      resource: \'security\',\n      resourceId: userId,\n      details: {\n        violation,\n        ...details\n      },\n      ipAddress,\n      userAgent,\n      severity: \'critical\',\n      requiresReview: true\n    });\n  }\n\n  /**\n   * Log unauthorized access attempt\n   */\n  async logUnauthorizedAccess(\n    userId: string,\n    attemptedResource: string,\n    reason: string,\n    ipAddress?: string,\n    userAgent?: string\n  ): Promise<string> {\n    return await this.log({\n      userId,\n      action: \'unauthorized_access_attempt\',\n      resource: attemptedResource,\n      resourceId: userId,\n      details: {\n        reason,\n        attemptedResource\n      },\n      ipAddress,\n      userAgent,\n      severity: \'high\',\n      requiresReview: true\n    });\n  }\n\n  /**\n   * Query audit logs\n   */\n  async query(query: AuditQuery): Promise<AuditLogEntry[]> {\n    let sql = `SELECT * FROM audit_logs WHERE 1=1`;\n    const params: any[] = [];\n\n    if (query.userId) {\n      sql += ` AND user_id = ?`;\n      params.push(query.userId);\n    }\n\n    if (query.action) {\n      sql += ` AND action = ?`;\n      params.push(query.action);\n    }\n\n    if (query.resource) {\n      sql += ` AND resource = ?`;\n      params.push(query.resource);\n    }\n\n    if (query.startDate) {\n      sql += ` AND timestamp >= ?`;\n      params.push(query.startDate);\n    }\n\n    if (query.endDate) {\n      sql += ` AND timestamp <= ?`;\n      params.push(query.endDate);\n    }\n\n    if (query.severity) {\n      sql += ` AND severity = ?`;\n      params.push(query.severity);\n    }\n\n    if (query.requiresReview !== undefined) {\n      sql += ` AND requires_review = ?`;\n      params.push(query.requiresReview);\n    }\n\n    sql += ` ORDER BY timestamp DESC`;\n\n    if (query.limit) {\n      sql += ` LIMIT ?`;\n      params.push(query.limit);\n    }\n\n    const results = await prisma.$queryRawUnsafe<any[]>(sql, ...params);\n\n    return results.map(this.mapToAuditLogEntry);\n  }\n\n  /**\n   * Get audit logs for a patient\n   */\n  async getPatientAuditLogs(patientId: string, limit: number = 100): Promise<AuditLogEntry[]> {\n    const results = await prisma.$queryRaw<any[]>`\n      SELECT * FROM audit_logs \n      WHERE resource_id = ${patientId}\n        OR details LIKE ${`%${patientId}%`}\n      ORDER BY timestamp DESC\n      LIMIT ${limit}\n    `;\n\n    return results.map(this.mapToAuditLogEntry);\n  }\n\n  /**\n   * Get audit logs requiring review\n   */\n  async getLogsRequiringReview(limit: number = 50): Promise<AuditLogEntry[]> {\n    const results = await prisma.$queryRaw<any[]>`\n      SELECT * FROM audit_logs \n      WHERE requires_review = true\n        AND reviewed = false\n      ORDER BY timestamp DESC\n      LIMIT ${limit}\n    `;\n\n    return results.map(this.mapToAuditLogEntry);\n  }\n\n  /**\n   * Mark audit log as reviewed\n   */\n  async markAsReviewed(logId: string, reviewerId: string, notes?: string): Promise<void> {\n    await prisma.$executeRaw`\n      UPDATE audit_logs \n      SET reviewed = true,\n          reviewed_by = ${reviewerId},\n          reviewed_at = NOW(),\n          review_notes = ${notes}\n      WHERE id = ${logId}\n    `;\n  }\n\n  /**\n   * Generate audit report\n   */\n  async generateReport(startDate: Date, endDate: Date): Promise<AuditReport> {\n    const logs = await this.query({ startDate, endDate });\n\n    const entriesBySeverity: Record<AuditSeverity, number> = {\n      low: 0,\n      medium: 0,\n      high: 0,\n      critical: 0\n    };\n\n    const entriesByAction: Record<string, number> = {};\n\n    for (const log of logs) {\n      entriesBySeverity[log.severity]++;\n      entriesByAction[log.action] = (entriesByAction[log.action] || 0) + 1;\n    }\n\n    const suspiciousActivities = logs.filter(log => \n      log.action === \'suspicious_activity\' || \n      log.action === \'security_violation\' ||\n      log.action === \'unauthorized_access_attempt\'\n    );\n\n    const requiresReview = logs.filter(log => log.requiresReview);\n\n    return {\n      totalEntries: logs.length,\n      entriesBySeverity,\n      entriesByAction,\n      suspiciousActivities,\n      requiresReview,\n      dateRange: { start: startDate, end: endDate }\n    };\n  }\n\n  /**\n   * Get user activity summary\n   */\n  async getUserActivitySummary(userId: string, days: number = 30): Promise<any> {\n    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\n\n    const logs = await this.query({ userId, startDate });\n\n    const actionCounts: Record<string, number> = {};\n    const dailyActivity: Record<string, number> = {};\n\n    for (const log of logs) {\n      actionCounts[log.action] = (actionCounts[log.action] || 0) + 1;\n\n      const date = new Date(log.details.timestamp || Date.now()).toISOString().split(\'T\')[0];\n      dailyActivity[date] = (dailyActivity[date] || 0) + 1;\n    }\n\n    return {\n      userId,\n      period: `${days} days`,\n      totalActions: logs.length,\n      actionCounts,\n      dailyActivity,\n      securityViolations: logs.filter(l => l.action === \'security_violation\').length,\n      unauthorizedAttempts: logs.filter(l => l.action === \'unauthorized_access_attempt\').length\n    };\n  }\n\n  /**\n   * Check for suspicious activity patterns\n   */\n  private async checkSuspiciousActivity(entry: AuditLogEntry): Promise<void> {\n    // Check for rapid repeated access\n    const recentLogs = await prisma.$queryRaw<any[]>`\n      SELECT COUNT(*) as count FROM audit_logs \n      WHERE user_id = ${entry.userId}\n        AND action = ${entry.action}\n        AND timestamp > NOW() - INTERVAL \'5 minutes\'\n    `;\n\n    if (recentLogs[0].count > 20) {\n      await this.log({\n        userId: entry.userId,\n        action: \'suspicious_activity\',\n        resource: \'security\',\n        resourceId: entry.userId,\n        details: {\n          pattern: \'rapid_repeated_access\',\n          count: recentLogs[0].count,\n          action: entry.action\n        },\n        severity: \'high\',\n        requiresReview: true\n      });\n    }\n\n    // Check for access from multiple IPs\n    if (entry.ipAddress) {\n      const recentIPs = await prisma.$queryRaw<any[]>`\n        SELECT DISTINCT ip_address FROM audit_logs \n        WHERE user_id = ${entry.userId}\n          AND timestamp > NOW() - INTERVAL \'1 hour\'\n      `;\n\n      if (recentIPs.length > 3) {\n        await this.log({\n          userId: entry.userId,\n          action: \'suspicious_activity\',\n          resource: \'security\',\n          resourceId: entry.userId,\n          details: {\n            pattern: \'multiple_ip_addresses\',\n            ipCount: recentIPs.length,\n            ips: recentIPs.map(r => r.ip_address)\n          },\n          severity: \'high\',\n          requiresReview: true\n        });\n      }\n    }\n\n    // Check for unusual access times (e.g., 2 AM - 5 AM)\n    const hour = new Date().getHours();\n    if (hour >= 2 && hour <= 5 && entry.action.includes(\'data_\')) {\n      await this.log({\n        userId: entry.userId,\n        action: \'suspicious_activity\',\n        resource: \'security\',\n        resourceId: entry.userId,\n        details: {\n          pattern: \'unusual_access_time\',\n          hour,\n          action: entry.action\n        },\n        severity: \'medium\',\n        requiresReview: true\n      });\n    }\n  }\n\n  /**\n   * Send critical alert\n   */\n  private async sendCriticalAlert(entry: AuditLogEntry): Promise<void> {\n    // In production, send alerts via email, SMS, Slack, PagerDuty, etc.\n    console.error(\'[AuditLogger] CRITICAL ALERT:\', {\n      userId: entry.userId,\n      action: entry.action,\n      resource: entry.resource,\n      details: entry.details\n    });\n\n    // Store alert\n    await prisma.$executeRaw`\n      INSERT INTO security_alerts (user_id, action, details, created_at)\n      VALUES (${entry.userId}, ${entry.action}, ${JSON.stringify(entry.details)}, NOW())\n    `;\n  }\n\n  /**\n   * Generate unique log ID\n   */\n  private generateLogId(): string {\n    return `audit_${Date.now()}_${Math.random().toString(36).substr(2, 16)}`;\n  }\n\n  /**\n   * Map database row to AuditLogEntry\n   */\n  private mapToAuditLogEntry(row: any): AuditLogEntry {\n    return {\n      userId: row.user_id,\n      action: row.action,\n      resource: row.resource,\n      resourceId: row.resource_id,\n      details: row.details ? JSON.parse(row.details) : {},\n      ipAddress: row.ip_address,\n      userAgent: row.user_agent,\n      sessionId: row.session_id,\n      severity: row.severity,\n      requiresReview: row.requires_review,\n      consentId: row.consent_id\n    };\n  }\n}\n\nexport const auditLogger = new AuditLogger();\n</create-file>\n</function_calls>'}