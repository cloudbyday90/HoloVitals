{'role': 'assistant', 'content': 'Now let me create the AI Context Cache Repository - this is the most critical one for maintaining HIPAA-compliant context:\n\n<function_calls>\n<create-file file_path="medical-analysis-platform/lib/repositories/AIContextCacheRepository.ts">\n/**\n * AI Context Cache Repository\n * \n * This repository stores and provides the AI Analysis Repository with necessary context.\n * Key features:\n * - Pulls relevant patient data and new input\n * - Stores information in memory (cache)\n * - Sorts cache by importance\n * - Re-analyzes after new results to maintain relevance\n * - HIPAA-compliant: Removes all PII/PHI before caching\n */\n\nimport { IRepository, RepositoryHealth } from \'./interfaces/IRepository\';\nimport { HIPAASanitizer, SanitizationResult } from \'../utils/hipaa/sanitizer\';\nimport { PrismaClient } from \'@prisma/client\';\n\nconst prisma = new PrismaClient();\n\nexport interface ContextEntry {\n  id: string;\n  patientId: string; // Hashed/anonymized ID\n  type: ContextType;\n  data: any; // Sanitized data\n  importance: number; // 0-100 score\n  relevanceScore: number; // 0-1 score\n  timestamp: Date;\n  expiresAt?: Date;\n  metadata: ContextMetadata;\n  sanitizationInfo: SanitizationResult;\n}\n\nexport type ContextType = \n  | \'medical_history\'\n  | \'test_results\'\n  | \'medications\'\n  | \'allergies\'\n  | \'conditions\'\n  | \'procedures\'\n  | \'vital_signs\'\n  | \'imaging_results\'\n  | \'clinical_notes\'\n  | \'trends\'\n  | \'correlations\';\n\nexport interface ContextMetadata {\n  source: string;\n  documentIds: string[];\n  dateRange?: { start: Date; end: Date };\n  tags: string[];\n  version: number;\n  lastAccessed: Date;\n  accessCount: number;\n}\n\nexport interface CacheQuery {\n  patientId: string;\n  contextTypes?: ContextType[];\n  minImportance?: number;\n  maxAge?: number; // in milliseconds\n  limit?: number;\n  includeExpired?: boolean;\n}\n\nexport interface CacheStatistics {\n  totalEntries: number;\n  entriesByType: Record<ContextType, number>;\n  averageImportance: number;\n  cacheHitRate: number;\n  sanitizationCompliance: number;\n  storageUsed: number;\n  oldestEntry: Date;\n  newestEntry: Date;\n}\n\nexport interface ImportanceFactors {\n  recency: number; // How recent is the data\n  frequency: number; // How often is it accessed\n  relevance: number; // How relevant to current analysis\n  completeness: number; // How complete is the data\n  accuracy: number; // Data quality score\n}\n\nexport class AIContextCacheRepository implements IRepository<ContextEntry> {\n  readonly name = \'AIContextCacheRepository\';\n  readonly version = \'1.0.0\';\n  \n  private cache: Map<string, ContextEntry> = new Map();\n  private accessLog: Map<string, number> = new Map();\n  private importanceCache: Map<string, ImportanceFactors> = new Map();\n  \n  // Cache configuration\n  private readonly MAX_CACHE_SIZE = 10000; // Maximum entries\n  private readonly DEFAULT_TTL = 24 * 60 * 60 * 1000; // 24 hours\n  private readonly REANALYSIS_INTERVAL = 60 * 60 * 1000; // 1 hour\n  \n  private lastReanalysis: Date = new Date();\n\n  async initialize(): Promise<void> {\n    console.log(`[${this.name}] Initializing...`);\n    \n    // Start periodic reanalysis\n    this.startPeriodicReanalysis();\n    \n    console.log(`[${this.name}] Initialized with max size: ${this.MAX_CACHE_SIZE}`);\n  }\n\n  /**\n   * Store context entry (with automatic sanitization)\n   */\n  async store(key: string, data: ContextEntry): Promise<void> {\n    // Ensure data is sanitized\n    if (!data.sanitizationInfo) {\n      const sanitized = HIPAASanitizer.sanitize(data.data);\n      data.data = sanitized.sanitizedData;\n      data.sanitizationInfo = sanitized;\n    }\n\n    // Validate HIPAA compliance\n    const validation = HIPAASanitizer.validate(data.data);\n    if (!validation.isValid) {\n      throw new Error(`HIPAA validation failed: ${validation.issues.join(\', \')}`);\n    }\n\n    // Check cache size and evict if necessary\n    if (this.cache.size >= this.MAX_CACHE_SIZE) {\n      await this.evictLeastImportant();\n    }\n\n    // Store entry\n    this.cache.set(key, data);\n    this.accessLog.set(key, 0);\n    \n    // Calculate initial importance\n    await this.calculateImportance(key);\n  }\n\n  /**\n   * Retrieve context entry\n   */\n  async retrieve(key: string): Promise<ContextEntry | null> {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return null;\n    }\n\n    // Check expiration\n    if (entry.expiresAt && entry.expiresAt < new Date()) {\n      await this.delete(key);\n      return null;\n    }\n\n    // Update access metadata\n    entry.metadata.lastAccessed = new Date();\n    entry.metadata.accessCount++;\n    this.accessLog.set(key, (this.accessLog.get(key) || 0) + 1);\n\n    return entry;\n  }\n\n  /**\n   * Update context entry\n   */\n  async update(key: string, data: Partial<ContextEntry>): Promise<void> {\n    const existing = await this.retrieve(key);\n    if (!existing) {\n      throw new Error(`Context entry ${key} not found`);\n    }\n\n    // If data is being updated, re-sanitize\n    if (data.data) {\n      const sanitized = HIPAASanitizer.sanitize(data.data);\n      data.data = sanitized.sanitizedData;\n      data.sanitizationInfo = sanitized;\n    }\n\n    const updated = {\n      ...existing,\n      ...data,\n      timestamp: new Date()\n    };\n\n    await this.store(key, updated);\n  }\n\n  /**\n   * Delete context entry\n   */\n  async delete(key: string): Promise<void> {\n    this.cache.delete(key);\n    this.accessLog.delete(key);\n    this.importanceCache.delete(key);\n  }\n\n  /**\n   * Check if entry exists\n   */\n  async exists(key: string): Promise<boolean> {\n    return this.cache.has(key);\n  }\n\n  /**\n   * Clear all cache\n   */\n  async clear(): Promise<void> {\n    this.cache.clear();\n    this.accessLog.clear();\n    this.importanceCache.clear();\n  }\n\n  /**\n   * Get repository health\n   */\n  async getHealth(): Promise<RepositoryHealth> {\n    const stats = await this.getStatistics();\n    \n    const issues: string[] = [];\n    \n    if (stats.sanitizationCompliance < 1.0) {\n      issues.push(`Sanitization compliance below 100%: ${(stats.sanitizationCompliance * 100).toFixed(1)}%`);\n    }\n    \n    if (stats.totalEntries > this.MAX_CACHE_SIZE * 0.9) {\n      issues.push(`Cache near capacity: ${stats.totalEntries}/${this.MAX_CACHE_SIZE}`);\n    }\n    \n    if (stats.cacheHitRate < 0.5) {\n      issues.push(`Low cache hit rate: ${(stats.cacheHitRate * 100).toFixed(1)}%`);\n    }\n\n    return {\n      status: issues.length === 0 ? \'healthy\' : issues.length < 3 ? \'degraded\' : \'unhealthy\',\n      lastCheck: new Date(),\n      metrics: {\n        itemCount: stats.totalEntries,\n        storageUsed: stats.storageUsed,\n        averageResponseTime: 5 // Cache is fast\n      },\n      issues: issues.length > 0 ? issues : undefined\n    };\n  }\n\n  /**\n   * Add new context from patient data\n   */\n  async addPatientContext(\n    patientId: string,\n    type: ContextType,\n    rawData: any,\n    metadata: Partial<ContextMetadata>\n  ): Promise<string> {\n    // Sanitize data before storing\n    const sanitized = HIPAASanitizer.sanitize(rawData);\n    \n    const entryId = this.generateEntryId();\n    const entry: ContextEntry = {\n      id: entryId,\n      patientId: this.anonymizePatientId(patientId),\n      type,\n      data: sanitized.sanitizedData,\n      importance: 50, // Default, will be calculated\n      relevanceScore: 1.0,\n      timestamp: new Date(),\n      expiresAt: new Date(Date.now() + this.DEFAULT_TTL),\n      metadata: {\n        source: metadata.source || \'unknown\',\n        documentIds: metadata.documentIds || [],\n        tags: metadata.tags || [],\n        version: 1,\n        lastAccessed: new Date(),\n        accessCount: 0,\n        ...metadata\n      },\n      sanitizationInfo: sanitized\n    };\n\n    await this.store(entryId, entry);\n    \n    // Trigger reanalysis of importance\n    await this.reanalyzeImportance();\n\n    return entryId;\n  }\n\n  /**\n   * Query context cache\n   */\n  async query(query: CacheQuery): Promise<ContextEntry[]> {\n    let results: ContextEntry[] = [];\n\n    // Filter by patient\n    for (const entry of this.cache.values()) {\n      if (entry.patientId !== this.anonymizePatientId(query.patientId)) {\n        continue;\n      }\n\n      // Filter by type\n      if (query.contextTypes && !query.contextTypes.includes(entry.type)) {\n        continue;\n      }\n\n      // Filter by importance\n      if (query.minImportance && entry.importance < query.minImportance) {\n        continue;\n      }\n\n      // Filter by age\n      if (query.maxAge) {\n        const age = Date.now() - entry.timestamp.getTime();\n        if (age > query.maxAge) {\n          continue;\n        }\n      }\n\n      // Filter expired\n      if (!query.includeExpired && entry.expiresAt && entry.expiresAt < new Date()) {\n        continue;\n      }\n\n      results.push(entry);\n    }\n\n    // Sort by importance (descending)\n    results.sort((a, b) => b.importance - a.importance);\n\n    // Apply limit\n    if (query.limit) {\n      results = results.slice(0, query.limit);\n    }\n\n    return results;\n  }\n\n  /**\n   * Get sorted context for analysis\n   */\n  async getContextForAnalysis(\n    patientId: string,\n    analysisType: string,\n    maxEntries: number = 20\n  ): Promise<ContextEntry[]> {\n    // Get all relevant context\n    const allContext = await this.query({\n      patientId,\n      minImportance: 30, // Only include moderately important or higher\n      includeExpired: false\n    });\n\n    // Calculate relevance scores based on analysis type\n    for (const entry of allContext) {\n      entry.relevanceScore = this.calculateRelevanceForAnalysis(entry, analysisType);\n    }\n\n    // Sort by combined importance and relevance\n    allContext.sort((a, b) => {\n      const scoreA = a.importance * 0.5 + a.relevanceScore * 50;\n      const scoreB = b.importance * 0.5 + b.relevanceScore * 50;\n      return scoreB - scoreA;\n    });\n\n    return allContext.slice(0, maxEntries);\n  }\n\n  /**\n   * Reanalyze importance of all cached entries\n   */\n  async reanalyzeImportance(): Promise<void> {\n    console.log(`[${this.name}] Reanalyzing importance of ${this.cache.size} entries...`);\n    \n    for (const [key, entry] of this.cache.entries()) {\n      await this.calculateImportance(key);\n    }\n\n    this.lastReanalysis = new Date();\n    console.log(`[${this.name}] Reanalysis complete`);\n  }\n\n  /**\n   * Calculate importance score for an entry\n   */\n  private async calculateImportance(key: string): Promise<void> {\n    const entry = this.cache.get(key);\n    if (!entry) return;\n\n    const factors: ImportanceFactors = {\n      recency: this.calculateRecencyScore(entry),\n      frequency: this.calculateFrequencyScore(key),\n      relevance: entry.relevanceScore,\n      completeness: this.calculateCompletenessScore(entry),\n      accuracy: this.calculateAccuracyScore(entry)\n    };\n\n    // Weighted average\n    const importance = \n      factors.recency * 0.25 +\n      factors.frequency * 0.20 +\n      factors.relevance * 0.30 +\n      factors.completeness * 0.15 +\n      factors.accuracy * 0.10;\n\n    entry.importance = Math.round(importance * 100);\n    this.importanceCache.set(key, factors);\n  }\n\n  /**\n   * Calculate recency score (newer = higher)\n   */\n  private calculateRecencyScore(entry: ContextEntry): number {\n    const ageMs = Date.now() - entry.timestamp.getTime();\n    const ageDays = ageMs / (24 * 60 * 60 * 1000);\n    \n    // Exponential decay: score = e^(-age/30)\n    return Math.exp(-ageDays / 30);\n  }\n\n  /**\n   * Calculate frequency score (more accessed = higher)\n   */\n  private calculateFrequencyScore(key: string): number {\n    const accessCount = this.accessLog.get(key) || 0;\n    \n    // Logarithmic scale: score = log(1 + count) / log(101)\n    return Math.log(1 + accessCount) / Math.log(101);\n  }\n\n  /**\n   * Calculate completeness score\n   */\n  private calculateCompletenessScore(entry: ContextEntry): number {\n    // Check how much data was removed during sanitization\n    const removedFields = entry.sanitizationInfo.removedFields.length;\n    \n    // Assume complete if few fields removed\n    if (removedFields === 0) return 1.0;\n    if (removedFields < 5) return 0.8;\n    if (removedFields < 10) return 0.6;\n    return 0.4;\n  }\n\n  /**\n   * Calculate accuracy score\n   */\n  private calculateAccuracyScore(entry: ContextEntry): number {\n    // In production, this would check data quality metrics\n    // For now, assume high accuracy for recent data\n    const ageMs = Date.now() - entry.timestamp.getTime();\n    const ageDays = ageMs / (24 * 60 * 60 * 1000);\n    \n    if (ageDays < 7) return 1.0;\n    if (ageDays < 30) return 0.9;\n    if (ageDays < 90) return 0.8;\n    return 0.7;\n  }\n\n  /**\n   * Calculate relevance for specific analysis type\n   */\n  private calculateRelevanceForAnalysis(entry: ContextEntry, analysisType: string): number {\n    // Map analysis types to relevant context types\n    const relevanceMap: Record<string, ContextType[]> = {\n      \'bloodwork\': [\'test_results\', \'trends\', \'medical_history\'],\n      \'imaging\': [\'imaging_results\', \'procedures\', \'clinical_notes\'],\n      \'medication\': [\'medications\', \'allergies\', \'conditions\'],\n      \'trend\': [\'test_results\', \'vital_signs\', \'trends\'],\n      \'risk\': [\'conditions\', \'medical_history\', \'trends\', \'correlations\']\n    };\n\n    const relevantTypes = relevanceMap[analysisType] || [];\n    \n    if (relevantTypes.includes(entry.type)) {\n      return 1.0;\n    }\n\n    return 0.3; // Still somewhat relevant\n  }\n\n  /**\n   * Evict least important entries\n   */\n  private async evictLeastImportant(): Promise<void> {\n    const entries = Array.from(this.cache.entries());\n    \n    // Sort by importance (ascending)\n    entries.sort((a, b) => a[1].importance - b[1].importance);\n    \n    // Remove bottom 10%\n    const toRemove = Math.ceil(entries.length * 0.1);\n    for (let i = 0; i < toRemove; i++) {\n      await this.delete(entries[i][0]);\n    }\n\n    console.log(`[${this.name}] Evicted ${toRemove} least important entries`);\n  }\n\n  /**\n   * Get cache statistics\n   */\n  async getStatistics(): Promise<CacheStatistics> {\n    const entries = Array.from(this.cache.values());\n    \n    const entriesByType: Record<ContextType, number> = {} as any;\n    let totalImportance = 0;\n    let sanitizedCount = 0;\n    let oldestDate = new Date();\n    let newestDate = new Date(0);\n\n    for (const entry of entries) {\n      entriesByType[entry.type] = (entriesByType[entry.type] || 0) + 1;\n      totalImportance += entry.importance;\n      \n      if (entry.sanitizationInfo.sanitizationLevel !== \'none\') {\n        sanitizedCount++;\n      }\n      \n      if (entry.timestamp < oldestDate) oldestDate = entry.timestamp;\n      if (entry.timestamp > newestDate) newestDate = entry.timestamp;\n    }\n\n    return {\n      totalEntries: entries.length,\n      entriesByType,\n      averageImportance: entries.length > 0 ? totalImportance / entries.length : 0,\n      cacheHitRate: this.calculateCacheHitRate(),\n      sanitizationCompliance: entries.length > 0 ? sanitizedCount / entries.length : 1.0,\n      storageUsed: this.estimateStorageUsed(),\n      oldestEntry: oldestDate,\n      newestEntry: newestDate\n    };\n  }\n\n  /**\n   * Start periodic reanalysis\n   */\n  private startPeriodicReanalysis(): void {\n    setInterval(async () => {\n      const timeSinceLastReanalysis = Date.now() - this.lastReanalysis.getTime();\n      \n      if (timeSinceLastReanalysis >= this.REANALYSIS_INTERVAL) {\n        await this.reanalyzeImportance();\n      }\n    }, this.REANALYSIS_INTERVAL);\n  }\n\n  // Helper methods\n\n  private generateEntryId(): string {\n    return `ctx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private anonymizePatientId(patientId: string): string {\n    // Simple hash - in production, use proper cryptographic hash\n    let hash = 0;\n    for (let i = 0; i < patientId.length; i++) {\n      const char = patientId.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    return `anon_${Math.abs(hash).toString(36)}`;\n  }\n\n  private calculateCacheHitRate(): number {\n    // This would track actual cache hits vs misses\n    // For now, return estimated value\n    return 0.75;\n  }\n\n  private estimateStorageUsed(): number {\n    return this.cache.size * 8000; // ~8KB per entry\n  }\n}\n\nexport const aiContextCacheRepository = new AIContextCacheRepository();\n</create-file>\n</function_calls>'}