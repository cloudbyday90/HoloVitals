{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/errors/ErrorLogger.ts">\n/**\n * Error Logging Service\n * Centralized error logging with different severity levels\n */\n\nimport { prisma } from \'../prisma\';\nimport { AppError, getErrorDetails } from \'./AppError\';\n\n// ============================================================================\n// ERROR SEVERITY LEVELS\n// ============================================================================\n\nexport enum ErrorSeverity {\n  LOW = \'LOW\',\n  MEDIUM = \'MEDIUM\',\n  HIGH = \'HIGH\',\n  CRITICAL = \'CRITICAL\',\n}\n\n// ============================================================================\n// ERROR LOG ENTRY\n// ============================================================================\n\nexport interface ErrorLogEntry {\n  id?: string;\n  severity: ErrorSeverity;\n  message: string;\n  code?: string;\n  statusCode?: number;\n  stack?: string;\n  details?: any;\n  userId?: string;\n  requestId?: string;\n  endpoint?: string;\n  method?: string;\n  userAgent?: string;\n  ipAddress?: string;\n  timestamp: Date;\n}\n\n// ============================================================================\n// ERROR LOGGER SERVICE\n// ============================================================================\n\nexport class ErrorLogger {\n  private static instance: ErrorLogger;\n\n  private constructor() {}\n\n  public static getInstance(): ErrorLogger {\n    if (!ErrorLogger.instance) {\n      ErrorLogger.instance = new ErrorLogger();\n    }\n    return ErrorLogger.instance;\n  }\n\n  /**\n   * Log error to database and console\n   */\n  public async logError(\n    error: Error,\n    context?: {\n      userId?: string;\n      requestId?: string;\n      endpoint?: string;\n      method?: string;\n      userAgent?: string;\n      ipAddress?: string;\n    }\n  ): Promise<void> {\n    const severity = this.determineSeverity(error);\n    const details = getErrorDetails(error);\n\n    const logEntry: ErrorLogEntry = {\n      severity,\n      message: error.message,\n      code: details.code,\n      statusCode: details.statusCode,\n      stack: details.stack,\n      details: details.details,\n      userId: context?.userId,\n      requestId: context?.requestId,\n      endpoint: context?.endpoint,\n      method: context?.method,\n      userAgent: context?.userAgent,\n      ipAddress: context?.ipAddress,\n      timestamp: new Date(),\n    };\n\n    // Log to console\n    this.logToConsole(logEntry);\n\n    // Log to database\n    await this.logToDatabase(logEntry);\n\n    // Send alerts for critical errors\n    if (severity === ErrorSeverity.CRITICAL) {\n      await this.sendCriticalAlert(logEntry);\n    }\n  }\n\n  /**\n   * Determine error severity\n   */\n  private determineSeverity(error: Error): ErrorSeverity {\n    if (error instanceof AppError) {\n      // Critical errors (system failures)\n      if (!error.isOperational || error.statusCode >= 500) {\n        return ErrorSeverity.CRITICAL;\n      }\n\n      // High severity (authorization, HIPAA violations)\n      if (\n        error.code === \'HIPAA_VIOLATION\' ||\n        error.code === \'PHI_ACCESS_ERROR\' ||\n        error.code === \'AUTHORIZATION_ERROR\'\n      ) {\n        return ErrorSeverity.HIGH;\n      }\n\n      // Medium severity (validation, not found)\n      if (\n        error.statusCode === 400 ||\n        error.statusCode === 404 ||\n        error.statusCode === 409\n      ) {\n        return ErrorSeverity.MEDIUM;\n      }\n\n      // Low severity (rate limiting, etc.)\n      return ErrorSeverity.LOW;\n    }\n\n    // Unknown errors are critical\n    return ErrorSeverity.CRITICAL;\n  }\n\n  /**\n   * Log to console with appropriate formatting\n   */\n  private logToConsole(entry: ErrorLogEntry): void {\n    const timestamp = entry.timestamp.toISOString();\n    const prefix = `[${timestamp}] [${entry.severity}]`;\n\n    switch (entry.severity) {\n      case ErrorSeverity.CRITICAL:\n        console.error(`${prefix} ðŸ”´ CRITICAL ERROR:`, {\n          message: entry.message,\n          code: entry.code,\n          statusCode: entry.statusCode,\n          endpoint: entry.endpoint,\n          userId: entry.userId,\n          stack: entry.stack,\n        });\n        break;\n\n      case ErrorSeverity.HIGH:\n        console.error(`${prefix} ðŸŸ  HIGH SEVERITY:`, {\n          message: entry.message,\n          code: entry.code,\n          endpoint: entry.endpoint,\n          userId: entry.userId,\n        });\n        break;\n\n      case ErrorSeverity.MEDIUM:\n        console.warn(`${prefix} ðŸŸ¡ MEDIUM SEVERITY:`, {\n          message: entry.message,\n          code: entry.code,\n          endpoint: entry.endpoint,\n        });\n        break;\n\n      case ErrorSeverity.LOW:\n        console.log(`${prefix} ðŸŸ¢ LOW SEVERITY:`, {\n          message: entry.message,\n          code: entry.code,\n        });\n        break;\n    }\n  }\n\n  /**\n   * Log to database\n   */\n  private async logToDatabase(entry: ErrorLogEntry): Promise<void> {\n    try {\n      await prisma.errorLog.create({\n        data: {\n          severity: entry.severity,\n          message: entry.message,\n          code: entry.code,\n          statusCode: entry.statusCode,\n          stack: entry.stack,\n          details: entry.details ? JSON.stringify(entry.details) : null,\n          userId: entry.userId,\n          requestId: entry.requestId,\n          endpoint: entry.endpoint,\n          method: entry.method,\n          userAgent: entry.userAgent,\n          ipAddress: entry.ipAddress,\n          timestamp: entry.timestamp,\n        },\n      });\n    } catch (dbError) {\n      // If database logging fails, at least log to console\n      console.error(\'Failed to log error to database:\', dbError);\n      console.error(\'Original error:\', entry);\n    }\n  }\n\n  /**\n   * Send critical error alerts\n   */\n  private async sendCriticalAlert(entry: ErrorLogEntry): Promise<void> {\n    // TODO: Implement alert mechanism (email, Slack, PagerDuty, etc.)\n    console.error(\'ðŸš¨ CRITICAL ALERT:\', {\n      message: entry.message,\n      code: entry.code,\n      endpoint: entry.endpoint,\n      timestamp: entry.timestamp,\n    });\n\n    // Create notification in database\n    try {\n      await prisma.notification.create({\n        data: {\n          type: \'CRITICAL_ERROR\',\n          title: \'Critical System Error\',\n          message: `${entry.message} (${entry.code})`,\n          severity: \'CRITICAL\',\n          metadata: JSON.stringify({\n            errorCode: entry.code,\n            endpoint: entry.endpoint,\n            timestamp: entry.timestamp,\n          }),\n          createdAt: new Date(),\n        },\n      });\n    } catch (error) {\n      console.error(\'Failed to create critical error notification:\', error);\n    }\n  }\n\n  /**\n   * Get recent errors\n   */\n  public async getRecentErrors(\n    limit: number = 100,\n    severity?: ErrorSeverity\n  ): Promise<ErrorLogEntry[]> {\n    const errors = await prisma.errorLog.findMany({\n      where: severity ? { severity } : undefined,\n      orderBy: { timestamp: \'desc\' },\n      take: limit,\n    });\n\n    return errors.map(error => ({\n      id: error.id,\n      severity: error.severity as ErrorSeverity,\n      message: error.message,\n      code: error.code || undefined,\n      statusCode: error.statusCode || undefined,\n      stack: error.stack || undefined,\n      details: error.details ? JSON.parse(error.details) : undefined,\n      userId: error.userId || undefined,\n      requestId: error.requestId || undefined,\n      endpoint: error.endpoint || undefined,\n      method: error.method || undefined,\n      userAgent: error.userAgent || undefined,\n      ipAddress: error.ipAddress || undefined,\n      timestamp: error.timestamp,\n    }));\n  }\n\n  /**\n   * Get error statistics\n   */\n  public async getErrorStats(timeRange: number = 24): Promise<{\n    total: number;\n    bySeverity: Record<ErrorSeverity, number>;\n    byCode: Record<string, number>;\n    byEndpoint: Record<string, number>;\n  }> {\n    const since = new Date(Date.now() - timeRange * 60 * 60 * 1000);\n\n    const errors = await prisma.errorLog.findMany({\n      where: {\n        timestamp: { gte: since },\n      },\n      select: {\n        severity: true,\n        code: true,\n        endpoint: true,\n      },\n    });\n\n    const stats = {\n      total: errors.length,\n      bySeverity: {\n        [ErrorSeverity.LOW]: 0,\n        [ErrorSeverity.MEDIUM]: 0,\n        [ErrorSeverity.HIGH]: 0,\n        [ErrorSeverity.CRITICAL]: 0,\n      },\n      byCode: {} as Record<string, number>,\n      byEndpoint: {} as Record<string, number>,\n    };\n\n    errors.forEach(error => {\n      // Count by severity\n      stats.bySeverity[error.severity as ErrorSeverity]++;\n\n      // Count by code\n      if (error.code) {\n        stats.byCode[error.code] = (stats.byCode[error.code] || 0) + 1;\n      }\n\n      // Count by endpoint\n      if (error.endpoint) {\n        stats.byEndpoint[error.endpoint] = (stats.byEndpoint[error.endpoint] || 0) + 1;\n      }\n    });\n\n    return stats;\n  }\n\n  /**\n   * Clean up old error logs\n   */\n  public async cleanupOldLogs(daysToKeep: number = 90): Promise<number> {\n    const cutoffDate = new Date(Date.now() - daysToKeep * 24 * 60 * 60 * 1000);\n\n    const result = await prisma.errorLog.deleteMany({\n      where: {\n        timestamp: { lt: cutoffDate },\n        severity: {\n          in: [ErrorSeverity.LOW, ErrorSeverity.MEDIUM],\n        },\n      },\n    });\n\n    console.log(`Cleaned up ${result.count} old error logs`);\n    return result.count;\n  }\n}\n\n// Export singleton instance\nexport const errorLogger = ErrorLogger.getInstance();\n</create-file>\n</function_calls>'}