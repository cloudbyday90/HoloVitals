{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/services/DevQARepositoryCoordinator.ts">\n/**\n * Development & QA Repository Coordinator\n * \n * Orchestrates interactions between Bug Repository, Development & Enhancement Repository,\n * and Development & QA Processing Repository. Manages data flow and automated workflows.\n */\n\nimport BugRepositoryService from \'./BugRepositoryService\';\nimport DevelopmentEnhancementService from \'./DevelopmentEnhancementService\';\nimport DevQAProcessingService from \'./DevQAProcessingService\';\nimport { BugSeverity, BugStatus, FeatureType, FeaturePriority, EnvironmentType } from \'@prisma/client\';\n\ninterface WorkflowResult {\n  success: boolean;\n  message: string;\n  data?: any;\n}\n\nexport class DevQARepositoryCoordinator {\n  private bugService: BugRepositoryService;\n  private enhancementService: DevelopmentEnhancementService;\n  private devQAService: DevQAProcessingService;\n\n  constructor() {\n    this.bugService = new BugRepositoryService();\n    this.enhancementService = new DevelopmentEnhancementService();\n    this.devQAService = new DevQAProcessingService();\n  }\n\n  // ============================================================================\n  // BUG-DRIVEN WORKFLOWS\n  // ============================================================================\n\n  /**\n   * Process a new bug report through the entire workflow\n   */\n  async processBugReport(bugReport: any): Promise<WorkflowResult> {\n    try {\n      // 1. Create bug in Bug Repository\n      const bug = await this.bugService.reportBug(bugReport);\n\n      // 2. Triage the bug\n      const triageData = await this.autoTriageBug(bug.id);\n      await this.bugService.triageBug(bug.id, triageData);\n\n      // 3. If critical/high severity, create enhancement for systemic fix\n      if (bug.severity === BugSeverity.CRITICAL || bug.severity === BugSeverity.HIGH) {\n        const enhancement = await this.createEnhancementFromBug(bug.id);\n        \n        // 4. If approved, create development project\n        if (enhancement) {\n          const project = await this.createProjectFromBug(bug.id, enhancement.id);\n          \n          return {\n            success: true,\n            message: \'Bug processed and development project created\',\n            data: { bug, enhancement, project },\n          };\n        }\n      }\n\n      return {\n        success: true,\n        message: \'Bug processed and triaged\',\n        data: { bug },\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        message: `Failed to process bug: ${error.message}`,\n      };\n    }\n  }\n\n  /**\n   * Create enhancement from high-priority bug\n   */\n  async createEnhancementFromBug(bugId: string): Promise<any> {\n    const bug = await this.bugService[\'prisma\'].bug.findUnique({ where: { id: bugId } });\n    if (!bug) return null;\n\n    // Check if enhancement already exists for this bug\n    const existingEnhancements = await this.enhancementService[\'prisma\'].feature.findMany({\n      where: {\n        relatedBugs: { has: bugId },\n      },\n    });\n\n    if (existingEnhancements.length > 0) {\n      return existingEnhancements[0];\n    }\n\n    // Create enhancement\n    const enhancement = await this.enhancementService.submitFeatureRequest({\n      title: `Fix: ${bug.title}`,\n      description: `Enhancement to address bug: ${bug.description}\\n\\nOriginal Bug ID: ${bugId}`,\n      type: FeatureType.ENHANCEMENT,\n      priority: this.mapBugSeverityToPriority(bug.severity),\n      businessValue: bug.businessImpact || \'Resolves critical bug affecting users\',\n      relatedBugs: [bugId],\n      tags: [\'bug-fix\', bug.category.toLowerCase()],\n    });\n\n    // Auto-approve critical bug fixes\n    if (bug.severity === BugSeverity.CRITICAL) {\n      await this.enhancementService.evaluateFeature(enhancement.id, {\n        approved: true,\n        priority: FeaturePriority.CRITICAL,\n        feedback: \'Auto-approved due to critical bug severity\',\n        evaluatedBy: \'SYSTEM\',\n      });\n    }\n\n    return enhancement;\n  }\n\n  /**\n   * Create development project from bug\n   */\n  async createProjectFromBug(bugId: string, enhancementId?: string): Promise<any> {\n    const bug = await this.bugService[\'prisma\'].bug.findUnique({ where: { id: bugId } });\n    if (!bug) throw new Error(\'Bug not found\');\n\n    const project = await this.devQAService.createProject({\n      name: `Bug Fix: ${bug.title}`,\n      description: bug.description,\n      type: \'BUG_FIX\',\n      sourceType: \'BUG\',\n      sourceId: bugId,\n      tags: [\'bug-fix\', bug.category.toLowerCase(), bug.severity.toLowerCase()],\n    });\n\n    // Update bug status\n    await this.bugService.updateBugStatus(bugId, BugStatus.IN_PROGRESS, \'SYSTEM\');\n\n    return project;\n  }\n\n  // ============================================================================\n  // FEATURE-DRIVEN WORKFLOWS\n  // ============================================================================\n\n  /**\n   * Process a feature request through the entire workflow\n   */\n  async processFeatureRequest(featureRequest: any): Promise<WorkflowResult> {\n    try {\n      // 1. Create feature in Enhancement Repository\n      const feature = await this.enhancementService.submitFeatureRequest(featureRequest);\n\n      // 2. Perform impact analysis\n      const impact = await this.enhancementService.performImpactAnalysis(feature.id);\n\n      // 3. Auto-evaluate based on impact score\n      if (impact.overallScore >= 70) {\n        await this.enhancementService.evaluateFeature(feature.id, {\n          approved: true,\n          priority: FeaturePriority.HIGH,\n          feedback: `Auto-approved based on high impact score (${impact.overallScore})`,\n          evaluatedBy: \'SYSTEM\',\n        });\n\n        // 4. Create development project\n        const project = await this.createProjectFromFeature(feature.id);\n\n        return {\n          success: true,\n          message: \'Feature approved and development project created\',\n          data: { feature, impact, project },\n        };\n      }\n\n      return {\n        success: true,\n        message: \'Feature submitted for evaluation\',\n        data: { feature, impact },\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        message: `Failed to process feature: ${error.message}`,\n      };\n    }\n  }\n\n  /**\n   * Create development project from feature\n   */\n  async createProjectFromFeature(featureId: string): Promise<any> {\n    const feature = await this.enhancementService[\'prisma\'].feature.findUnique({ where: { id: featureId } });\n    if (!feature) throw new Error(\'Feature not found\');\n\n    const project = await this.devQAService.createProject({\n      name: feature.title,\n      description: feature.description,\n      type: \'FEATURE\',\n      sourceType: \'FEATURE\',\n      sourceId: featureId,\n      tags: [feature.type.toLowerCase(), feature.priority.toLowerCase()],\n    });\n\n    // Update feature status\n    await this.enhancementService.startDevelopment(featureId, \'SYSTEM\');\n\n    return project;\n  }\n\n  // ============================================================================\n  // DEPLOYMENT WORKFLOWS\n  // ============================================================================\n\n  /**\n   * Complete development and deploy workflow\n   */\n  async completeAndDeploy(projectId: string, deployedBy: string): Promise<WorkflowResult> {\n    try {\n      const project = await this.devQAService[\'prisma\'].developmentProject.findUnique({\n        where: { id: projectId },\n      });\n\n      if (!project) {\n        return { success: false, message: \'Project not found\' };\n      }\n\n      // 1. Run tests in QA environment\n      const testResult = await this.devQAService.runTests(projectId, {\n        environment: EnvironmentType.QA,\n        testSuite: \'full\',\n        testType: \'INTEGRATION\',\n        triggeredBy: deployedBy,\n      });\n\n      if (!testResult.success) {\n        return {\n          success: false,\n          message: \'Tests failed in QA environment\',\n          data: testResult,\n        };\n      }\n\n      // 2. Deploy to Staging\n      const stagingDeployment = await this.devQAService.deploy(projectId, {\n        environment: EnvironmentType.STAGING,\n        version: \'1.0.0\',\n        branch: \'staging\',\n        deployedBy,\n        notes: \'Automated deployment to staging\',\n      });\n\n      if (!stagingDeployment.success) {\n        return {\n          success: false,\n          message: \'Staging deployment failed\',\n          data: stagingDeployment,\n        };\n      }\n\n      // 3. Run tests in Staging\n      const stagingTestResult = await this.devQAService.runTests(projectId, {\n        environment: EnvironmentType.STAGING,\n        testSuite: \'full\',\n        testType: \'E2E\',\n        triggeredBy: deployedBy,\n      });\n\n      if (!stagingTestResult.success) {\n        return {\n          success: false,\n          message: \'Tests failed in Staging environment\',\n          data: stagingTestResult,\n        };\n      }\n\n      // 4. Update source (bug or feature) status\n      if (project.sourceType === \'BUG\' && project.sourceId) {\n        await this.bugService.updateBugStatus(project.sourceId, BugStatus.FIXED, deployedBy);\n      } else if (project.sourceType === \'FEATURE\' && project.sourceId) {\n        await this.enhancementService.completeFeature(project.sourceId, deployedBy);\n      }\n\n      // 5. Close project\n      await this.devQAService.closeProject(projectId);\n\n      return {\n        success: true,\n        message: \'Project completed and deployed successfully\',\n        data: {\n          testResult,\n          stagingDeployment,\n          stagingTestResult,\n        },\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        message: `Deployment workflow failed: ${error.message}`,\n      };\n    }\n  }\n\n  // ============================================================================\n  // MONITORING & HEALTH WORKFLOWS\n  // ============================================================================\n\n  /**\n   * Monitor system health and detect issues\n   */\n  async monitorSystemHealth(): Promise<WorkflowResult> {\n    try {\n      // 1. Monitor all environments\n      await this.devQAService.monitorAllEnvironments();\n\n      // 2. Detect system bugs\n      const bugDetection = await this.bugService.detectSystemBugs();\n\n      // 3. Process detected bugs\n      if (bugDetection.detected) {\n        for (const bug of bugDetection.bugs) {\n          await this.processBugReport({\n            title: bug.title,\n            description: bug.description,\n            source: bug.source,\n            severity: bug.severity,\n            category: bug.category,\n          });\n        }\n      }\n\n      return {\n        success: true,\n        message: \'System health monitoring completed\',\n        data: {\n          bugsDetected: bugDetection.bugs.length,\n          bugs: bugDetection.bugs,\n        },\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        message: `Health monitoring failed: ${error.message}`,\n      };\n    }\n  }\n\n  // ============================================================================\n  // REPORTING & ANALYTICS\n  // ============================================================================\n\n  /**\n   * Generate comprehensive system report\n   */\n  async generateSystemReport(): Promise<any> {\n    const [bugStats, featureStats, projectStats] = await Promise.all([\n      this.bugService.getBugStatistics(),\n      this.enhancementService.getFeatureStatistics(),\n      this.getProjectStatistics(),\n    ]);\n\n    return {\n      timestamp: new Date(),\n      bugs: bugStats,\n      features: featureStats,\n      projects: projectStats,\n      summary: {\n        openBugs: bugStats.open,\n        criticalBugs: bugStats.critical,\n        featuresInProgress: featureStats.inProgress,\n        activeProjects: projectStats.active,\n      },\n    };\n  }\n\n  /**\n   * Get high-priority items across all repositories\n   */\n  async getHighPriorityItems(): Promise<any> {\n    const [bugs, features] = await Promise.all([\n      this.bugService.getHighPriorityBugs(10),\n      this.enhancementService.getFeaturesByPriority(FeaturePriority.CRITICAL),\n    ]);\n\n    return {\n      criticalBugs: bugs.filter(b => b.severity === BugSeverity.CRITICAL),\n      highPriorityBugs: bugs.filter(b => b.severity === BugSeverity.HIGH),\n      criticalFeatures: features,\n    };\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  private async autoTriageBug(bugId: string): Promise<any> {\n    const bug = await this.bugService[\'prisma\'].bug.findUnique({ where: { id: bugId } });\n    if (!bug) throw new Error(\'Bug not found\');\n\n    // Calculate priority score\n    const priorityScore = await this.bugService.calculateBugPriorityScore(bugId);\n\n    // Determine if auto-assignment is needed\n    let assignedTo: string | undefined;\n    if (bug.severity === BugSeverity.CRITICAL) {\n      assignedTo = \'CRITICAL_TEAM\'; // Would be actual team/person ID\n    }\n\n    return {\n      severity: bug.severity,\n      category: bug.category,\n      priority: priorityScore.score,\n      assignedTo,\n    };\n  }\n\n  private mapBugSeverityToPriority(severity: BugSeverity): FeaturePriority {\n    const map = {\n      [BugSeverity.CRITICAL]: FeaturePriority.CRITICAL,\n      [BugSeverity.HIGH]: FeaturePriority.HIGH,\n      [BugSeverity.MEDIUM]: FeaturePriority.MEDIUM,\n      [BugSeverity.LOW]: FeaturePriority.LOW,\n      [BugSeverity.TRIVIAL]: FeaturePriority.BACKLOG,\n    };\n    return map[severity];\n  }\n\n  private async getProjectStatistics(): Promise<any> {\n    const projects = await this.devQAService[\'prisma\'].developmentProject.findMany();\n    \n    return {\n      total: projects.length,\n      active: projects.filter(p => [\'PLANNING\', \'DEVELOPMENT\', \'TESTING\', \'STAGING\'].includes(p.status)).length,\n      completed: projects.filter(p => p.status === \'CLOSED\').length,\n      byType: this.groupBy(projects, \'type\'),\n      byStatus: this.groupBy(projects, \'status\'),\n    };\n  }\n\n  private groupBy(array: any[], key: string): any {\n    return array.reduce((acc, item) => {\n      const value = item[key];\n      acc[value] = (acc[value] || 0) + 1;\n      return acc;\n    }, {});\n  }\n}\n\nexport default DevQARepositoryCoordinator;\n</create-file>\n</function_calls>'}