{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/services/PricingService.ts">\n/**\n * Pricing Service\n * \n * Handles all pricing calculations, cost estimations, and token conversions\n */\n\nimport {\n  SubscriptionTier,\n  TIER_CONFIGS,\n  TOKEN_COSTS,\n  TOKEN_PACKAGES,\n  FILE_ESTIMATION,\n  PRICING_RULES,\n  getTierConfig,\n  formatTokens,\n  formatFileSize,\n} from \'../config/pricing\';\n\nexport interface CostEstimation {\n  fileSize: number;\n  fileSizeFormatted: string;\n  mimeType: string;\n  estimatedTokens: number;\n  estimatedTokensFormatted: string;\n  estimatedCost: number;\n  estimatedCostFormatted: string;\n  requiresOCR: boolean;\n  requiresAnalysis: boolean;\n  canAfford: boolean;\n  currentBalance: number;\n  balanceAfter: number;\n  useFreeUpload: boolean;\n  freeUploadRemaining: number;\n  processingTime: string;\n  recommendation: string;\n}\n\nexport interface MultiMonthEstimation {\n  totalTokens: number;\n  monthlyAllocation: number;\n  monthsRequired: number;\n  monthlyProcessing: Array<{\n    month: number;\n    tokens: number;\n    percentage: number;\n  }>;\n  estimatedCompletionDate: Date;\n}\n\nexport class PricingService {\n  /**\n   * Estimate cost for file upload and processing\n   */\n  static estimateFileCost(\n    fileSize: number,\n    mimeType: string,\n    currentBalance: number,\n    tier: SubscriptionTier,\n    freeUploadUsed: number,\n    requiresOCR: boolean = true,\n    requiresAnalysis: boolean = true\n  ): CostEstimation {\n    const tierConfig = getTierConfig(tier);\n    const fileSizeMB = fileSize / (1024 * 1024);\n    \n    // Check if this upload qualifies for free upload limit\n    const freeUploadRemaining = Math.max(0, tierConfig.freeUploadLimit - freeUploadUsed);\n    const useFreeUpload = fileSize <= freeUploadRemaining;\n    \n    // Get file estimation config\n    const estimationConfig = FILE_ESTIMATION[mimeType] || FILE_ESTIMATION[\'default\'];\n    \n    // Calculate base tokens\n    let estimatedTokens = Math.ceil(fileSizeMB * estimationConfig.baseTokensPerMB);\n    \n    // Apply multipliers\n    if (requiresOCR) {\n      estimatedTokens = Math.ceil(estimatedTokens * estimationConfig.ocrMultiplier);\n    }\n    if (requiresAnalysis) {\n      estimatedTokens = Math.ceil(estimatedTokens * estimationConfig.analysisMultiplier);\n    }\n    \n    // If using free upload, tokens are free\n    if (useFreeUpload) {\n      estimatedTokens = 0;\n    }\n    \n    // Calculate cost (tokens to USD)\n    const estimatedCost = (estimatedTokens / PRICING_RULES.TOKENS_PER_DOLLAR);\n    \n    // Check if user can afford\n    const canAfford = currentBalance >= estimatedTokens;\n    const balanceAfter = currentBalance - estimatedTokens;\n    \n    // Estimate processing time (rough estimate: 1 minute per 10MB)\n    const processingMinutes = Math.ceil(fileSizeMB / 10);\n    const processingTime = processingMinutes < 60\n      ? `${processingMinutes} minutes`\n      : `${Math.ceil(processingMinutes / 60)} hours`;\n    \n    // Generate recommendation\n    let recommendation = \'\';\n    if (useFreeUpload) {\n      recommendation = \'This upload qualifies for your free upload limit. No tokens will be charged.\';\n    } else if (canAfford) {\n      recommendation = \'You have sufficient tokens to process this file immediately.\';\n    } else {\n      const tokensNeeded = estimatedTokens - currentBalance;\n      recommendation = `You need ${formatTokens(tokensNeeded)} more tokens. Consider purchasing a token package or upgrading your subscription.`;\n    }\n    \n    return {\n      fileSize,\n      fileSizeFormatted: formatFileSize(fileSize),\n      mimeType,\n      estimatedTokens,\n      estimatedTokensFormatted: formatTokens(estimatedTokens),\n      estimatedCost,\n      estimatedCostFormatted: `$${estimatedCost.toFixed(2)}`,\n      requiresOCR,\n      requiresAnalysis,\n      canAfford,\n      currentBalance,\n      balanceAfter,\n      useFreeUpload,\n      freeUploadRemaining,\n      processingTime,\n      recommendation,\n    };\n  }\n  \n  /**\n   * Calculate multi-month processing schedule\n   */\n  static calculateMultiMonthProcessing(\n    totalTokensNeeded: number,\n    currentBalance: number,\n    monthlyAllocation: number\n  ): MultiMonthEstimation {\n    const remainingTokens = totalTokensNeeded - currentBalance;\n    const monthsRequired = Math.ceil(remainingTokens / monthlyAllocation);\n    \n    const monthlyProcessing: Array<{\n      month: number;\n      tokens: number;\n      percentage: number;\n    }> = [];\n    \n    let tokensRemaining = totalTokensNeeded;\n    let month = 0;\n    \n    // First month: use current balance\n    if (currentBalance > 0) {\n      const tokensThisMonth = Math.min(currentBalance, tokensRemaining);\n      monthlyProcessing.push({\n        month: month + 1,\n        tokens: tokensThisMonth,\n        percentage: (tokensThisMonth / totalTokensNeeded) * 100,\n      });\n      tokensRemaining -= tokensThisMonth;\n      month++;\n    }\n    \n    // Subsequent months: use monthly allocation\n    while (tokensRemaining > 0) {\n      const tokensThisMonth = Math.min(monthlyAllocation, tokensRemaining);\n      monthlyProcessing.push({\n        month: month + 1,\n        tokens: tokensThisMonth,\n        percentage: (tokensThisMonth / totalTokensNeeded) * 100,\n      });\n      tokensRemaining -= tokensThisMonth;\n      month++;\n    }\n    \n    // Calculate estimated completion date\n    const estimatedCompletionDate = new Date();\n    estimatedCompletionDate.setMonth(estimatedCompletionDate.getMonth() + monthsRequired);\n    \n    return {\n      totalTokens: totalTokensNeeded,\n      monthlyAllocation,\n      monthsRequired,\n      monthlyProcessing,\n      estimatedCompletionDate,\n    };\n  }\n  \n  /**\n   * Get recommended token package for a specific need\n   */\n  static getRecommendedPackage(tokensNeeded: number): typeof TOKEN_PACKAGES[0] | null {\n    // Find the smallest package that covers the need\n    const suitablePackages = TOKEN_PACKAGES.filter(\n      pkg => (pkg.tokens + pkg.bonus) >= tokensNeeded\n    );\n    \n    if (suitablePackages.length === 0) {\n      // Return largest package if none cover the full need\n      return TOKEN_PACKAGES[TOKEN_PACKAGES.length - 1];\n    }\n    \n    // Return the smallest suitable package\n    return suitablePackages[0];\n  }\n  \n  /**\n   * Get recommended tier upgrade based on usage\n   */\n  static getRecommendedTierUpgrade(\n    currentTier: SubscriptionTier,\n    monthlyTokenUsage: number\n  ): SubscriptionTier | null {\n    const currentConfig = getTierConfig(currentTier);\n    \n    // If usage is within current tier, no upgrade needed\n    if (monthlyTokenUsage <= currentConfig.monthlyTokens) {\n      return null;\n    }\n    \n    // Check if PROFESSIONAL tier would be sufficient\n    if (currentTier === SubscriptionTier.BASIC) {\n      const professionalConfig = getTierConfig(SubscriptionTier.PROFESSIONAL);\n      if (monthlyTokenUsage <= professionalConfig.monthlyTokens) {\n        return SubscriptionTier.PROFESSIONAL;\n      }\n    }\n    \n    // Check if ENTERPRISE tier would be sufficient\n    if (currentTier !== SubscriptionTier.ENTERPRISE) {\n      const enterpriseConfig = getTierConfig(SubscriptionTier.ENTERPRISE);\n      if (monthlyTokenUsage <= enterpriseConfig.monthlyTokens) {\n        return SubscriptionTier.ENTERPRISE;\n      }\n    }\n    \n    // Already at highest tier or usage exceeds all tiers\n    return null;\n  }\n  \n  /**\n   * Calculate savings from tier upgrade\n   */\n  static calculateUpgradeSavings(\n    currentTier: SubscriptionTier,\n    targetTier: SubscriptionTier,\n    monthlyTokenUsage: number\n  ): {\n    currentMonthlyCost: number;\n    targetMonthlyCost: number;\n    monthlySavings: number;\n    annualSavings: number;\n    breakEvenMonths: number;\n  } {\n    const currentConfig = getTierConfig(currentTier);\n    const targetConfig = getTierConfig(targetTier);\n    \n    // Calculate current monthly cost (subscription + token purchases)\n    const currentTokenShortfall = Math.max(0, monthlyTokenUsage - currentConfig.monthlyTokens);\n    const currentTokenPurchaseCost = (currentTokenShortfall / PRICING_RULES.TOKENS_PER_DOLLAR);\n    const currentMonthlyCost = currentConfig.monthlyPrice + currentTokenPurchaseCost;\n    \n    // Calculate target monthly cost\n    const targetTokenShortfall = Math.max(0, monthlyTokenUsage - targetConfig.monthlyTokens);\n    const targetTokenPurchaseCost = (targetTokenShortfall / PRICING_RULES.TOKENS_PER_DOLLAR);\n    const targetMonthlyCost = targetConfig.monthlyPrice + targetTokenPurchaseCost;\n    \n    // Calculate savings\n    const monthlySavings = currentMonthlyCost - targetMonthlyCost;\n    const annualSavings = monthlySavings * 12;\n    \n    // Calculate break-even (how many months to recover upgrade cost)\n    const upgradeCost = targetConfig.monthlyPrice - currentConfig.monthlyPrice;\n    const breakEvenMonths = monthlySavings > 0 ? Math.ceil(upgradeCost / monthlySavings) : Infinity;\n    \n    return {\n      currentMonthlyCost,\n      targetMonthlyCost,\n      monthlySavings,\n      annualSavings,\n      breakEvenMonths,\n    };\n  }\n  \n  /**\n   * Validate file size against tier limits\n   */\n  static validateFileSize(\n    fileSize: number,\n    tier: SubscriptionTier\n  ): { valid: boolean; message: string } {\n    const tierConfig = getTierConfig(tier);\n    \n    if (fileSize > tierConfig.maxFileSize) {\n      return {\n        valid: false,\n        message: `File size (${formatFileSize(fileSize)}) exceeds your tier limit (${formatFileSize(tierConfig.maxFileSize)}). Please upgrade to ${tier === SubscriptionTier.BASIC ? \'Professional\' : \'Enterprise\'} tier or split the file into smaller parts.`,\n      };\n    }\n    \n    return {\n      valid: true,\n      message: \'File size is within your tier limit.\',\n    };\n  }\n  \n  /**\n   * Calculate token usage statistics\n   */\n  static calculateTokenStats(transactions: Array<{\n    type: string;\n    amount: number;\n    createdAt: Date;\n  }>): {\n    totalEarned: number;\n    totalUsed: number;\n    totalPurchased: number;\n    averageDaily: number;\n    projectedMonthly: number;\n    topUsageTypes: Array<{ type: string; tokens: number; percentage: number }>;\n  } {\n    let totalEarned = 0;\n    let totalUsed = 0;\n    let totalPurchased = 0;\n    const usageByType: Record<string, number> = {};\n    \n    transactions.forEach(tx => {\n      if (tx.amount > 0) {\n        if (tx.type === \'PURCHASE\') {\n          totalPurchased += tx.amount;\n        }\n        totalEarned += tx.amount;\n      } else {\n        totalUsed += Math.abs(tx.amount);\n        const type = tx.type || \'UNKNOWN\';\n        usageByType[type] = (usageByType[type] || 0) + Math.abs(tx.amount);\n      }\n    });\n    \n    // Calculate daily average (last 30 days)\n    const thirtyDaysAgo = new Date();\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n    const recentTransactions = transactions.filter(tx => tx.createdAt >= thirtyDaysAgo);\n    const recentUsage = recentTransactions\n      .filter(tx => tx.amount < 0)\n      .reduce((sum, tx) => sum + Math.abs(tx.amount), 0);\n    const averageDaily = recentUsage / 30;\n    const projectedMonthly = averageDaily * 30;\n    \n    // Top usage types\n    const topUsageTypes = Object.entries(usageByType)\n      .map(([type, tokens]) => ({\n        type,\n        tokens,\n        percentage: (tokens / totalUsed) * 100,\n      }))\n      .sort((a, b) => b.tokens - a.tokens)\n      .slice(0, 5);\n    \n    return {\n      totalEarned,\n      totalUsed,\n      totalPurchased,\n      averageDaily,\n      projectedMonthly,\n      topUsageTypes,\n    };\n  }\n}\n</create-file>\n</function_calls>'}