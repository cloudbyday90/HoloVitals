{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/services/context.service.ts">\nimport { Document, ExtractedData, AnalysisContext } from \'@/lib/types\';\nimport { PrismaClient } from \'@prisma/client\';\n\nconst prisma = new PrismaClient();\n\nexport class ContextBuilder {\n  /**\n   * Build comprehensive analysis context for a document\n   */\n  async buildAnalysisContext(\n    currentDocumentId: string,\n    userId: string\n  ): Promise<AnalysisContext> {\n    // 1. Get current document and its data\n    const currentDoc = await prisma.document.findUnique({\n      where: { id: currentDocumentId },\n      include: {\n        extractedData: true,\n        ocrResults: true\n      }\n    });\n\n    if (!currentDoc) {\n      throw new Error(\'Document not found\');\n    }\n\n    // 2. Find related documents\n    const relatedDocs = await this.findRelatedDocuments(\n      currentDocumentId,\n      currentDoc.documentType || \'other\',\n      currentDoc.documentDate || new Date()\n    );\n\n    // 3. Get historical data for trend analysis\n    const historicalData = await this.getHistoricalData(\n      userId,\n      currentDoc.documentType || \'other\',\n      currentDoc.documentDate || new Date()\n    );\n\n    // 4. Get metadata\n    const metadata = await this.getMetadata(userId);\n\n    return {\n      currentDocument: currentDoc as any,\n      currentData: currentDoc.extractedData as any,\n      relatedDocuments: relatedDocs as any,\n      historicalTrends: historicalData,\n      similarDocuments: [], // TODO: Implement semantic similarity\n      metadata\n    };\n  }\n\n  /**\n   * Find documents related to the current document\n   */\n  async findRelatedDocuments(\n    documentId: string,\n    documentType: string,\n    documentDate: Date\n  ): Promise<Document[]> {\n    // Find explicitly linked documents\n    const linked = await prisma.document.findMany({\n      where: {\n        OR: [\n          {\n            sourceLinks: {\n              some: {\n                targetDocumentId: documentId\n              }\n            }\n          },\n          {\n            targetLinks: {\n              some: {\n                sourceDocumentId: documentId\n              }\n            }\n          }\n        ]\n      }\n    });\n\n    // Find temporally related documents (same type within 30 days)\n    const thirtyDaysAgo = new Date(documentDate);\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n    \n    const thirtyDaysAfter = new Date(documentDate);\n    thirtyDaysAfter.setDate(thirtyDaysAfter.getDate() + 30);\n\n    const temporal = await prisma.document.findMany({\n      where: {\n        id: { not: documentId },\n        documentType,\n        documentDate: {\n          gte: thirtyDaysAgo,\n          lte: thirtyDaysAfter\n        }\n      },\n      take: 5\n    });\n\n    // Combine and deduplicate\n    const allDocs = [...linked, ...temporal];\n    const uniqueDocs = Array.from(\n      new Map(allDocs.map(doc => [doc.id, doc])).values()\n    );\n\n    return uniqueDocs as any;\n  }\n\n  /**\n   * Get historical data for trend analysis\n   */\n  async getHistoricalData(\n    userId: string,\n    documentType: string,\n    beforeDate: Date\n  ): Promise<any[]> {\n    const historicalDocs = await prisma.document.findMany({\n      where: {\n        userId,\n        documentType,\n        documentDate: {\n          lt: beforeDate\n        },\n        status: \'completed\'\n      },\n      include: {\n        extractedData: true\n      },\n      orderBy: {\n        documentDate: \'desc\'\n      },\n      take: 10\n    });\n\n    return historicalDocs;\n  }\n\n  /**\n   * Get user\'s document metadata\n   */\n  async getMetadata(userId: string) {\n    const documents = await prisma.document.findMany({\n      where: { userId },\n      select: {\n        documentDate: true,\n        documentType: true\n      }\n    });\n\n    const dates = documents\n      .map(d => d.documentDate)\n      .filter((d): d is Date => d !== null)\n      .sort((a, b) => a.getTime() - b.getTime());\n\n    const types = Array.from(\n      new Set(documents.map(d => d.documentType).filter(Boolean))\n    );\n\n    return {\n      totalDocuments: documents.length,\n      dateRange: {\n        earliest: dates[0] || new Date(),\n        latest: dates[dates.length - 1] || new Date()\n      },\n      documentTypes: types as string[]\n    };\n  }\n\n  /**\n   * Link two documents together\n   */\n  async linkDocuments(\n    sourceId: string,\n    targetId: string,\n    relationshipType: string\n  ): Promise<void> {\n    await prisma.documentLink.create({\n      data: {\n        sourceDocumentId: sourceId,\n        targetDocumentId: targetId,\n        relationshipType\n      }\n    });\n  }\n\n  /**\n   * Find documents by semantic similarity (placeholder for vector search)\n   */\n  async findSimilarDocuments(\n    documentId: string,\n    limit: number = 5\n  ): Promise<Document[]> {\n    // TODO: Implement vector similarity search\n    // This would use document embeddings to find semantically similar documents\n    return [];\n  }\n}\n\nexport const contextBuilder = new ContextBuilder();\n</create-file>\n</function_calls>'}