{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="src/services/HIPAAComplianceService.ts">\n/**\n * HIPAA Compliance Service\n * \n * Central service for HIPAA compliance verification, rule enforcement,\n * and violation detection. Acts as the authoritative source for all\n * HIPAA-related compliance in HoloVitals.\n */\n\nimport { PrismaClient, HIPAARule, HIPAARuleCategory, ComplianceCheck, ComplianceCheckType, ComplianceCheckStatus, ComplianceViolation, ViolationSeverity, ViolationStatus } from \'@prisma/client\';\nimport OpenAI from \'openai\';\n\nconst prisma = new PrismaClient();\nconst openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });\n\ninterface ComplianceCheckRequest {\n  action: string;\n  repository: string;\n  targetType: string;\n  targetId: string;\n  targetDetails?: any;\n  rules?: string[]; // Specific rules to check, or all if not specified\n  triggeredBy: string;\n}\n\ninterface ComplianceCheckResult {\n  passed: boolean;\n  status: ComplianceCheckStatus;\n  score: number; // 0-100\n  violations: ComplianceViolation[];\n  warnings: string[];\n  recommendations: string[];\n  blocked: boolean;\n  requiresReview: boolean;\n}\n\ninterface PHISanitizationResult {\n  sanitized: any;\n  phiDetected: boolean;\n  phiRemoved: string[];\n  sanitizationLog: string[];\n}\n\nexport class HIPAAComplianceService {\n  /**\n   * Check compliance for an action\n   */\n  async checkCompliance(request: ComplianceCheckRequest): Promise<ComplianceCheckResult> {\n    // Create compliance check record\n    const check = await prisma.complianceCheck.create({\n      data: {\n        checkType: this.determineCheckType(request.action),\n        targetType: request.targetType,\n        targetId: request.targetId,\n        targetDetails: request.targetDetails,\n        rulesChecked: request.rules || [],\n        repository: request.repository,\n        action: request.action,\n        triggeredBy: request.triggeredBy,\n        status: ComplianceCheckStatus.RUNNING,\n      },\n    });\n\n    try {\n      // Get applicable HIPAA rules\n      const rules = await this.getApplicableRules(request);\n\n      // Perform compliance checks\n      const violations: ComplianceViolation[] = [];\n      const warnings: string[] = [];\n      const recommendations: string[] = [];\n\n      for (const rule of rules) {\n        const ruleCheck = await this.checkRule(rule, request);\n        \n        if (ruleCheck.violated) {\n          const violation = await this.createViolation({\n            ruleId: rule.id,\n            checkId: check.id,\n            ...ruleCheck.violationDetails,\n          });\n          violations.push(violation);\n        }\n\n        if (ruleCheck.warnings) {\n          warnings.push(...ruleCheck.warnings);\n        }\n\n        if (ruleCheck.recommendations) {\n          recommendations.push(...ruleCheck.recommendations);\n        }\n      }\n\n      // Calculate compliance score\n      const score = this.calculateComplianceScore(rules.length, violations.length, warnings.length);\n\n      // Determine if action should be blocked\n      const blocked = violations.some(v => v.severity === ViolationSeverity.CRITICAL);\n      const requiresReview = violations.some(v => v.severity === ViolationSeverity.HIGH) || blocked;\n\n      // Update check record\n      await prisma.complianceCheck.update({\n        where: { id: check.id },\n        data: {\n          status: blocked ? ComplianceCheckStatus.BLOCKED : \n                  requiresReview ? ComplianceCheckStatus.REVIEW_REQUIRED :\n                  violations.length > 0 ? ComplianceCheckStatus.FAILED :\n                  warnings.length > 0 ? ComplianceCheckStatus.WARNING :\n                  ComplianceCheckStatus.PASSED,\n          passed: violations.length === 0,\n          score,\n          violations: violations.map(v => v.id),\n          warnings,\n          completedAt: new Date(),\n          duration: Math.floor((Date.now() - check.startedAt.getTime()) / 1000),\n        },\n      });\n\n      return {\n        passed: violations.length === 0,\n        status: blocked ? ComplianceCheckStatus.BLOCKED : \n                requiresReview ? ComplianceCheckStatus.REVIEW_REQUIRED :\n                violations.length > 0 ? ComplianceCheckStatus.FAILED :\n                ComplianceCheckStatus.PASSED,\n        score,\n        violations,\n        warnings,\n        recommendations,\n        blocked,\n        requiresReview,\n      };\n    } catch (error: any) {\n      // Mark check as failed\n      await prisma.complianceCheck.update({\n        where: { id: check.id },\n        data: {\n          status: ComplianceCheckStatus.FAILED,\n          completedAt: new Date(),\n        },\n      });\n\n      throw new Error(`Compliance check failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Sanitize PHI from data\n   */\n  async sanitizePHI(data: any): Promise<PHISanitizationResult> {\n    const sanitized = JSON.parse(JSON.stringify(data)); // Deep clone\n    const phiRemoved: string[] = [];\n    const sanitizationLog: string[] = [];\n\n    // PHI identifiers to remove (18 HIPAA identifiers)\n    const phiPatterns = {\n      // Names\n      name: /\\b[A-Z][a-z]+ [A-Z][a-z]+\\b/g,\n      \n      // Dates (except year)\n      date: /\\b\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\b/g,\n      \n      // Phone numbers\n      phone: /\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/g,\n      \n      // Email addresses\n      email: /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g,\n      \n      // SSN\n      ssn: /\\b\\d{3}-\\d{2}-\\d{4}\\b/g,\n      \n      // Medical record numbers\n      mrn: /\\b(MRN|mrn)[:\\s]*[A-Z0-9]+\\b/gi,\n      \n      // IP addresses\n      ip: /\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b/g,\n      \n      // URLs\n      url: /https?:\\/\\/[^\\s]+/g,\n    };\n\n    // Recursively sanitize object\n    const sanitizeObject = (obj: any, path: string = \'\'): void => {\n      if (typeof obj === \'string\') {\n        let modified = false;\n        let sanitizedValue = obj;\n\n        for (const [type, pattern] of Object.entries(phiPatterns)) {\n          if (pattern.test(sanitizedValue)) {\n            sanitizedValue = sanitizedValue.replace(pattern, `[${type.toUpperCase()}_REDACTED]`);\n            phiRemoved.push(type);\n            sanitizationLog.push(`Removed ${type} from ${path}`);\n            modified = true;\n          }\n        }\n\n        return sanitizedValue;\n      } else if (Array.isArray(obj)) {\n        return obj.map((item, index) => sanitizeObject(item, `${path}[${index}]`));\n      } else if (typeof obj === \'object\' && obj !== null) {\n        const result: any = {};\n        for (const [key, value] of Object.entries(obj)) {\n          // Check if key itself indicates PHI\n          const lowerKey = key.toLowerCase();\n          if ([\'ssn\', \'socialsecurity\', \'email\', \'phone\', \'address\', \'dob\', \'dateofbirth\'].includes(lowerKey)) {\n            result[key] = \'[REDACTED]\';\n            phiRemoved.push(key);\n            sanitizationLog.push(`Redacted field: ${path}.${key}`);\n          } else {\n            result[key] = sanitizeObject(value, `${path}.${key}`);\n          }\n        }\n        return result;\n      }\n\n      return obj;\n    };\n\n    const sanitizedData = sanitizeObject(data);\n\n    return {\n      sanitized: sanitizedData,\n      phiDetected: phiRemoved.length > 0,\n      phiRemoved: [...new Set(phiRemoved)],\n      sanitizationLog,\n    };\n  }\n\n  /**\n   * Verify bug report compliance\n   */\n  async verifyBugCompliance(bugData: any): Promise<ComplianceCheckResult> {\n    return await this.checkCompliance({\n      action: \'CREATE_BUG\',\n      repository: \'BUG_REPOSITORY\',\n      targetType: \'bug\',\n      targetId: bugData.id || \'new\',\n      targetDetails: bugData,\n      rules: [\'HIPAA-PR-001\', \'HIPAA-SR-001\'], // Privacy and Security rules\n      triggeredBy: bugData.reportedBy || \'SYSTEM\',\n    });\n  }\n\n  /**\n   * Verify feature compliance\n   */\n  async verifyFeatureCompliance(featureData: any): Promise<ComplianceCheckResult> {\n    return await this.checkCompliance({\n      action: \'IMPLEMENT_FEATURE\',\n      repository: \'ENHANCEMENT_REPOSITORY\',\n      targetType: \'feature\',\n      targetId: featureData.id,\n      targetDetails: featureData,\n      triggeredBy: featureData.requestedBy || \'SYSTEM\',\n    });\n  }\n\n  /**\n   * Verify recovery compliance\n   */\n  async verifyRecoveryCompliance(recoveryData: any): Promise<ComplianceCheckResult> {\n    return await this.checkCompliance({\n      action: \'EMERGENCY_ROLLBACK\',\n      repository: \'EMERGENCY_RECOVERY\',\n      targetType: \'restoration\',\n      targetId: recoveryData.snapshot || \'new\',\n      targetDetails: recoveryData,\n      triggeredBy: recoveryData.triggeredBy || \'SYSTEM\',\n    });\n  }\n\n  /**\n   * Authorize PHI access\n   */\n  async authorizeAccess(accessRequest: {\n    userId: string;\n    patientId: string;\n    resourceType: string;\n    action: string;\n    purpose: string;\n  }): Promise<{ authorized: boolean; reason?: string }> {\n    // Check minimum necessary\n    const minimumNecessary = await this.checkMinimumNecessary(accessRequest);\n    if (!minimumNecessary.compliant) {\n      return {\n        authorized: false,\n        reason: \'Access does not meet minimum necessary standard\',\n      };\n    }\n\n    // Check consent\n    const consentCheck = await this.checkConsent(accessRequest);\n    if (!consentCheck.valid) {\n      return {\n        authorized: false,\n        reason: \'Valid consent not found\',\n      };\n    }\n\n    // Check authorization\n    const authCheck = await this.checkAuthorization(accessRequest);\n    if (!authCheck.authorized) {\n      return {\n        authorized: false,\n        reason: authCheck.reason,\n      };\n    }\n\n    return { authorized: true };\n  }\n\n  /**\n   * Log PHI access\n   */\n  async logPHIAccess(accessData: {\n    userId: string;\n    userName: string;\n    userRole: string;\n    patientId: string;\n    resourceType: string;\n    resourceId: string;\n    action: string;\n    purpose: string;\n    justification?: string;\n    consentId?: string;\n    authorized: boolean;\n    ipAddress: string;\n    location?: string;\n    deviceInfo?: string;\n    sessionId?: string;\n    fieldsAccessed: string[];\n    minimumNecessary: boolean;\n  }): Promise<void> {\n    await prisma.pHIAccessLog.create({\n      data: {\n        ...accessData,\n        authorizationMethod: \'RBAC_WITH_CONSENT\',\n      },\n    });\n  }\n\n  /**\n   * Get HIPAA rule by ID\n   */\n  async getRule(ruleId: string): Promise<HIPAARule | null> {\n    return await prisma.hIPAARule.findUnique({\n      where: { ruleId },\n    });\n  }\n\n  /**\n   * Get all active HIPAA rules\n   */\n  async getAllRules(): Promise<HIPAARule[]> {\n    return await prisma.hIPAARule.findMany({\n      where: { active: true },\n      orderBy: [\n        { category: \'asc\' },\n        { severity: \'desc\' },\n      ],\n    });\n  }\n\n  /**\n   * Get rules by category\n   */\n  async getRulesByCategory(category: HIPAARuleCategory): Promise<HIPAARule[]> {\n    return await prisma.hIPAARule.findMany({\n      where: {\n        category,\n        active: true,\n      },\n    });\n  }\n\n  /**\n   * Search knowledge base\n   */\n  async searchKnowledgeBase(query: string, category?: HIPAARuleCategory): Promise<any[]> {\n    const where: any = {};\n    \n    if (category) {\n      where.category = category;\n    }\n\n    // Simple text search (in production, use full-text search)\n    const results = await prisma.hIPAAKnowledgeBase.findMany({\n      where: {\n        ...where,\n        OR: [\n          { title: { contains: query, mode: \'insensitive\' } },\n          { summary: { contains: query, mode: \'insensitive\' } },\n        ],\n      },\n      take: 10,\n    });\n\n    // Update reference count\n    for (const result of results) {\n      await prisma.hIPAAKnowledgeBase.update({\n        where: { id: result.id },\n        data: {\n          timesReferenced: result.timesReferenced + 1,\n          lastAccessed: new Date(),\n        },\n      });\n    }\n\n    return results;\n  }\n\n  // ============================================================================\n  // PRIVATE HELPER METHODS\n  // ============================================================================\n\n  private determineCheckType(action: string): ComplianceCheckType {\n    const actionMap: { [key: string]: ComplianceCheckType } = {\n      \'CREATE_BUG\': ComplianceCheckType.PHI_HANDLING,\n      \'IMPLEMENT_FEATURE\': ComplianceCheckType.CODE_ANALYSIS,\n      \'DEPLOY\': ComplianceCheckType.DATA_FLOW,\n      \'ACCESS_PHI\': ComplianceCheckType.ACCESS_CONTROL,\n      \'EMERGENCY_ROLLBACK\': ComplianceCheckType.AUDIT_LOG,\n      \'RESTORE_SNAPSHOT\': ComplianceCheckType.ENCRYPTION,\n    };\n\n    return actionMap[action] || ComplianceCheckType.CODE_ANALYSIS;\n  }\n\n  private async getApplicableRules(request: ComplianceCheckRequest): Promise<HIPAARule[]> {\n    if (request.rules && request.rules.length > 0) {\n      // Get specific rules\n      return await prisma.hIPAARule.findMany({\n        where: {\n          ruleId: { in: request.rules },\n          active: true,\n        },\n      });\n    }\n\n    // Get all applicable rules based on action\n    const applicableCategories = this.getApplicableCategories(request.action);\n    \n    return await prisma.hIPAARule.findMany({\n      where: {\n        category: { in: applicableCategories },\n        active: true,\n      },\n    });\n  }\n\n  private getApplicableCategories(action: string): HIPAARuleCategory[] {\n    // Map actions to HIPAA rule categories\n    const categoryMap: { [key: string]: HIPAARuleCategory[] } = {\n      \'CREATE_BUG\': [HIPAARuleCategory.PRIVACY_RULE, HIPAARuleCategory.SECURITY_RULE],\n      \'IMPLEMENT_FEATURE\': [HIPAARuleCategory.PRIVACY_RULE, HIPAARuleCategory.SECURITY_RULE],\n      \'ACCESS_PHI\': [HIPAARuleCategory.PRIVACY_RULE, HIPAARuleCategory.SECURITY_RULE],\n      \'EMERGENCY_ROLLBACK\': [HIPAARuleCategory.SECURITY_RULE, HIPAARuleCategory.BREACH_NOTIFICATION],\n    };\n\n    return categoryMap[action] || [HIPAARuleCategory.PRIVACY_RULE, HIPAARuleCategory.SECURITY_RULE];\n  }\n\n  private async checkRule(rule: HIPAARule, request: ComplianceCheckRequest): Promise<any> {\n    // Use AI to check rule compliance\n    const prompt = `\n      Analyze the following action for HIPAA compliance:\n      \n      Rule: ${rule.title}\n      Description: ${rule.description}\n      Requirements: ${rule.requirements.join(\', \')}\n      \n      Action: ${request.action}\n      Details: ${JSON.stringify(request.targetDetails, null, 2)}\n      \n      Determine if this action violates the HIPAA rule. Return JSON:\n      {\n        "violated": boolean,\n        "confidence": 0-1,\n        "explanation": "string",\n        "warnings": ["string"],\n        "recommendations": ["string"]\n      }\n    `;\n\n    try {\n      const response = await openai.chat.completions.create({\n        model: \'gpt-4\',\n        messages: [\n          {\n            role: \'system\',\n            content: \'You are a HIPAA compliance expert. Analyze actions for HIPAA violations.\',\n          },\n          {\n            role: \'user\',\n            content: prompt,\n          },\n        ],\n        temperature: 0.1,\n        response_format: { type: \'json_object\' },\n      });\n\n      const analysis = JSON.parse(response.choices[0].message.content || \'{}\');\n\n      return {\n        violated: analysis.violated && analysis.confidence > 0.7,\n        warnings: analysis.warnings || [],\n        recommendations: analysis.recommendations || [],\n        violationDetails: analysis.violated ? {\n          title: `${rule.title} Violation`,\n          description: analysis.explanation,\n          severity: this.mapRuleSeverityToViolationSeverity(rule.severity),\n          location: request.targetType,\n          component: request.repository,\n          detectedBy: \'AI_ANALYSIS\',\n          detectionMethod: \'AUTOMATED_COMPLIANCE_CHECK\',\n          ruleCategory: rule.category,\n        } : null,\n      };\n    } catch (error) {\n      console.error(\'AI compliance check failed:\', error);\n      // Fall back to basic checks\n      return {\n        violated: false,\n        warnings: [\'AI analysis unavailable, manual review recommended\'],\n        recommendations: [],\n      };\n    }\n  }\n\n  private async createViolation(violationData: any): Promise<ComplianceViolation> {\n    return await prisma.complianceViolation.create({\n      data: {\n        ...violationData,\n        violationType: \'HIPAA_VIOLATION\',\n        status: ViolationStatus.DETECTED,\n        riskScore: this.calculateRiskScore(violationData.severity),\n      },\n    });\n  }\n\n  private calculateComplianceScore(totalRules: number, violations: number, warnings: number): number {\n    if (totalRules === 0) return 100;\n    \n    const violationPenalty = (violations / totalRules) * 50;\n    const warningPenalty = (warnings / totalRules) * 20;\n    \n    return Math.max(0, 100 - violationPenalty - warningPenalty);\n  }\n\n  private calculateRiskScore(severity: ViolationSeverity): number {\n    const scoreMap = {\n      [ViolationSeverity.CRITICAL]: 100,\n      [ViolationSeverity.HIGH]: 75,\n      [ViolationSeverity.MEDIUM]: 50,\n      [ViolationSeverity.LOW]: 25,\n    };\n    return scoreMap[severity];\n  }\n\n  private mapRuleSeverityToViolationSeverity(ruleSeverity: string): ViolationSeverity {\n    const map: { [key: string]: ViolationSeverity } = {\n      \'CRITICAL\': ViolationSeverity.CRITICAL,\n      \'HIGH\': ViolationSeverity.HIGH,\n      \'MEDIUM\': ViolationSeverity.MEDIUM,\n      \'LOW\': ViolationSeverity.LOW,\n    };\n    return map[ruleSeverity] || ViolationSeverity.MEDIUM;\n  }\n\n  private async checkMinimumNecessary(accessRequest: any): Promise<{ compliant: boolean; reason?: string }> {\n    // TODO: Implement minimum necessary check\n    // This would verify that the access request only includes necessary fields\n    return { compliant: true };\n  }\n\n  private async checkConsent(accessRequest: any): Promise<{ valid: boolean; reason?: string }> {\n    // TODO: Implement consent check\n    // This would verify valid consent exists for the access\n    return { valid: true };\n  }\n\n  private async checkAuthorization(accessRequest: any): Promise<{ authorized: boolean; reason?: string }> {\n    // TODO: Implement authorization check\n    // This would verify user has proper authorization\n    return { authorized: true };\n  }\n}\n\nexport default HIPAAComplianceService;\n</create-file>\n</function_calls>'}