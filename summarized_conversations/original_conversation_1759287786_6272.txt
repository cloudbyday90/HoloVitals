{'role': 'assistant', 'content': 'Now let me create the Token Management Service:\n\n<function_calls>\n<create-file file_path="medical-analysis-platform/lib/services/TokenService.ts">\n/**\n * Token Management Service\n * \n * Handles token balance tracking, deductions, purchases, and analytics\n */\n\nimport { PrismaClient } from \'@prisma/client\';\nimport {\n  SubscriptionTier,\n  getTierConfig,\n  TOKEN_PACKAGES,\n  PRICING_RULES,\n  formatTokens,\n} from \'../config/pricing\';\n\nconst prisma = new PrismaClient();\n\nexport interface TokenDeductionInput {\n  userId: string;\n  amount: number;\n  description: string;\n  referenceId?: string;\n  referenceType?: string;\n}\n\nexport interface TokenPurchaseInput {\n  userId: string;\n  packageIndex: number; // Index in TOKEN_PACKAGES array\n  paymentIntentId: string;\n}\n\nexport interface TokenRefundInput {\n  userId: string;\n  amount: number;\n  reason: string;\n  referenceId?: string;\n}\n\nexport class TokenService {\n  /**\n   * Get user\'s token balance\n   */\n  static async getBalance(userId: string) {\n    const tokenBalance = await prisma.tokenBalance.findUnique({\n      where: { userId },\n      include: {\n        subscription: true,\n      },\n    });\n    \n    if (!tokenBalance) {\n      throw new Error(\'Token balance not found\');\n    }\n    \n    const tierConfig = getTierConfig(tokenBalance.subscription.tier as SubscriptionTier);\n    \n    return {\n      ...tokenBalance,\n      currentBalanceFormatted: formatTokens(tokenBalance.currentBalance),\n      totalEarnedFormatted: formatTokens(tokenBalance.totalEarned),\n      totalUsedFormatted: formatTokens(tokenBalance.totalUsed),\n      monthlyAllocation: tierConfig.monthlyTokens,\n      monthlyAllocationFormatted: formatTokens(tierConfig.monthlyTokens),\n      freeUploadRemaining: Math.max(0, tierConfig.freeUploadLimit - tokenBalance.freeUploadUsed),\n    };\n  }\n  \n  /**\n   * Deduct tokens from user\'s balance\n   */\n  static async deductTokens(input: TokenDeductionInput) {\n    const tokenBalance = await prisma.tokenBalance.findUnique({\n      where: { userId: input.userId },\n    });\n    \n    if (!tokenBalance) {\n      throw new Error(\'Token balance not found\');\n    }\n    \n    // Check if user has sufficient balance\n    if (tokenBalance.currentBalance < input.amount) {\n      throw new Error(\n        `Insufficient token balance. Required: ${formatTokens(input.amount)}, Available: ${formatTokens(tokenBalance.currentBalance)}`\n      );\n    }\n    \n    // Deduct tokens\n    const newBalance = tokenBalance.currentBalance - input.amount;\n    const newTotalUsed = tokenBalance.totalUsed + input.amount;\n    \n    const updatedBalance = await prisma.tokenBalance.update({\n      where: { id: tokenBalance.id },\n      data: {\n        currentBalance: newBalance,\n        totalUsed: newTotalUsed,\n      },\n    });\n    \n    // Create transaction record\n    await prisma.tokenTransaction.create({\n      data: {\n        tokenBalanceId: tokenBalance.id,\n        type: \'DEDUCTION\',\n        amount: -input.amount,\n        balanceBefore: tokenBalance.currentBalance,\n        balanceAfter: newBalance,\n        description: input.description,\n        referenceId: input.referenceId,\n        referenceType: input.referenceType,\n      },\n    });\n    \n    return updatedBalance;\n  }\n  \n  /**\n   * Purchase additional tokens\n   */\n  static async purchaseTokens(input: TokenPurchaseInput) {\n    const tokenPackage = TOKEN_PACKAGES[input.packageIndex];\n    \n    if (!tokenPackage) {\n      throw new Error(\'Invalid token package\');\n    }\n    \n    const tokenBalance = await prisma.tokenBalance.findUnique({\n      where: { userId: input.userId },\n    });\n    \n    if (!tokenBalance) {\n      throw new Error(\'Token balance not found\');\n    }\n    \n    // Calculate total tokens (base + bonus)\n    const totalTokens = tokenPackage.tokens + tokenPackage.bonus;\n    \n    // Add tokens to balance\n    const newBalance = tokenBalance.currentBalance + totalTokens;\n    const newTotalEarned = tokenBalance.totalEarned + totalTokens;\n    const newTotalPurchased = tokenBalance.totalPurchased + totalTokens;\n    \n    const updatedBalance = await prisma.tokenBalance.update({\n      where: { id: tokenBalance.id },\n      data: {\n        currentBalance: newBalance,\n        totalEarned: newTotalEarned,\n        totalPurchased: newTotalPurchased,\n      },\n    });\n    \n    // Create transaction record\n    await prisma.tokenTransaction.create({\n      data: {\n        tokenBalanceId: tokenBalance.id,\n        type: \'PURCHASE\',\n        amount: totalTokens,\n        balanceBefore: tokenBalance.currentBalance,\n        balanceAfter: newBalance,\n        description: `Token purchase: ${tokenPackage.displayName}`,\n        referenceId: input.paymentIntentId,\n        referenceType: \'PaymentIntent\',\n        metadata: JSON.stringify({\n          packageIndex: input.packageIndex,\n          baseTokens: tokenPackage.tokens,\n          bonusTokens: tokenPackage.bonus,\n          price: tokenPackage.price,\n        }),\n      },\n    });\n    \n    // Create payment intent record\n    await prisma.paymentIntent.create({\n      data: {\n        userId: input.userId,\n        amount: tokenPackage.price,\n        status: \'succeeded\',\n        paymentMethodId: input.paymentIntentId,\n        tokensPurchased: totalTokens,\n        description: `Token purchase: ${tokenPackage.displayName}`,\n        metadata: JSON.stringify({\n          packageIndex: input.packageIndex,\n          baseTokens: tokenPackage.tokens,\n          bonusTokens: tokenPackage.bonus,\n        }),\n      },\n    });\n    \n    return updatedBalance;\n  }\n  \n  /**\n   * Refund tokens to user\n   */\n  static async refundTokens(input: TokenRefundInput) {\n    const tokenBalance = await prisma.tokenBalance.findUnique({\n      where: { userId: input.userId },\n    });\n    \n    if (!tokenBalance) {\n      throw new Error(\'Token balance not found\');\n    }\n    \n    // Add tokens back\n    const newBalance = tokenBalance.currentBalance + input.amount;\n    const newTotalEarned = tokenBalance.totalEarned + input.amount;\n    \n    const updatedBalance = await prisma.tokenBalance.update({\n      where: { id: tokenBalance.id },\n      data: {\n        currentBalance: newBalance,\n        totalEarned: newTotalEarned,\n      },\n    });\n    \n    // Create transaction record\n    await prisma.tokenTransaction.create({\n      data: {\n        tokenBalanceId: tokenBalance.id,\n        type: \'REFUND\',\n        amount: input.amount,\n        balanceBefore: tokenBalance.currentBalance,\n        balanceAfter: newBalance,\n        description: `Refund: ${input.reason}`,\n        referenceId: input.referenceId,\n        referenceType: \'Refund\',\n      },\n    });\n    \n    return updatedBalance;\n  }\n  \n  /**\n   * Add bonus tokens (promotional, referral, etc.)\n   */\n  static async addBonusTokens(\n    userId: string,\n    amount: number,\n    reason: string\n  ) {\n    const tokenBalance = await prisma.tokenBalance.findUnique({\n      where: { userId },\n    });\n    \n    if (!tokenBalance) {\n      throw new Error(\'Token balance not found\');\n    }\n    \n    const newBalance = tokenBalance.currentBalance + amount;\n    const newTotalEarned = tokenBalance.totalEarned + amount;\n    \n    const updatedBalance = await prisma.tokenBalance.update({\n      where: { id: tokenBalance.id },\n      data: {\n        currentBalance: newBalance,\n        totalEarned: newTotalEarned,\n      },\n    });\n    \n    await prisma.tokenTransaction.create({\n      data: {\n        tokenBalanceId: tokenBalance.id,\n        type: \'BONUS\',\n        amount,\n        balanceBefore: tokenBalance.currentBalance,\n        balanceAfter: newBalance,\n        description: reason,\n      },\n    });\n    \n    return updatedBalance;\n  }\n  \n  /**\n   * Track free upload usage\n   */\n  static async trackFreeUploadUsage(\n    userId: string,\n    bytesUsed: number\n  ) {\n    const tokenBalance = await prisma.tokenBalance.findUnique({\n      where: { userId },\n      include: { subscription: true },\n    });\n    \n    if (!tokenBalance) {\n      throw new Error(\'Token balance not found\');\n    }\n    \n    const tierConfig = getTierConfig(tokenBalance.subscription.tier as SubscriptionTier);\n    const currentUsed = tokenBalance.freeUploadUsed;\n    const newUsed = currentUsed + bytesUsed;\n    \n    // Check if exceeds limit\n    if (newUsed > tierConfig.freeUploadLimit) {\n      throw new Error(\n        `Free upload limit exceeded. Limit: ${tierConfig.freeUploadLimit} bytes, Used: ${newUsed} bytes`\n      );\n    }\n    \n    const updatedBalance = await prisma.tokenBalance.update({\n      where: { id: tokenBalance.id },\n      data: {\n        freeUploadUsed: newUsed,\n      },\n    });\n    \n    return updatedBalance;\n  }\n  \n  /**\n   * Check if user can afford an operation\n   */\n  static async canAfford(userId: string, tokensRequired: number): Promise<boolean> {\n    const tokenBalance = await prisma.tokenBalance.findUnique({\n      where: { userId },\n    });\n    \n    if (!tokenBalance) {\n      return false;\n    }\n    \n    return tokenBalance.currentBalance >= tokensRequired;\n  }\n  \n  /**\n   * Get token transaction history\n   */\n  static async getTransactionHistory(\n    userId: string,\n    limit: number = 50,\n    offset: number = 0\n  ) {\n    const tokenBalance = await prisma.tokenBalance.findUnique({\n      where: { userId },\n    });\n    \n    if (!tokenBalance) {\n      throw new Error(\'Token balance not found\');\n    }\n    \n    const transactions = await prisma.tokenTransaction.findMany({\n      where: { tokenBalanceId: tokenBalance.id },\n      orderBy: { createdAt: \'desc\' },\n      take: limit,\n      skip: offset,\n    });\n    \n    const total = await prisma.tokenTransaction.count({\n      where: { tokenBalanceId: tokenBalance.id },\n    });\n    \n    return {\n      transactions,\n      total,\n      limit,\n      offset,\n      hasMore: offset + limit < total,\n    };\n  }\n  \n  /**\n   * Get token usage analytics\n   */\n  static async getUsageAnalytics(userId: string, days: number = 30) {\n    const tokenBalance = await prisma.tokenBalance.findUnique({\n      where: { userId },\n    });\n    \n    if (!tokenBalance) {\n      throw new Error(\'Token balance not found\');\n    }\n    \n    const startDate = new Date();\n    startDate.setDate(startDate.getDate() - days);\n    \n    const transactions = await prisma.tokenTransaction.findMany({\n      where: {\n        tokenBalanceId: tokenBalance.id,\n        createdAt: { gte: startDate },\n      },\n      orderBy: { createdAt: \'asc\' },\n    });\n    \n    // Calculate daily usage\n    const dailyUsage: Record<string, number> = {};\n    const usageByType: Record<string, number> = {};\n    \n    transactions.forEach(tx => {\n      const date = tx.createdAt.toISOString().split(\'T\')[0];\n      \n      if (tx.amount < 0) {\n        // Deduction\n        dailyUsage[date] = (dailyUsage[date] || 0) + Math.abs(tx.amount);\n        \n        const type = tx.referenceType || \'OTHER\';\n        usageByType[type] = (usageByType[type] || 0) + Math.abs(tx.amount);\n      }\n    });\n    \n    // Calculate statistics\n    const totalUsed = Object.values(dailyUsage).reduce((sum, val) => sum + val, 0);\n    const averageDaily = totalUsed / days;\n    const projectedMonthly = averageDaily * 30;\n    \n    return {\n      period: {\n        days,\n        startDate,\n        endDate: new Date(),\n      },\n      usage: {\n        total: totalUsed,\n        averageDaily,\n        projectedMonthly,\n      },\n      dailyUsage: Object.entries(dailyUsage).map(([date, tokens]) => ({\n        date,\n        tokens,\n      })),\n      usageByType: Object.entries(usageByType)\n        .map(([type, tokens]) => ({\n          type,\n          tokens,\n          percentage: (tokens / totalUsed) * 100,\n        }))\n        .sort((a, b) => b.tokens - a.tokens),\n    };\n  }\n  \n  /**\n   * Get token balance summary for all users (admin only)\n   */\n  static async getGlobalStats() {\n    const [\n      totalBalances,\n      totalTokensInCirculation,\n      totalTokensEarned,\n      totalTokensUsed,\n      totalTokensPurchased,\n    ] = await Promise.all([\n      prisma.tokenBalance.count(),\n      prisma.tokenBalance.aggregate({\n        _sum: { currentBalance: true },\n      }),\n      prisma.tokenBalance.aggregate({\n        _sum: { totalEarned: true },\n      }),\n      prisma.tokenBalance.aggregate({\n        _sum: { totalUsed: true },\n      }),\n      prisma.tokenBalance.aggregate({\n        _sum: { totalPurchased: true },\n      }),\n    ]);\n    \n    return {\n      totalBalances,\n      totalTokensInCirculation: totalTokensInCirculation._sum.currentBalance || 0,\n      totalTokensEarned: totalTokensEarned._sum.totalEarned || 0,\n      totalTokensUsed: totalTokensUsed._sum.totalUsed || 0,\n      totalTokensPurchased: totalTokensPurchased._sum.totalPurchased || 0,\n    };\n  }\n}\n</create-file>\n</function_calls>'}