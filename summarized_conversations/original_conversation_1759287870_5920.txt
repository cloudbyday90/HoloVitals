{'role': 'assistant', 'content': 'Now let\'s create the EHR Connection Service that manages connections to EHR systems:\n\n<function_calls>\n<create-file file_path="medical-analysis-platform/lib/services/EHRConnectionService.ts">\n/**\n * EHR Connection Service\n * \n * Manages connections to EHR systems and handles OAuth token lifecycle\n */\n\nimport { PrismaClient } from \'@prisma/client\';\nimport { SMARTAuthService, TokenResponse, getDefaultPatientScopes } from \'../fhir/SMARTAuthService\';\nimport { FHIRClient } from \'../fhir/FHIRClient\';\nimport crypto from \'crypto\';\n\nconst prisma = new PrismaClient();\n\nexport interface CreateConnectionInput {\n  userId: string;\n  provider: string;\n  providerName: string;\n  fhirBaseUrl: string;\n  authorizationUrl: string;\n  tokenUrl: string;\n  clientId: string;\n  clientSecret?: string;\n  redirectUri: string;\n}\n\nexport interface AuthorizeConnectionInput {\n  connectionId: string;\n  code: string;\n  state: string;\n  codeVerifier: string;\n}\n\nexport class EHRConnectionService {\n  /**\n   * Initiate a new EHR connection\n   * Returns authorization URL for user to visit\n   */\n  static async initiateConnection(input: CreateConnectionInput): Promise<{\n    connection: any;\n    authorizationUrl: string;\n    state: string;\n  }> {\n    // Create SMART auth service\n    const authService = new SMARTAuthService({\n      clientId: input.clientId,\n      clientSecret: input.clientSecret,\n      redirectUri: input.redirectUri,\n      authorizationUrl: input.authorizationUrl,\n      tokenUrl: input.tokenUrl,\n      scopes: getDefaultPatientScopes(),\n    });\n\n    // Generate authorization URL\n    const { url, params } = authService.generateAuthorizationUrl();\n\n    // Create connection record\n    const connection = await prisma.eHRConnection.create({\n      data: {\n        userId: input.userId,\n        provider: input.provider as any,\n        providerName: input.providerName,\n        fhirBaseUrl: input.fhirBaseUrl,\n        status: \'PENDING\',\n        metadata: JSON.stringify({\n          authorizationUrl: input.authorizationUrl,\n          tokenUrl: input.tokenUrl,\n          clientId: input.clientId,\n          clientSecret: input.clientSecret ? this.encrypt(input.clientSecret) : undefined,\n          redirectUri: input.redirectUri,\n          codeVerifier: params.codeVerifier,\n          codeChallenge: params.codeChallenge,\n        }),\n      },\n    });\n\n    return {\n      connection,\n      authorizationUrl: url,\n      state: params.state,\n    };\n  }\n\n  /**\n   * Complete OAuth authorization and activate connection\n   */\n  static async authorizeConnection(input: AuthorizeConnectionInput): Promise<any> {\n    const connection = await prisma.eHRConnection.findUnique({\n      where: { id: input.connectionId },\n    });\n\n    if (!connection) {\n      throw new Error(\'Connection not found\');\n    }\n\n    if (connection.status !== \'PENDING\') {\n      throw new Error(\'Connection is not in pending state\');\n    }\n\n    // Parse metadata\n    const metadata = JSON.parse(connection.metadata || \'{}\');\n\n    // Create SMART auth service\n    const authService = new SMARTAuthService({\n      clientId: metadata.clientId,\n      clientSecret: metadata.clientSecret ? this.decrypt(metadata.clientSecret) : undefined,\n      redirectUri: metadata.redirectUri,\n      authorizationUrl: metadata.authorizationUrl,\n      tokenUrl: metadata.tokenUrl,\n      scopes: getDefaultPatientScopes(),\n    });\n\n    // Exchange code for token\n    const tokenResponse = await authService.getAccessToken(\n      input.code,\n      input.codeVerifier\n    );\n\n    // Get patient information\n    const fhirClient = new FHIRClient({\n      baseUrl: connection.fhirBaseUrl,\n      accessToken: tokenResponse.accessToken,\n    });\n\n    let patientId = tokenResponse.patientId;\n    let patientName = \'Unknown\';\n\n    if (patientId) {\n      try {\n        const patient = await fhirClient.getPatient(patientId);\n        patientName = this.formatPatientName(patient);\n      } catch (error) {\n        console.error(\'Failed to fetch patient info:\', error);\n      }\n    }\n\n    // Update connection with tokens\n    const updatedConnection = await prisma.eHRConnection.update({\n      where: { id: connection.id },\n      data: {\n        status: \'ACTIVE\',\n        accessToken: this.encrypt(tokenResponse.accessToken),\n        refreshToken: tokenResponse.refreshToken ? this.encrypt(tokenResponse.refreshToken) : null,\n        tokenExpiresAt: tokenResponse.expiresAt,\n        patientId,\n        patientName,\n        nextSyncAt: new Date(), // Schedule immediate sync\n      },\n    });\n\n    return updatedConnection;\n  }\n\n  /**\n   * Refresh access token for a connection\n   */\n  static async refreshToken(connectionId: string): Promise<any> {\n    const connection = await prisma.eHRConnection.findUnique({\n      where: { id: connectionId },\n    });\n\n    if (!connection) {\n      throw new Error(\'Connection not found\');\n    }\n\n    if (!connection.refreshToken) {\n      throw new Error(\'No refresh token available\');\n    }\n\n    const metadata = JSON.parse(connection.metadata || \'{}\');\n\n    // Create SMART auth service\n    const authService = new SMARTAuthService({\n      clientId: metadata.clientId,\n      clientSecret: metadata.clientSecret ? this.decrypt(metadata.clientSecret) : undefined,\n      redirectUri: metadata.redirectUri,\n      authorizationUrl: metadata.authorizationUrl,\n      tokenUrl: metadata.tokenUrl,\n      scopes: getDefaultPatientScopes(),\n    });\n\n    // Refresh token\n    const tokenResponse = await authService.refreshAccessToken(\n      this.decrypt(connection.refreshToken)\n    );\n\n    // Update connection\n    const updatedConnection = await prisma.eHRConnection.update({\n      where: { id: connection.id },\n      data: {\n        accessToken: this.encrypt(tokenResponse.accessToken),\n        refreshToken: tokenResponse.refreshToken ? this.encrypt(tokenResponse.refreshToken) : connection.refreshToken,\n        tokenExpiresAt: tokenResponse.expiresAt,\n        status: \'ACTIVE\',\n        errorMessage: null,\n      },\n    });\n\n    return updatedConnection;\n  }\n\n  /**\n   * Get FHIR client for a connection\n   */\n  static async getFHIRClient(connectionId: string): Promise<FHIRClient> {\n    const connection = await prisma.eHRConnection.findUnique({\n      where: { id: connectionId },\n    });\n\n    if (!connection) {\n      throw new Error(\'Connection not found\');\n    }\n\n    if (connection.status !== \'ACTIVE\') {\n      throw new Error(\'Connection is not active\');\n    }\n\n    if (!connection.accessToken) {\n      throw new Error(\'No access token available\');\n    }\n\n    // Check if token is expired\n    if (connection.tokenExpiresAt && new Date() >= connection.tokenExpiresAt) {\n      // Try to refresh\n      if (connection.refreshToken) {\n        await this.refreshToken(connectionId);\n        // Fetch updated connection\n        const refreshedConnection = await prisma.eHRConnection.findUnique({\n          where: { id: connectionId },\n        });\n        if (!refreshedConnection?.accessToken) {\n          throw new Error(\'Failed to refresh token\');\n        }\n        return new FHIRClient({\n          baseUrl: refreshedConnection.fhirBaseUrl,\n          accessToken: this.decrypt(refreshedConnection.accessToken),\n        });\n      } else {\n        throw new Error(\'Token expired and no refresh token available\');\n      }\n    }\n\n    return new FHIRClient({\n      baseUrl: connection.fhirBaseUrl,\n      accessToken: this.decrypt(connection.accessToken),\n    });\n  }\n\n  /**\n   * Get user\'s connections\n   */\n  static async getUserConnections(userId: string): Promise<any[]> {\n    const connections = await prisma.eHRConnection.findMany({\n      where: { userId },\n      orderBy: { createdAt: \'desc\' },\n    });\n\n    // Remove sensitive data\n    return connections.map(conn => ({\n      ...conn,\n      accessToken: undefined,\n      refreshToken: undefined,\n      metadata: undefined,\n    }));\n  }\n\n  /**\n   * Disconnect (revoke) a connection\n   */\n  static async disconnectConnection(connectionId: string): Promise<any> {\n    const connection = await prisma.eHRConnection.update({\n      where: { id: connectionId },\n      data: {\n        status: \'DISCONNECTED\',\n        accessToken: null,\n        refreshToken: null,\n        autoSync: false,\n      },\n    });\n\n    return connection;\n  }\n\n  /**\n   * Delete a connection\n   */\n  static async deleteConnection(connectionId: string): Promise<void> {\n    await prisma.eHRConnection.delete({\n      where: { id: connectionId },\n    });\n  }\n\n  /**\n   * Get connections that need syncing\n   */\n  static async getConnectionsNeedingSync(): Promise<any[]> {\n    const now = new Date();\n\n    return prisma.eHRConnection.findMany({\n      where: {\n        status: \'ACTIVE\',\n        autoSync: true,\n        nextSyncAt: {\n          lte: now,\n        },\n      },\n    });\n  }\n\n  /**\n   * Update connection sync schedule\n   */\n  static async updateSyncSchedule(connectionId: string): Promise<any> {\n    const connection = await prisma.eHRConnection.findUnique({\n      where: { id: connectionId },\n    });\n\n    if (!connection) {\n      throw new Error(\'Connection not found\');\n    }\n\n    const nextSyncAt = new Date();\n    nextSyncAt.setHours(nextSyncAt.getHours() + connection.syncFrequency);\n\n    return prisma.eHRConnection.update({\n      where: { id: connectionId },\n      data: {\n        lastSyncAt: new Date(),\n        nextSyncAt,\n      },\n    });\n  }\n\n  /**\n   * Format patient name from FHIR Patient resource\n   */\n  private static formatPatientName(patient: any): string {\n    const name = patient.name?.[0];\n    if (!name) return \'Unknown\';\n\n    const parts = [];\n    if (name.given) parts.push(...name.given);\n    if (name.family) parts.push(name.family);\n\n    return parts.join(\' \') || \'Unknown\';\n  }\n\n  /**\n   * Encrypt sensitive data\n   */\n  private static encrypt(text: string): string {\n    const algorithm = \'aes-256-gcm\';\n    const key = Buffer.from(process.env.ENCRYPTION_KEY || \'default-key-change-in-production-32b\', \'utf8\');\n    const iv = crypto.randomBytes(16);\n    \n    const cipher = crypto.createCipheriv(algorithm, key, iv);\n    let encrypted = cipher.update(text, \'utf8\', \'hex\');\n    encrypted += cipher.final(\'hex\');\n    \n    const authTag = cipher.getAuthTag();\n    \n    return `${iv.toString(\'hex\')}:${authTag.toString(\'hex\')}:${encrypted}`;\n  }\n\n  /**\n   * Decrypt sensitive data\n   */\n  private static decrypt(encryptedText: string): string {\n    const algorithm = \'aes-256-gcm\';\n    const key = Buffer.from(process.env.ENCRYPTION_KEY || \'default-key-change-in-production-32b\', \'utf8\');\n    \n    const parts = encryptedText.split(\':\');\n    const iv = Buffer.from(parts[0], \'hex\');\n    const authTag = Buffer.from(parts[1], \'hex\');\n    const encrypted = parts[2];\n    \n    const decipher = crypto.createDecipheriv(algorithm, key, iv);\n    decipher.setAuthTag(authTag);\n    \n    let decrypted = decipher.update(encrypted, \'hex\', \'utf8\');\n    decrypted += decipher.final(\'utf8\');\n    \n    return decrypted;\n  }\n}\n</create-file>\n</function_calls>'}