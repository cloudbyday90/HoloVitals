{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/services/EpicEnhancedService.ts">\n/**\n * Epic Enhanced Service\n * \n * Provides Epic-specific optimizations and features including:\n * - Additional resource types (DiagnosticReport, CarePlan, Encounter, Goal, ServiceRequest)\n * - Bulk Data Export ($export operation)\n * - Enhanced data extraction with Epic extensions\n * - Epic-specific rate limiting and optimizations\n */\n\nimport { PrismaClient, BulkExportType, BulkExportStatus, FHIRResourceType } from \'@prisma/client\';\nimport { FHIRClient } from \'../fhir/FHIRClient\';\nimport { EHRSyncService } from \'./EHRSyncService\';\n\nconst prisma = new PrismaClient();\n\ninterface BulkExportRequest {\n  connectionId: string;\n  exportType: BulkExportType;\n  resourceTypes?: string[];\n  since?: Date;\n}\n\ninterface BulkExportStatusResponse {\n  transactionTime: string;\n  request: string;\n  requiresAccessToken: boolean;\n  output: Array<{\n    type: string;\n    url: string;\n    count?: number;\n  }>;\n  error?: Array<{\n    type: string;\n    url: string;\n  }>;\n}\n\ninterface DiagnosticReportData {\n  id: string;\n  status: string;\n  category: string[];\n  code: {\n    coding: Array<{\n      system: string;\n      code: string;\n      display: string;\n    }>;\n    text: string;\n  };\n  subject: {\n    reference: string;\n  };\n  effectiveDateTime?: string;\n  issued?: string;\n  result?: Array<{\n    reference: string;\n  }>;\n  conclusion?: string;\n  conclusionCode?: Array<{\n    coding: Array<{\n      system: string;\n      code: string;\n      display: string;\n    }>;\n  }>;\n  presentedForm?: Array<{\n    contentType: string;\n    url?: string;\n    data?: string;\n    title?: string;\n  }>;\n}\n\ninterface CarePlanData {\n  id: string;\n  status: string;\n  intent: string;\n  category?: Array<{\n    coding: Array<{\n      system: string;\n      code: string;\n      display: string;\n    }>;\n  }>;\n  title?: string;\n  description?: string;\n  subject: {\n    reference: string;\n  };\n  period?: {\n    start?: string;\n    end?: string;\n  };\n  activity?: Array<{\n    detail?: {\n      kind?: string;\n      code?: {\n        coding: Array<{\n          system: string;\n          code: string;\n          display: string;\n        }>;\n      };\n      status: string;\n      description?: string;\n    };\n  }>;\n  goal?: Array<{\n    reference: string;\n  }>;\n}\n\ninterface EncounterData {\n  id: string;\n  status: string;\n  class: {\n    system: string;\n    code: string;\n    display: string;\n  };\n  type?: Array<{\n    coding: Array<{\n      system: string;\n      code: string;\n      display: string;\n    }>;\n    text?: string;\n  }>;\n  subject: {\n    reference: string;\n  };\n  period?: {\n    start?: string;\n    end?: string;\n  };\n  reasonCode?: Array<{\n    coding: Array<{\n      system: string;\n      code: string;\n      display: string;\n    }>;\n    text?: string;\n  }>;\n  diagnosis?: Array<{\n    condition: {\n      reference: string;\n    };\n    use?: {\n      coding: Array<{\n        system: string;\n        code: string;\n        display: string;\n      }>;\n    };\n  }>;\n  hospitalization?: {\n    admitSource?: {\n      coding: Array<{\n        system: string;\n        code: string;\n        display: string;\n      }>;\n    };\n    dischargeDisposition?: {\n      coding: Array<{\n        system: string;\n        code: string;\n        display: string;\n      }>;\n    };\n  };\n}\n\nexport class EpicEnhancedService {\n  private fhirClient: FHIRClient;\n  private syncService: EHRSyncService;\n  private rateLimitDelay = 100; // 10 requests per second for Epic\n\n  constructor(fhirClient: FHIRClient) {\n    this.fhirClient = fhirClient;\n    this.syncService = new EHRSyncService(fhirClient);\n  }\n\n  /**\n   * Initiate a bulk data export operation\n   */\n  async initiateBulkExport(request: BulkExportRequest): Promise<string> {\n    const connection = await prisma.eHRConnection.findUnique({\n      where: { id: request.connectionId },\n    });\n\n    if (!connection) {\n      throw new Error(\'Connection not found\');\n    }\n\n    // Construct the $export endpoint\n    let exportUrl = `${connection.fhirBaseUrl}/`;\n    \n    switch (request.exportType) {\n      case \'PATIENT\':\n        exportUrl += `Patient/${connection.patientId}/$export`;\n        break;\n      case \'GROUP\':\n        exportUrl += `Group/$export`;\n        break;\n      case \'SYSTEM\':\n        exportUrl += `$export`;\n        break;\n    }\n\n    // Add query parameters\n    const params = new URLSearchParams();\n    if (request.resourceTypes && request.resourceTypes.length > 0) {\n      params.append(\'_type\', request.resourceTypes.join(\',\'));\n    }\n    if (request.since) {\n      params.append(\'_since\', request.since.toISOString());\n    }\n\n    const fullUrl = `${exportUrl}?${params.toString()}`;\n\n    // Make the kickoff request\n    const response = await fetch(fullUrl, {\n      method: \'GET\',\n      headers: {\n        \'Authorization\': `Bearer ${connection.accessToken}`,\n        \'Accept\': \'application/fhir+json\',\n        \'Prefer\': \'respond-async\',\n      },\n    });\n\n    if (response.status !== 202) {\n      throw new Error(`Bulk export kickoff failed: ${response.statusText}`);\n    }\n\n    // Get the status URL from Content-Location header\n    const statusUrl = response.headers.get(\'Content-Location\');\n    if (!statusUrl) {\n      throw new Error(\'No status URL returned from bulk export kickoff\');\n    }\n\n    // Create the bulk export job\n    const job = await prisma.bulkExportJob.create({\n      data: {\n        connectionId: request.connectionId,\n        exportType: request.exportType,\n        status: \'INITIATED\',\n        kickoffUrl: fullUrl,\n        statusUrl,\n        resourceTypes: request.resourceTypes ? JSON.stringify(request.resourceTypes) : null,\n        since: request.since,\n      },\n    });\n\n    return job.id;\n  }\n\n  /**\n   * Check the status of a bulk export job\n   */\n  async checkBulkExportStatus(jobId: string): Promise<BulkExportStatus> {\n    const job = await prisma.bulkExportJob.findUnique({\n      where: { id: jobId },\n      include: { connection: true },\n    });\n\n    if (!job) {\n      throw new Error(\'Bulk export job not found\');\n    }\n\n    if (!job.statusUrl) {\n      throw new Error(\'No status URL for this job\');\n    }\n\n    // Check the status\n    const response = await fetch(job.statusUrl, {\n      method: \'GET\',\n      headers: {\n        \'Authorization\': `Bearer ${job.connection.accessToken}`,\n        \'Accept\': \'application/fhir+json\',\n      },\n    });\n\n    if (response.status === 202) {\n      // Still in progress\n      await prisma.bulkExportJob.update({\n        where: { id: jobId },\n        data: { status: \'IN_PROGRESS\' },\n      });\n      return \'IN_PROGRESS\';\n    }\n\n    if (response.status === 200) {\n      // Completed\n      const statusData: BulkExportStatusResponse = await response.json();\n      \n      await prisma.bulkExportJob.update({\n        where: { id: jobId },\n        data: {\n          status: \'COMPLETED\',\n          completedAt: new Date(),\n          outputUrls: JSON.stringify(statusData.output),\n          resourceCount: statusData.output.reduce((sum, o) => sum + (o.count || 0), 0),\n        },\n      });\n      \n      return \'COMPLETED\';\n    }\n\n    // Failed\n    await prisma.bulkExportJob.update({\n      where: { id: jobId },\n      data: {\n        status: \'FAILED\',\n        completedAt: new Date(),\n        errorMessage: `Export failed with status ${response.status}`,\n      },\n    });\n    \n    return \'FAILED\';\n  }\n\n  /**\n   * Download and process bulk export files\n   */\n  async processBulkExportFiles(jobId: string): Promise<void> {\n    const job = await prisma.bulkExportJob.findUnique({\n      where: { id: jobId },\n      include: { connection: true },\n    });\n\n    if (!job || job.status !== \'COMPLETED\') {\n      throw new Error(\'Job not ready for processing\');\n    }\n\n    const outputUrls = JSON.parse(job.outputUrls || \'[]\') as Array<{\n      type: string;\n      url: string;\n      count?: number;\n    }>;\n\n    let totalSize = 0;\n    let processedCount = 0;\n\n    for (const output of outputUrls) {\n      // Download the NDJSON file\n      const response = await fetch(output.url, {\n        headers: {\n          \'Authorization\': `Bearer ${job.connection.accessToken}`,\n        },\n      });\n\n      if (!response.ok) {\n        console.error(`Failed to download ${output.url}: ${response.statusText}`);\n        continue;\n      }\n\n      const ndjsonData = await response.text();\n      totalSize += ndjsonData.length;\n\n      // Parse NDJSON (newline-delimited JSON)\n      const lines = ndjsonData.split(\'\\n\').filter(line => line.trim());\n      \n      for (const line of lines) {\n        try {\n          const resource = JSON.parse(line);\n          \n          // Store the resource\n          await this.storeResource(job.connectionId, resource);\n          processedCount++;\n\n          // Rate limiting\n          await this.sleep(this.rateLimitDelay);\n        } catch (error) {\n          console.error(\'Error processing resource:\', error);\n        }\n      }\n    }\n\n    // Update job with final metrics\n    await prisma.bulkExportJob.update({\n      where: { id: jobId },\n      data: {\n        totalSize: BigInt(totalSize),\n        resourceCount: processedCount,\n      },\n    });\n  }\n\n  /**\n   * Sync DiagnosticReport resources (lab results, imaging reports)\n   */\n  async syncDiagnosticReports(connectionId: string, patientId: string): Promise<number> {\n    const resources = await this.fhirClient.searchResources(\n      \'DiagnosticReport\',\n      { patient: patientId, _sort: \'-date\' }\n    );\n\n    let count = 0;\n    for (const resource of resources) {\n      await this.storeDiagnosticReport(connectionId, resource as DiagnosticReportData);\n      count++;\n      await this.sleep(this.rateLimitDelay);\n    }\n\n    return count;\n  }\n\n  /**\n   * Sync CarePlan resources (treatment plans)\n   */\n  async syncCarePlans(connectionId: string, patientId: string): Promise<number> {\n    const resources = await this.fhirClient.searchResources(\n      \'CarePlan\',\n      { patient: patientId, _sort: \'-date\' }\n    );\n\n    let count = 0;\n    for (const resource of resources) {\n      await this.storeCarePlan(connectionId, resource as CarePlanData);\n      count++;\n      await this.sleep(this.rateLimitDelay);\n    }\n\n    return count;\n  }\n\n  /**\n   * Sync Encounter resources (visits, appointments)\n   */\n  async syncEncounters(connectionId: string, patientId: string): Promise<number> {\n    const resources = await this.fhirClient.searchResources(\n      \'Encounter\',\n      { patient: patientId, _sort: \'-date\' }\n    );\n\n    let count = 0;\n    for (const resource of resources) {\n      await this.storeEncounter(connectionId, resource as EncounterData);\n      count++;\n      await this.sleep(this.rateLimitDelay);\n    }\n\n    return count;\n  }\n\n  /**\n   * Perform enhanced sync with all Epic-specific resources\n   */\n  async performEnhancedSync(connectionId: string): Promise<{\n    diagnosticReports: number;\n    carePlans: number;\n    encounters: number;\n    standardResources: number;\n  }> {\n    const connection = await prisma.eHRConnection.findUnique({\n      where: { id: connectionId },\n    });\n\n    if (!connection || !connection.patientId) {\n      throw new Error(\'Connection or patient ID not found\');\n    }\n\n    // Perform standard sync first\n    const standardCount = await this.syncService.syncConnection(connectionId);\n\n    // Sync Epic-specific resources\n    const diagnosticReports = await this.syncDiagnosticReports(connectionId, connection.patientId);\n    const carePlans = await this.syncCarePlans(connectionId, connection.patientId);\n    const encounters = await this.syncEncounters(connectionId, connection.patientId);\n\n    return {\n      diagnosticReports,\n      carePlans,\n      encounters,\n      standardResources: standardCount,\n    };\n  }\n\n  /**\n   * Store a DiagnosticReport with enhanced data extraction\n   */\n  private async storeDiagnosticReport(connectionId: string, resource: DiagnosticReportData): Promise<void> {\n    // Extract clinical notes from presentedForm\n    let clinicalNotes = resource.conclusion || \'\';\n    if (resource.presentedForm && resource.presentedForm.length > 0) {\n      const form = resource.presentedForm[0];\n      if (form.data) {\n        // Base64 decode if needed\n        try {\n          clinicalNotes += \'\\n\\n\' + Buffer.from(form.data, \'base64\').toString(\'utf-8\');\n        } catch (e) {\n          // Not base64, use as-is\n          clinicalNotes += \'\\n\\n\' + form.data;\n        }\n      }\n    }\n\n    // Store the base resource\n    const fhirResource = await prisma.fHIRResource.upsert({\n      where: {\n        connectionId_fhirId_resourceType: {\n          connectionId,\n          fhirId: resource.id,\n          resourceType: \'DIAGNOSTIC_REPORT\' as FHIRResourceType,\n        },\n      },\n      create: {\n        connectionId,\n        fhirId: resource.id,\n        resourceType: \'DIAGNOSTIC_REPORT\' as FHIRResourceType,\n        rawData: JSON.stringify(resource),\n        title: resource.code.text,\n        description: resource.conclusion,\n        date: resource.effectiveDateTime ? new Date(resource.effectiveDateTime) : null,\n        status: resource.status,\n        category: resource.category.join(\', \'),\n      },\n      update: {\n        rawData: JSON.stringify(resource),\n        title: resource.code.text,\n        description: resource.conclusion,\n        date: resource.effectiveDateTime ? new Date(resource.effectiveDateTime) : null,\n        status: resource.status,\n        category: resource.category.join(\', \'),\n      },\n    });\n\n    // Store Epic-specific data\n    await prisma.epicSpecificData.upsert({\n      where: { resourceId: fhirResource.id },\n      create: {\n        resourceId: fhirResource.id,\n        clinicalNotes,\n        labResultDetails: resource.result ? JSON.stringify(resource.result) : null,\n      },\n      update: {\n        clinicalNotes,\n        labResultDetails: resource.result ? JSON.stringify(resource.result) : null,\n      },\n    });\n  }\n\n  /**\n   * Store a CarePlan with enhanced data extraction\n   */\n  private async storeCarePlan(connectionId: string, resource: CarePlanData): Promise<void> {\n    // Extract care plan details\n    const carePlanDetails = {\n      activities: resource.activity?.map(a => ({\n        kind: a.detail?.kind,\n        code: a.detail?.code?.coding[0]?.display,\n        status: a.detail?.status,\n        description: a.detail?.description,\n      })) || [],\n      goals: resource.goal?.map(g => g.reference) || [],\n    };\n\n    // Store the base resource\n    const fhirResource = await prisma.fHIRResource.upsert({\n      where: {\n        connectionId_fhirId_resourceType: {\n          connectionId,\n          fhirId: resource.id,\n          resourceType: \'CARE_PLAN\' as FHIRResourceType,\n        },\n      },\n      create: {\n        connectionId,\n        fhirId: resource.id,\n        resourceType: \'CARE_PLAN\' as FHIRResourceType,\n        rawData: JSON.stringify(resource),\n        title: resource.title,\n        description: resource.description,\n        date: resource.period?.start ? new Date(resource.period.start) : null,\n        status: resource.status,\n        category: resource.category?.[0]?.coding[0]?.display,\n      },\n      update: {\n        rawData: JSON.stringify(resource),\n        title: resource.title,\n        description: resource.description,\n        date: resource.period?.start ? new Date(resource.period.start) : null,\n        status: resource.status,\n        category: resource.category?.[0]?.coding[0]?.display,\n      },\n    });\n\n    // Store Epic-specific data\n    await prisma.epicSpecificData.upsert({\n      where: { resourceId: fhirResource.id },\n      create: {\n        resourceId: fhirResource.id,\n        carePlanDetails: JSON.stringify(carePlanDetails),\n      },\n      update: {\n        carePlanDetails: JSON.stringify(carePlanDetails),\n      },\n    });\n  }\n\n  /**\n   * Store an Encounter with enhanced data extraction\n   */\n  private async storeEncounter(connectionId: string, resource: EncounterData): Promise<void> {\n    // Extract encounter details\n    const encounterDetails = {\n      class: resource.class.display,\n      type: resource.type?.[0]?.coding[0]?.display,\n      reasonCode: resource.reasonCode?.map(r => r.coding[0]?.display) || [],\n      diagnoses: resource.diagnosis?.map(d => ({\n        condition: d.condition.reference,\n        use: d.use?.coding[0]?.display,\n      })) || [],\n      hospitalization: resource.hospitalization,\n    };\n\n    // Store the base resource\n    const fhirResource = await prisma.fHIRResource.upsert({\n      where: {\n        connectionId_fhirId_resourceType: {\n          connectionId,\n          fhirId: resource.id,\n          resourceType: \'ENCOUNTER\' as FHIRResourceType,\n        },\n      },\n      create: {\n        connectionId,\n        fhirId: resource.id,\n        resourceType: \'ENCOUNTER\' as FHIRResourceType,\n        rawData: JSON.stringify(resource),\n        title: resource.type?.[0]?.text || resource.class.display,\n        description: resource.reasonCode?.[0]?.text,\n        date: resource.period?.start ? new Date(resource.period.start) : null,\n        status: resource.status,\n        category: resource.class.display,\n      },\n      update: {\n        rawData: JSON.stringify(resource),\n        title: resource.type?.[0]?.text || resource.class.display,\n        description: resource.reasonCode?.[0]?.text,\n        date: resource.period?.start ? new Date(resource.period.start) : null,\n        status: resource.status,\n        category: resource.class.display,\n      },\n    });\n\n    // Store Epic-specific data\n    await prisma.epicSpecificData.upsert({\n      where: { resourceId: fhirResource.id },\n      create: {\n        resourceId: fhirResource.id,\n        encounterDetails: JSON.stringify(encounterDetails),\n      },\n      update: {\n        encounterDetails: JSON.stringify(encounterDetails),\n      },\n    });\n  }\n\n  /**\n   * Store a generic resource from bulk export\n   */\n  private async storeResource(connectionId: string, resource: any): Promise<void> {\n    const resourceType = resource.resourceType;\n    \n    // Map FHIR resource type to our enum\n    const typeMap: Record<string, FHIRResourceType> = {\n      \'Patient\': \'PATIENT\',\n      \'DocumentReference\': \'DOCUMENT_REFERENCE\',\n      \'Observation\': \'OBSERVATION\',\n      \'Condition\': \'CONDITION\',\n      \'MedicationRequest\': \'MEDICATION_REQUEST\',\n      \'AllergyIntolerance\': \'ALLERGY_INTOLERANCE\',\n      \'Immunization\': \'IMMUNIZATION\',\n      \'Procedure\': \'PROCEDURE\',\n      \'DiagnosticReport\': \'DIAGNOSTIC_REPORT\',\n      \'CarePlan\': \'CARE_PLAN\',\n      \'Encounter\': \'ENCOUNTER\',\n    };\n\n    const mappedType = typeMap[resourceType];\n    if (!mappedType) {\n      console.warn(`Unknown resource type: ${resourceType}`);\n      return;\n    }\n\n    // Store the resource\n    await prisma.fHIRResource.upsert({\n      where: {\n        connectionId_fhirId_resourceType: {\n          connectionId,\n          fhirId: resource.id,\n          resourceType: mappedType,\n        },\n      },\n      create: {\n        connectionId,\n        fhirId: resource.id,\n        resourceType: mappedType,\n        rawData: JSON.stringify(resource),\n      },\n      update: {\n        rawData: JSON.stringify(resource),\n      },\n    });\n  }\n\n  /**\n   * Sleep for rate limiting\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n</create-file>\n</function_calls>'}