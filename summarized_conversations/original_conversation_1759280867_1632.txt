{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="lib/services/AccessControlService.ts">\n/**\n * Access Control Service\n * Handles role-based access control (RBAC) for HoloVitals\n */\n\nimport {\n  UserRole,\n  Permission,\n  ROLE_PERMISSIONS,\n  ROLE_HIERARCHY,\n  ResourceType,\n  AccessControlContext,\n  AccessDecision,\n  AccessAuditLog,\n} from \'../types/rbac\';\nimport { prisma } from \'../prisma\';\n\nexport class AccessControlService {\n  private static instance: AccessControlService;\n\n  private constructor() {}\n\n  public static getInstance(): AccessControlService {\n    if (!AccessControlService.instance) {\n      AccessControlService.instance = new AccessControlService();\n    }\n    return AccessControlService.instance;\n  }\n\n  // ============================================================================\n  // PERMISSION CHECKING\n  // ============================================================================\n\n  /**\n   * Check if a user has a specific permission\n   */\n  public hasPermission(role: UserRole, permission: Permission): boolean {\n    const rolePermissions = ROLE_PERMISSIONS[role];\n    return rolePermissions.includes(permission);\n  }\n\n  /**\n   * Check if a user has any of the specified permissions\n   */\n  public hasAnyPermission(role: UserRole, permissions: Permission[]): boolean {\n    return permissions.some(permission => this.hasPermission(role, permission));\n  }\n\n  /**\n   * Check if a user has all of the specified permissions\n   */\n  public hasAllPermissions(role: UserRole, permissions: Permission[]): boolean {\n    return permissions.every(permission => this.hasPermission(role, permission));\n  }\n\n  /**\n   * Get all permissions for a role\n   */\n  public getRolePermissions(role: UserRole): Permission[] {\n    return ROLE_PERMISSIONS[role];\n  }\n\n  // ============================================================================\n  // ROLE CHECKING\n  // ============================================================================\n\n  /**\n   * Check if a role has sufficient hierarchy level\n   */\n  public hasRoleLevel(userRole: UserRole, requiredRole: UserRole): boolean {\n    return ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY[requiredRole];\n  }\n\n  /**\n   * Check if user is owner\n   */\n  public isOwner(role: UserRole): boolean {\n    return role === UserRole.OWNER;\n  }\n\n  /**\n   * Check if user is admin or higher\n   */\n  public isAdminOrHigher(role: UserRole): boolean {\n    return this.hasRoleLevel(role, UserRole.ADMIN);\n  }\n\n  // ============================================================================\n  // RESOURCE ACCESS CONTROL\n  // ============================================================================\n\n  /**\n   * Check if user can access a specific resource\n   */\n  public async canAccessResource(\n    context: AccessControlContext\n  ): Promise<AccessDecision> {\n    const { userId, role, permissions, resourceType, resourceId, resourceOwnerId } = context;\n\n    // OWNER can access everything\n    if (role === UserRole.OWNER) {\n      return { allowed: true, reason: \'Owner has full access\' };\n    }\n\n    // Check if user has required permissions\n    const hasRequiredPermissions = permissions.every(permission =>\n      this.hasPermission(role, permission)\n    );\n\n    if (!hasRequiredPermissions) {\n      return {\n        allowed: false,\n        reason: \'Insufficient permissions\',\n        requiredPermission: permissions[0],\n      };\n    }\n\n    // Resource-specific access control\n    if (resourceType && resourceId) {\n      // Check if user owns the resource\n      if (resourceOwnerId && resourceOwnerId === userId) {\n        return { allowed: true, reason: \'User owns the resource\' };\n      }\n\n      // Check resource-specific permissions\n      switch (resourceType) {\n        case ResourceType.PATIENT:\n          return this.canAccessPatientData(role, userId, resourceId);\n        \n        case ResourceType.DOCUMENT:\n          return this.canAccessDocument(role, userId, resourceId);\n        \n        case ResourceType.CONVERSATION:\n          return this.canAccessConversation(role, userId, resourceId);\n        \n        case ResourceType.COST:\n        case ResourceType.FINANCIAL:\n          return this.canAccessFinancialData(role);\n        \n        case ResourceType.INSTANCE:\n          return this.canAccessInstance(role, userId, resourceId);\n        \n        default:\n          return { allowed: true };\n      }\n    }\n\n    return { allowed: true };\n  }\n\n  /**\n   * Check if user can access patient data\n   */\n  private async canAccessPatientData(\n    role: UserRole,\n    userId: string,\n    patientId: string\n  ): Promise<AccessDecision> {\n    // OWNER and ADMIN can access all patient data\n    if (this.isAdminOrHigher(role)) {\n      return { allowed: true, reason: \'Admin access to patient data\' };\n    }\n\n    // PATIENT can only access their own data\n    if (role === UserRole.PATIENT) {\n      if (userId === patientId) {\n        return { allowed: true, reason: \'User accessing own data\' };\n      }\n      return {\n        allowed: false,\n        reason: \'Patients can only access their own data\',\n      };\n    }\n\n    // DOCTOR needs consent to access patient data\n    if (role === UserRole.DOCTOR) {\n      const hasConsent = await this.checkPatientConsent(userId, patientId);\n      if (hasConsent) {\n        return { allowed: true, reason: \'Doctor has patient consent\' };\n      }\n      return {\n        allowed: false,\n        reason: \'Doctor requires patient consent\',\n      };\n    }\n\n    // SUPPORT can view with proper permissions\n    if (role === UserRole.SUPPORT) {\n      return { allowed: true, reason: \'Support access for assistance\' };\n    }\n\n    return { allowed: false, reason: \'Insufficient role for patient data access\' };\n  }\n\n  /**\n   * Check if user can access document\n   */\n  private async canAccessDocument(\n    role: UserRole,\n    userId: string,\n    documentId: string\n  ): Promise<AccessDecision> {\n    // OWNER and ADMIN can access all documents\n    if (this.isAdminOrHigher(role)) {\n      return { allowed: true, reason: \'Admin access to documents\' };\n    }\n\n    // Check if user owns the document\n    const document = await prisma.document.findUnique({\n      where: { id: documentId },\n      select: { userId: true },\n    });\n\n    if (!document) {\n      return { allowed: false, reason: \'Document not found\' };\n    }\n\n    if (document.userId === userId) {\n      return { allowed: true, reason: \'User owns the document\' };\n    }\n\n    // SUPPORT can view documents\n    if (role === UserRole.SUPPORT) {\n      return { allowed: true, reason: \'Support access to documents\' };\n    }\n\n    return { allowed: false, reason: \'User does not own this document\' };\n  }\n\n  /**\n   * Check if user can access conversation\n   */\n  private async canAccessConversation(\n    role: UserRole,\n    userId: string,\n    conversationId: string\n  ): Promise<AccessDecision> {\n    // OWNER and ADMIN can access all conversations\n    if (this.isAdminOrHigher(role)) {\n      return { allowed: true, reason: \'Admin access to conversations\' };\n    }\n\n    // Check if user owns the conversation\n    const conversation = await prisma.conversation.findUnique({\n      where: { id: conversationId },\n      select: { userId: true },\n    });\n\n    if (!conversation) {\n      return { allowed: false, reason: \'Conversation not found\' };\n    }\n\n    if (conversation.userId === userId) {\n      return { allowed: true, reason: \'User owns the conversation\' };\n    }\n\n    return { allowed: false, reason: \'User does not own this conversation\' };\n  }\n\n  /**\n   * Check if user can access financial data\n   */\n  private canAccessFinancialData(role: UserRole): AccessDecision {\n    // Only OWNER can access financial data\n    if (role === UserRole.OWNER) {\n      return { allowed: true, reason: \'Owner access to financial data\' };\n    }\n\n    return {\n      allowed: false,\n      reason: \'Only owner can access financial data\',\n      requiredRole: UserRole.OWNER,\n    };\n  }\n\n  /**\n   * Check if user can access instance\n   */\n  private async canAccessInstance(\n    role: UserRole,\n    userId: string,\n    instanceId: string\n  ): Promise<AccessDecision> {\n    // OWNER and ADMIN can access all instances\n    if (this.isAdminOrHigher(role)) {\n      return { allowed: true, reason: \'Admin access to instances\' };\n    }\n\n    // Check if user owns the instance\n    const instance = await prisma.cloudInstance.findUnique({\n      where: { id: instanceId },\n      select: { userId: true },\n    });\n\n    if (!instance) {\n      return { allowed: false, reason: \'Instance not found\' };\n    }\n\n    if (instance.userId === userId) {\n      return { allowed: true, reason: \'User owns the instance\' };\n    }\n\n    return { allowed: false, reason: \'User does not own this instance\' };\n  }\n\n  /**\n   * Check patient consent for doctor access\n   */\n  private async checkPatientConsent(\n    doctorId: string,\n    patientId: string\n  ): Promise<boolean> {\n    const consent = await prisma.consentGrant.findFirst({\n      where: {\n        patientId,\n        grantedToUserId: doctorId,\n        status: \'ACTIVE\',\n        expiresAt: {\n          gt: new Date(),\n        },\n      },\n    });\n\n    return !!consent;\n  }\n\n  // ============================================================================\n  // AUDIT LOGGING\n  // ============================================================================\n\n  /**\n   * Log access attempt\n   */\n  public async logAccess(\n    context: AccessControlContext,\n    action: string,\n    decision: AccessDecision,\n    metadata?: {\n      ipAddress?: string;\n      userAgent?: string;\n    }\n  ): Promise<void> {\n    try {\n      await prisma.accessLog.create({\n        data: {\n          userId: context.userId,\n          action,\n          resourceType: context.resourceType || \'UNKNOWN\',\n          resourceId: context.resourceId,\n          allowed: decision.allowed,\n          reason: decision.reason,\n          ipAddress: metadata?.ipAddress,\n          userAgent: metadata?.userAgent,\n          timestamp: new Date(),\n        },\n      });\n    } catch (error) {\n      console.error(\'Failed to log access:\', error);\n    }\n  }\n\n  /**\n   * Get access logs for a user\n   */\n  public async getUserAccessLogs(\n    userId: string,\n    limit: number = 100\n  ): Promise<AccessAuditLog[]> {\n    const logs = await prisma.accessLog.findMany({\n      where: { userId },\n      orderBy: { timestamp: \'desc\' },\n      take: limit,\n    });\n\n    return logs.map(log => ({\n      id: log.id,\n      timestamp: log.timestamp,\n      userId: log.userId,\n      userRole: UserRole.PATIENT, // Would need to fetch from user\n      action: log.action,\n      resourceType: log.resourceType as ResourceType,\n      resourceId: log.resourceId || undefined,\n      permission: Permission.VIEW_OWN_DATA, // Would need to determine from action\n      allowed: log.allowed,\n      reason: log.reason || undefined,\n      ipAddress: log.ipAddress || undefined,\n      userAgent: log.userAgent || undefined,\n    }));\n  }\n\n  /**\n   * Get suspicious access patterns\n   */\n  public async getSuspiciousAccess(\n    timeWindowMinutes: number = 60\n  ): Promise<AccessAuditLog[]> {\n    const since = new Date(Date.now() - timeWindowMinutes * 60 * 1000);\n\n    // Find users with many failed access attempts\n    const suspiciousLogs = await prisma.accessLog.findMany({\n      where: {\n        timestamp: { gte: since },\n        allowed: false,\n      },\n      orderBy: { timestamp: \'desc\' },\n    });\n\n    // Group by user and count failures\n    const userFailures = new Map<string, number>();\n    suspiciousLogs.forEach(log => {\n      const count = userFailures.get(log.userId) || 0;\n      userFailures.set(log.userId, count + 1);\n    });\n\n    // Return logs for users with >5 failures\n    const suspiciousUserIds = Array.from(userFailures.entries())\n      .filter(([_, count]) => count > 5)\n      .map(([userId]) => userId);\n\n    const logs = await prisma.accessLog.findMany({\n      where: {\n        userId: { in: suspiciousUserIds },\n        timestamp: { gte: since },\n      },\n      orderBy: { timestamp: \'desc\' },\n    });\n\n    return logs.map(log => ({\n      id: log.id,\n      timestamp: log.timestamp,\n      userId: log.userId,\n      userRole: UserRole.PATIENT,\n      action: log.action,\n      resourceType: log.resourceType as ResourceType,\n      resourceId: log.resourceId || undefined,\n      permission: Permission.VIEW_OWN_DATA,\n      allowed: log.allowed,\n      reason: log.reason || undefined,\n      ipAddress: log.ipAddress || undefined,\n      userAgent: log.userAgent || undefined,\n    }));\n  }\n\n  // ============================================================================\n  // UTILITY METHODS\n  // ============================================================================\n\n  /**\n   * Get user role from database\n   */\n  public async getUserRole(userId: string): Promise<UserRole | null> {\n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      select: { role: true },\n    });\n\n    return user?.role as UserRole | null;\n  }\n\n  /**\n   * Update user role\n   */\n  public async updateUserRole(\n    userId: string,\n    newRole: UserRole,\n    updatedBy: string\n  ): Promise<void> {\n    // Only OWNER can change roles\n    const updaterRole = await this.getUserRole(updatedBy);\n    if (updaterRole !== UserRole.OWNER) {\n      throw new Error(\'Only owner can change user roles\');\n    }\n\n    await prisma.user.update({\n      where: { id: userId },\n      data: { role: newRole },\n    });\n\n    // Log the role change\n    await prisma.auditLog.create({\n      data: {\n        userId: updatedBy,\n        action: \'ROLE_CHANGE\',\n        resourceType: \'USER\',\n        resourceId: userId,\n        details: { newRole },\n        timestamp: new Date(),\n      },\n    });\n  }\n\n  /**\n   * Check if route is protected\n   */\n  public isProtectedRoute(path: string): boolean {\n    const protectedPaths = [\n      \'/dashboard/costs\',\n      \'/dashboard/financials\',\n      \'/dashboard/admin\',\n      \'/dashboard/users\',\n      \'/api/costs\',\n      \'/api/admin\',\n      \'/api/financials\',\n    ];\n\n    return protectedPaths.some(protectedPath =>\n      path.startsWith(protectedPath)\n    );\n  }\n\n  /**\n   * Get required permissions for a route\n   */\n  public getRoutePermissions(path: string): Permission[] {\n    if (path.startsWith(\'/dashboard/costs\') || path.startsWith(\'/api/costs\')) {\n      return [Permission.VIEW_COSTS];\n    }\n    if (path.startsWith(\'/dashboard/financials\') || path.startsWith(\'/api/financials\')) {\n      return [Permission.VIEW_FINANCIALS];\n    }\n    if (path.startsWith(\'/dashboard/admin\') || path.startsWith(\'/api/admin\')) {\n      return [Permission.VIEW_SYSTEM_STATS];\n    }\n    if (path.startsWith(\'/dashboard/users\')) {\n      return [Permission.VIEW_ALL_USERS];\n    }\n    if (path.startsWith(\'/dashboard/instances\') || path.startsWith(\'/api/instances\')) {\n      return [Permission.VIEW_ALL_INSTANCES];\n    }\n    if (path.startsWith(\'/dashboard/queue\') || path.startsWith(\'/api/queue\')) {\n      return [Permission.VIEW_ALL_TASKS];\n    }\n\n    return [];\n  }\n}\n\n// Export singleton instance\nexport const accessControl = AccessControlService.getInstance();\n</create-file>\n</function_calls>'}