{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/identity/IdentityVerificationService.ts">\n/**\n * Identity Verification Service for HoloVitals\n * \n * Verifies patient identity using multiple factors to ensure:\n * - One repository per patient\n * - Prevent duplicate accounts\n * - Secure account migration\n * - Identity-based repository access\n */\n\nimport crypto from \'crypto\';\nimport { PrismaClient } from \'@prisma/client\';\n\nconst prisma = new PrismaClient();\n\nexport interface IdentityFactors {\n  // Primary Identifiers (Required)\n  dateOfBirth: Date;\n  fullName: {\n    firstName: string;\n    middleName?: string;\n    lastName: string;\n  };\n  placeOfBirth: {\n    city: string;\n    state: string;\n    country: string;\n  };\n  \n  // Secondary Identifiers (Recommended - at least 2)\n  socialSecurityNumber?: string; // Last 4 digits only\n  mothersMaidenName?: string;\n  medicalRecordNumber?: string;\n  previousAddress?: {\n    street: string;\n    city: string;\n    state: string;\n    zipCode: string;\n  };\n  phoneNumber?: string; // For verification\n  \n  // Biometric Identifiers (Optional - future)\n  biometricHash?: string;\n}\n\nexport interface IdentityVerificationResult {\n  verified: boolean;\n  confidence: number; // 0-1 score\n  matchedFactors: string[];\n  existingRepositoryId?: string;\n  requiresAdditionalVerification: boolean;\n  verificationMethod: string;\n}\n\nexport interface IdentityHash {\n  primaryHash: string;    // Hash of primary identifiers\n  secondaryHash: string;  // Hash of secondary identifiers\n  compositeHash: string;  // Combined hash for uniqueness\n}\n\nexport class IdentityVerificationService {\n  private readonly HASH_ALGORITHM = \'sha256\';\n  private readonly HASH_ITERATIONS = 10000;\n  private readonly MIN_CONFIDENCE_THRESHOLD = 0.85;\n\n  /**\n   * Generate identity hash from factors\n   * This creates a unique identifier without storing PII\n   */\n  generateIdentityHash(factors: IdentityFactors): IdentityHash {\n    // Normalize data for consistent hashing\n    const normalized = this.normalizeIdentityFactors(factors);\n\n    // Primary hash: DOB + Full Name + Place of Birth\n    const primaryData = [\n      normalized.dateOfBirth,\n      normalized.fullName.firstName,\n      normalized.fullName.middleName || \'\',\n      normalized.fullName.lastName,\n      normalized.placeOfBirth.city,\n      normalized.placeOfBirth.state,\n      normalized.placeOfBirth.country\n    ].join(\'|\');\n\n    const primaryHash = this.hashData(primaryData);\n\n    // Secondary hash: Additional identifiers\n    const secondaryData = [\n      normalized.socialSecurityNumber || \'\',\n      normalized.mothersMaidenName || \'\',\n      normalized.medicalRecordNumber || \'\',\n      normalized.phoneNumber || \'\'\n    ].join(\'|\');\n\n    const secondaryHash = this.hashData(secondaryData);\n\n    // Composite hash: Combination of both\n    const compositeHash = this.hashData(primaryHash + secondaryHash);\n\n    return {\n      primaryHash,\n      secondaryHash,\n      compositeHash\n    };\n  }\n\n  /**\n   * Verify identity and check for existing repository\n   */\n  async verifyIdentity(factors: IdentityFactors): Promise<IdentityVerificationResult> {\n    // Generate identity hashes\n    const identityHash = this.generateIdentityHash(factors);\n\n    // Check for existing repository with same identity\n    const existingRepository = await this.findRepositoryByIdentity(identityHash);\n\n    if (existingRepository) {\n      // Found existing repository - verify it\'s the same person\n      const verification = await this.verifyAgainstExisting(\n        factors,\n        existingRepository\n      );\n\n      return {\n        verified: verification.isMatch,\n        confidence: verification.confidence,\n        matchedFactors: verification.matchedFactors,\n        existingRepositoryId: existingRepository.id,\n        requiresAdditionalVerification: verification.confidence < this.MIN_CONFIDENCE_THRESHOLD,\n        verificationMethod: \'existing_repository_match\'\n      };\n    }\n\n    // No existing repository - verify identity is valid\n    const validation = this.validateIdentityFactors(factors);\n\n    return {\n      verified: validation.isValid,\n      confidence: validation.confidence,\n      matchedFactors: validation.providedFactors,\n      requiresAdditionalVerification: validation.confidence < this.MIN_CONFIDENCE_THRESHOLD,\n      verificationMethod: \'new_identity_validation\'\n    };\n  }\n\n  /**\n   * Check if identity already has a repository\n   */\n  async hasExistingRepository(factors: IdentityFactors): Promise<boolean> {\n    const identityHash = this.generateIdentityHash(factors);\n    const existing = await this.findRepositoryByIdentity(identityHash);\n    return existing !== null;\n  }\n\n  /**\n   * Verify identity for account migration\n   */\n  async verifyForMigration(\n    repositoryId: string,\n    factors: IdentityFactors,\n    additionalVerification: {\n      currentEmail: string;\n      mfaToken?: string;\n      securityQuestionAnswers?: Record<string, string>;\n    }\n  ): Promise<IdentityVerificationResult> {\n    // Get existing repository\n    const repository = await this.getRepository(repositoryId);\n    \n    if (!repository) {\n      return {\n        verified: false,\n        confidence: 0,\n        matchedFactors: [],\n        requiresAdditionalVerification: true,\n        verificationMethod: \'migration_verification\'\n      };\n    }\n\n    // Verify identity matches repository\n    const identityMatch = await this.verifyAgainstExisting(factors, repository);\n\n    // Verify additional factors\n    const emailMatch = repository.email === additionalVerification.currentEmail;\n    \n    let mfaVerified = true;\n    if (additionalVerification.mfaToken) {\n      // Verify MFA token\n      mfaVerified = await this.verifyMFAToken(\n        repository.userId,\n        additionalVerification.mfaToken\n      );\n    }\n\n    // Calculate overall confidence\n    const confidence = (\n      identityMatch.confidence * 0.6 +\n      (emailMatch ? 0.2 : 0) +\n      (mfaVerified ? 0.2 : 0)\n    );\n\n    return {\n      verified: confidence >= this.MIN_CONFIDENCE_THRESHOLD,\n      confidence,\n      matchedFactors: [\n        ...identityMatch.matchedFactors,\n        emailMatch ? \'email\' : \'\',\n        mfaVerified ? \'mfa\' : \'\'\n      ].filter(Boolean),\n      existingRepositoryId: repositoryId,\n      requiresAdditionalVerification: confidence < this.MIN_CONFIDENCE_THRESHOLD,\n      verificationMethod: \'migration_verification\'\n    };\n  }\n\n  /**\n   * Generate verification challenge for additional verification\n   */\n  async generateVerificationChallenge(\n    repositoryId: string\n  ): Promise<VerificationChallenge> {\n    const repository = await this.getRepository(repositoryId);\n    \n    if (!repository) {\n      throw new Error(\'Repository not found\');\n    }\n\n    // Generate challenge based on stored data\n    const challenges: ChallengeQuestion[] = [];\n\n    // DOB challenge\n    challenges.push({\n      type: \'date_of_birth\',\n      question: \'What is your date of birth?\',\n      expectedFormat: \'MM/DD/YYYY\'\n    });\n\n    // Place of birth challenge\n    challenges.push({\n      type: \'place_of_birth\',\n      question: \'What city were you born in?\',\n      expectedFormat: \'City name\'\n    });\n\n    // Additional challenges based on available data\n    if (repository.hasMothersMaidenName) {\n      challenges.push({\n        type: \'mothers_maiden_name\',\n        question: "What is your mother\'s maiden name?",\n        expectedFormat: \'Last name\'\n      });\n    }\n\n    if (repository.hasPreviousAddress) {\n      challenges.push({\n        type: \'previous_address\',\n        question: \'What was your previous street address?\',\n        expectedFormat: \'Street address\'\n      });\n    }\n\n    // Select 3 random challenges\n    const selectedChallenges = this.selectRandomChallenges(challenges, 3);\n\n    const challengeId = this.generateChallengeId();\n\n    // Store challenge\n    await this.storeChallenge(challengeId, repositoryId, selectedChallenges);\n\n    return {\n      challengeId,\n      challenges: selectedChallenges,\n      expiresAt: new Date(Date.now() + 15 * 60 * 1000) // 15 minutes\n    };\n  }\n\n  /**\n   * Verify challenge responses\n   */\n  async verifyChallenge(\n    challengeId: string,\n    responses: Record<string, string>\n  ): Promise<boolean> {\n    const challenge = await this.getChallenge(challengeId);\n    \n    if (!challenge) {\n      throw new Error(\'Challenge not found or expired\');\n    }\n\n    const repository = await this.getRepository(challenge.repositoryId);\n    \n    if (!repository) {\n      throw new Error(\'Repository not found\');\n    }\n\n    let correctAnswers = 0;\n    const totalQuestions = challenge.questions.length;\n\n    for (const question of challenge.questions) {\n      const userAnswer = responses[question.type];\n      const isCorrect = await this.verifyAnswer(\n        question.type,\n        userAnswer,\n        repository\n      );\n\n      if (isCorrect) {\n        correctAnswers++;\n      }\n    }\n\n    // Require all answers to be correct\n    const verified = correctAnswers === totalQuestions;\n\n    // Delete challenge after verification\n    await this.deleteChallenge(challengeId);\n\n    return verified;\n  }\n\n  // Private helper methods\n\n  private normalizeIdentityFactors(factors: IdentityFactors): IdentityFactors {\n    return {\n      dateOfBirth: factors.dateOfBirth,\n      fullName: {\n        firstName: factors.fullName.firstName.toLowerCase().trim(),\n        middleName: factors.fullName.middleName?.toLowerCase().trim(),\n        lastName: factors.fullName.lastName.toLowerCase().trim()\n      },\n      placeOfBirth: {\n        city: factors.placeOfBirth.city.toLowerCase().trim(),\n        state: factors.placeOfBirth.state.toLowerCase().trim(),\n        country: factors.placeOfBirth.country.toLowerCase().trim()\n      },\n      socialSecurityNumber: factors.socialSecurityNumber?.replace(/\\D/g, \'\'),\n      mothersMaidenName: factors.mothersMaidenName?.toLowerCase().trim(),\n      medicalRecordNumber: factors.medicalRecordNumber?.toUpperCase().trim(),\n      previousAddress: factors.previousAddress ? {\n        street: factors.previousAddress.street.toLowerCase().trim(),\n        city: factors.previousAddress.city.toLowerCase().trim(),\n        state: factors.previousAddress.state.toLowerCase().trim(),\n        zipCode: factors.previousAddress.zipCode.replace(/\\D/g, \'\')\n      } : undefined,\n      phoneNumber: factors.phoneNumber?.replace(/\\D/g, \'\')\n    };\n  }\n\n  private hashData(data: string): string {\n    return crypto\n      .pbkdf2Sync(data, process.env.IDENTITY_SALT || \'holovitals-salt\', this.HASH_ITERATIONS, 64, this.HASH_ALGORITHM)\n      .toString(\'hex\');\n  }\n\n  private async findRepositoryByIdentity(identityHash: IdentityHash): Promise<any> {\n    const result = await prisma.$queryRaw<any[]>`\n      SELECT * FROM patient_repositories \n      WHERE composite_identity_hash = ${identityHash.compositeHash}\n      LIMIT 1\n    `;\n\n    return result && result.length > 0 ? result[0] : null;\n  }\n\n  private async verifyAgainstExisting(\n    factors: IdentityFactors,\n    repository: any\n  ): Promise<{ isMatch: boolean; confidence: number; matchedFactors: string[] }> {\n    const matchedFactors: string[] = [];\n    let matchScore = 0;\n    let totalFactors = 0;\n\n    // Verify primary factors\n    const identityHash = this.generateIdentityHash(factors);\n    \n    if (identityHash.primaryHash === repository.primary_identity_hash) {\n      matchedFactors.push(\'primary_identity\');\n      matchScore += 3; // Primary factors are weighted heavily\n    }\n    totalFactors += 3;\n\n    if (identityHash.secondaryHash === repository.secondary_identity_hash) {\n      matchedFactors.push(\'secondary_identity\');\n      matchScore += 2;\n    }\n    totalFactors += 2;\n\n    const confidence = matchScore / totalFactors;\n\n    return {\n      isMatch: confidence >= this.MIN_CONFIDENCE_THRESHOLD,\n      confidence,\n      matchedFactors\n    };\n  }\n\n  private validateIdentityFactors(factors: IdentityFactors): {\n    isValid: boolean;\n    confidence: number;\n    providedFactors: string[];\n  } {\n    const providedFactors: string[] = [];\n    let score = 0;\n\n    // Primary factors (required)\n    if (factors.dateOfBirth) {\n      providedFactors.push(\'date_of_birth\');\n      score += 1;\n    }\n    if (factors.fullName.firstName && factors.fullName.lastName) {\n      providedFactors.push(\'full_name\');\n      score += 1;\n    }\n    if (factors.placeOfBirth.city && factors.placeOfBirth.state && factors.placeOfBirth.country) {\n      providedFactors.push(\'place_of_birth\');\n      score += 1;\n    }\n\n    // Secondary factors (recommended)\n    if (factors.socialSecurityNumber) {\n      providedFactors.push(\'ssn\');\n      score += 0.5;\n    }\n    if (factors.mothersMaidenName) {\n      providedFactors.push(\'mothers_maiden_name\');\n      score += 0.5;\n    }\n    if (factors.medicalRecordNumber) {\n      providedFactors.push(\'medical_record_number\');\n      score += 0.5;\n    }\n    if (factors.previousAddress) {\n      providedFactors.push(\'previous_address\');\n      score += 0.5;\n    }\n    if (factors.phoneNumber) {\n      providedFactors.push(\'phone_number\');\n      score += 0.5;\n    }\n\n    // Minimum: 3 primary factors + 2 secondary factors\n    const hasMinimumFactors = score >= 4;\n    const confidence = Math.min(score / 5, 1); // Max score of 5\n\n    return {\n      isValid: hasMinimumFactors,\n      confidence,\n      providedFactors\n    };\n  }\n\n  private async getRepository(repositoryId: string): Promise<any> {\n    const result = await prisma.$queryRaw<any[]>`\n      SELECT * FROM patient_repositories WHERE id = ${repositoryId}\n    `;\n\n    return result && result.length > 0 ? result[0] : null;\n  }\n\n  private async verifyMFAToken(userId: string, token: string): Promise<boolean> {\n    // This would integrate with AuthService\n    // For now, return true as placeholder\n    return true;\n  }\n\n  private selectRandomChallenges(challenges: ChallengeQuestion[], count: number): ChallengeQuestion[] {\n    const shuffled = [...challenges].sort(() => Math.random() - 0.5);\n    return shuffled.slice(0, Math.min(count, challenges.length));\n  }\n\n  private generateChallengeId(): string {\n    return `challenge_${Date.now()}_${Math.random().toString(36).substr(2, 12)}`;\n  }\n\n  private async storeChallenge(\n    challengeId: string,\n    repositoryId: string,\n    questions: ChallengeQuestion[]\n  ): Promise<void> {\n    await prisma.$executeRaw`\n      INSERT INTO identity_challenges (id, repository_id, questions, expires_at, created_at)\n      VALUES (${challengeId}, ${repositoryId}, ${JSON.stringify(questions)}, \n              NOW() + INTERVAL \'15 minutes\', NOW())\n    `;\n  }\n\n  private async getChallenge(challengeId: string): Promise<any> {\n    const result = await prisma.$queryRaw<any[]>`\n      SELECT * FROM identity_challenges \n      WHERE id = ${challengeId} AND expires_at > NOW()\n    `;\n\n    if (!result || result.length === 0) {\n      return null;\n    }\n\n    return {\n      challengeId: result[0].id,\n      repositoryId: result[0].repository_id,\n      questions: JSON.parse(result[0].questions),\n      expiresAt: result[0].expires_at\n    };\n  }\n\n  private async deleteChallenge(challengeId: string): Promise<void> {\n    await prisma.$executeRaw`\n      DELETE FROM identity_challenges WHERE id = ${challengeId}\n    `;\n  }\n\n  private async verifyAnswer(\n    questionType: string,\n    userAnswer: string,\n    repository: any\n  ): Promise<boolean> {\n    const normalized = userAnswer.toLowerCase().trim();\n\n    switch (questionType) {\n      case \'date_of_birth\':\n        const dob = new Date(repository.date_of_birth);\n        const userDob = new Date(userAnswer);\n        return dob.getTime() === userDob.getTime();\n\n      case \'place_of_birth\':\n        return normalized === repository.place_of_birth_city.toLowerCase();\n\n      case \'mothers_maiden_name\':\n        // Compare hashes\n        const hashedAnswer = this.hashData(normalized);\n        return hashedAnswer === repository.mothers_maiden_name_hash;\n\n      case \'previous_address\':\n        const hashedAddress = this.hashData(normalized);\n        return hashedAddress === repository.previous_address_hash;\n\n      default:\n        return false;\n    }\n  }\n}\n\nexport interface VerificationChallenge {\n  challengeId: string;\n  challenges: ChallengeQuestion[];\n  expiresAt: Date;\n}\n\nexport interface ChallengeQuestion {\n  type: string;\n  question: string;\n  expectedFormat: string;\n}\n\nexport const identityVerificationService = new IdentityVerificationService();\n</create-file>\n</function_calls>'}