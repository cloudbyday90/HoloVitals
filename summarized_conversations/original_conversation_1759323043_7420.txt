{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="lib/services/EClinicalWorksEnhancedService.ts">\n/**\n * eClinicalWorks Enhanced Service\n * \n * Provides enhanced integration with eClinicalWorks EHR system including:\n * - Bulk data export using FHIR $export\n * - Enhanced resource types (DiagnosticReport, CarePlan, Encounter)\n * - Patient portal integration\n * - Clinical documentation\n * - Telehealth integration\n * - Rate limiting (7 requests/second)\n * \n * Market Share: 5% of US healthcare\n * FHIR Version: R4\n */\n\nimport { PrismaClient } from \'@prisma/client\';\nimport { FHIRClient } from \'../fhir/FHIRClient\';\n\nconst prisma = new PrismaClient();\n\n// eClinicalWorks-specific resource types\nexport enum EClinicalWorksResourceType {\n  DIAGNOSTIC_REPORT = \'DiagnosticReport\',\n  CARE_PLAN = \'CarePlan\',\n  ENCOUNTER = \'Encounter\',\n  COMMUNICATION = \'Communication\',\n  TASK = \'Task\',\n}\n\n// Bulk export job status\nexport enum BulkExportStatus {\n  PENDING = \'PENDING\',\n  IN_PROGRESS = \'IN_PROGRESS\',\n  COMPLETED = \'COMPLETED\',\n  FAILED = \'FAILED\',\n}\n\n// Bulk export type\nexport enum BulkExportType {\n  PATIENT = \'Patient\',\n  GROUP = \'Group\',\n  SYSTEM = \'System\',\n}\n\ninterface BulkExportJob {\n  id: string;\n  connectionId: string;\n  exportType: BulkExportType;\n  status: BulkExportStatus;\n  statusUrl?: string;\n  outputUrls?: string[];\n  errorMessage?: string;\n  resourceTypes: string[];\n  since?: Date;\n  startedAt: Date;\n  completedAt?: Date;\n}\n\ninterface EnhancedSyncOptions {\n  includeStandard?: boolean;\n  includeEnhanced?: boolean;\n  resourceTypes?: EClinicalWorksResourceType[];\n  since?: Date;\n}\n\nexport class EClinicalWorksEnhancedService {\n  private fhirClient: FHIRClient;\n  private rateLimitDelay = 143; // 7 requests/second = 143ms between requests\n\n  constructor() {\n    this.fhirClient = new FHIRClient();\n  }\n\n  /**\n   * Initialize bulk data export\n   * Uses FHIR $export operation for efficient data retrieval\n   */\n  async initiateBulkExport(\n    connectionId: string,\n    options: {\n      exportType?: BulkExportType;\n      resourceTypes?: string[];\n      since?: Date;\n    } = {}\n  ): Promise<BulkExportJob> {\n    const connection = await this.getConnection(connectionId);\n    \n    const {\n      exportType = BulkExportType.PATIENT,\n      resourceTypes = [\n        \'Patient\',\n        \'Observation\',\n        \'Condition\',\n        \'MedicationRequest\',\n        \'AllergyIntolerance\',\n        \'Immunization\',\n        \'Procedure\',\n        \'DiagnosticReport\',\n        \'CarePlan\',\n        \'Encounter\',\n        \'Communication\',\n        \'Task\',\n      ],\n      since,\n    } = options;\n\n    // Construct export URL based on type\n    let exportUrl = `${connection.fhirEndpoint}`;\n    if (exportType === BulkExportType.PATIENT) {\n      exportUrl += `/Patient/$export`;\n    } else if (exportType === BulkExportType.GROUP) {\n      exportUrl += `/Group/${connection.userId}/$export`;\n    } else {\n      exportUrl += `/$export`;\n    }\n\n    // Add parameters\n    const params = new URLSearchParams();\n    params.append(\'_type\', resourceTypes.join(\',\'));\n    if (since) {\n      params.append(\'_since\', since.toISOString());\n    }\n\n    // Initiate export\n    const response = await fetch(`${exportUrl}?${params.toString()}`, {\n      method: \'GET\',\n      headers: {\n        \'Authorization\': `Bearer ${connection.accessToken}`,\n        \'Accept\': \'application/fhir+json\',\n        \'Prefer\': \'respond-async\',\n      },\n    });\n\n    if (response.status !== 202) {\n      throw new Error(`Bulk export initiation failed: ${response.statusText}`);\n    }\n\n    const statusUrl = response.headers.get(\'Content-Location\');\n    if (!statusUrl) {\n      throw new Error(\'No status URL returned from bulk export\');\n    }\n\n    // Create job record\n    const job = await prisma.bulkExportJob.create({\n      data: {\n        connectionId,\n        exportType,\n        status: BulkExportStatus.IN_PROGRESS,\n        statusUrl,\n        resourceTypes,\n        since,\n        startedAt: new Date(),\n      },\n    });\n\n    return job as any;\n  }\n\n  /**\n   * Check bulk export status\n   */\n  async checkBulkExportStatus(jobId: string): Promise<BulkExportJob> {\n    const job = await prisma.bulkExportJob.findUnique({\n      where: { id: jobId },\n    });\n\n    if (!job) {\n      throw new Error(\'Bulk export job not found\');\n    }\n\n    if (job.status === BulkExportStatus.COMPLETED || job.status === BulkExportStatus.FAILED) {\n      return job as any;\n    }\n\n    const connection = await this.getConnection(job.connectionId);\n\n    // Check status\n    const response = await fetch(job.statusUrl!, {\n      method: \'GET\',\n      headers: {\n        \'Authorization\': `Bearer ${connection.accessToken}`,\n        \'Accept\': \'application/fhir+json\',\n      },\n    });\n\n    if (response.status === 202) {\n      // Still in progress\n      return {\n        ...job,\n        status: BulkExportStatus.IN_PROGRESS,\n      } as any;\n    }\n\n    if (response.status === 200) {\n      // Completed\n      const result = await response.json();\n      \n      const outputUrls = result.output?.map((o: any) => o.url) || [];\n\n      const updatedJob = await prisma.bulkExportJob.update({\n        where: { id: jobId },\n        data: {\n          status: BulkExportStatus.COMPLETED,\n          outputUrls,\n          completedAt: new Date(),\n        },\n      });\n\n      return updatedJob as any;\n    }\n\n    // Failed\n    const updatedJob = await prisma.bulkExportJob.update({\n      where: { id: jobId },\n      data: {\n        status: BulkExportStatus.FAILED,\n        errorMessage: `Export failed with status ${response.status}`,\n        completedAt: new Date(),\n      },\n    });\n\n    return updatedJob as any;\n  }\n\n  /**\n   * Download and process bulk export data\n   */\n  async processBulkExportData(jobId: string): Promise<void> {\n    const job = await this.checkBulkExportStatus(jobId);\n\n    if (job.status !== BulkExportStatus.COMPLETED) {\n      throw new Error(`Job not completed. Current status: ${job.status}`);\n    }\n\n    const connection = await this.getConnection(job.connectionId);\n\n    // Process each output file\n    for (const url of job.outputUrls || []) {\n      await this.processNDJSONFile(url, connection.accessToken!, connection.userId);\n      \n      // Rate limiting\n      await this.delay(this.rateLimitDelay);\n    }\n  }\n\n  /**\n   * Process NDJSON file from bulk export\n   */\n  private async processNDJSONFile(\n    url: string,\n    accessToken: string,\n    userId: string\n  ): Promise<void> {\n    const response = await fetch(url, {\n      headers: {\n        \'Authorization\': `Bearer ${accessToken}`,\n      },\n    });\n\n    const text = await response.text();\n    const lines = text.split(\'\\n\').filter(line => line.trim());\n\n    for (const line of lines) {\n      try {\n        const resource = JSON.parse(line);\n        await this.storeResource(resource, userId);\n      } catch (error) {\n        console.error(\'Error processing NDJSON line:\', error);\n      }\n    }\n  }\n\n  /**\n   * Enhanced sync with eClinicalWorks-specific features\n   */\n  async enhancedSync(\n    connectionId: string,\n    options: EnhancedSyncOptions = {}\n  ): Promise<{\n    standardResources: number;\n    enhancedResources: number;\n    total: number;\n  }> {\n    const {\n      includeStandard = true,\n      includeEnhanced = true,\n      resourceTypes = Object.values(EClinicalWorksResourceType),\n      since,\n    } = options;\n\n    let standardCount = 0;\n    let enhancedCount = 0;\n\n    // Sync standard resources if requested\n    if (includeStandard) {\n      standardCount = await this.syncStandardResources(connectionId, since);\n    }\n\n    // Sync enhanced resources if requested\n    if (includeEnhanced) {\n      for (const resourceType of resourceTypes) {\n        const count = await this.syncEnhancedResource(connectionId, resourceType, since);\n        enhancedCount += count;\n        \n        // Rate limiting\n        await this.delay(this.rateLimitDelay);\n      }\n    }\n\n    return {\n      standardResources: standardCount,\n      enhancedResources: enhancedCount,\n      total: standardCount + enhancedCount,\n    };\n  }\n\n  /**\n   * Sync standard FHIR resources\n   */\n  private async syncStandardResources(\n    connectionId: string,\n    since?: Date\n  ): Promise<number> {\n    const connection = await this.getConnection(connectionId);\n    const resourceTypes = [\n      \'Patient\',\n      \'Observation\',\n      \'Condition\',\n      \'MedicationRequest\',\n      \'AllergyIntolerance\',\n      \'Immunization\',\n      \'Procedure\',\n    ];\n\n    let count = 0;\n    for (const resourceType of resourceTypes) {\n      const resources = await this.fhirClient.searchResources(\n        connection.fhirEndpoint!,\n        connection.accessToken!,\n        resourceType,\n        {\n          patient: connection.userId,\n          _since: since?.toISOString(),\n        }\n      );\n\n      for (const resource of resources) {\n        await this.storeResource(resource, connection.userId);\n        count++;\n      }\n\n      // Rate limiting\n      await this.delay(this.rateLimitDelay);\n    }\n\n    return count;\n  }\n\n  /**\n   * Sync enhanced resource type\n   */\n  private async syncEnhancedResource(\n    connectionId: string,\n    resourceType: EClinicalWorksResourceType,\n    since?: Date\n  ): Promise<number> {\n    const connection = await this.getConnection(connectionId);\n\n    const resources = await this.fhirClient.searchResources(\n      connection.fhirEndpoint!,\n      connection.accessToken!,\n      resourceType,\n      {\n        patient: connection.userId,\n        _since: since?.toISOString(),\n      }\n    );\n\n    let count = 0;\n    for (const resource of resources) {\n      await this.storeEnhancedResource(resource, connection.userId, resourceType);\n      count++;\n    }\n\n    return count;\n  }\n\n  /**\n   * Store enhanced resource with eClinicalWorks-specific data extraction\n   */\n  private async storeEnhancedResource(\n    resource: any,\n    userId: string,\n    resourceType: EClinicalWorksResourceType\n  ): Promise<void> {\n    // Store base resource\n    await this.storeResource(resource, userId);\n\n    // Extract and store eClinicalWorks-specific data\n    const specificData: any = {\n      resourceType,\n      resourceId: resource.id,\n    };\n\n    switch (resourceType) {\n      case EClinicalWorksResourceType.DIAGNOSTIC_REPORT:\n        specificData.reportType = resource.code?.text;\n        specificData.status = resource.status;\n        specificData.category = resource.category?.[0]?.coding?.[0]?.display;\n        specificData.effectiveDateTime = resource.effectiveDateTime;\n        specificData.issued = resource.issued;\n        specificData.conclusion = resource.conclusion;\n        specificData.presentedForm = resource.presentedForm?.map((pf: any) => ({\n          contentType: pf.contentType,\n          url: pf.url,\n          title: pf.title,\n        }));\n        break;\n\n      case EClinicalWorksResourceType.CARE_PLAN:\n        specificData.status = resource.status;\n        specificData.intent = resource.intent;\n        specificData.title = resource.title;\n        specificData.description = resource.description;\n        specificData.period = {\n          start: resource.period?.start,\n          end: resource.period?.end,\n        };\n        specificData.activities = resource.activity?.map((a: any) => ({\n          detail: {\n            description: a.detail?.description,\n            status: a.detail?.status,\n            scheduledTiming: a.detail?.scheduledTiming,\n          },\n        }));\n        break;\n\n      case EClinicalWorksResourceType.ENCOUNTER:\n        specificData.status = resource.status;\n        specificData.class = resource.class?.display;\n        specificData.type = resource.type?.[0]?.coding?.[0]?.display;\n        specificData.period = {\n          start: resource.period?.start,\n          end: resource.period?.end,\n        };\n        specificData.reasonCode = resource.reasonCode?.map((rc: any) => \n          rc.coding?.[0]?.display\n        );\n        specificData.diagnosis = resource.diagnosis?.map((d: any) => ({\n          condition: d.condition?.display,\n          use: d.use?.coding?.[0]?.display,\n        }));\n        specificData.hospitalization = resource.hospitalization;\n        break;\n\n      case EClinicalWorksResourceType.COMMUNICATION:\n        specificData.status = resource.status;\n        specificData.category = resource.category?.[0]?.coding?.[0]?.display;\n        specificData.priority = resource.priority;\n        specificData.medium = resource.medium?.map((m: any) => \n          m.coding?.[0]?.display\n        );\n        specificData.subject = resource.subject?.display;\n        specificData.topic = resource.topic?.text;\n        specificData.sent = resource.sent;\n        specificData.received = resource.received;\n        specificData.payload = resource.payload?.map((p: any) => ({\n          contentString: p.contentString,\n          contentAttachment: p.contentAttachment,\n        }));\n        break;\n\n      case EClinicalWorksResourceType.TASK:\n        specificData.status = resource.status;\n        specificData.intent = resource.intent;\n        specificData.priority = resource.priority;\n        specificData.code = resource.code?.coding?.[0]?.display;\n        specificData.description = resource.description;\n        specificData.authoredOn = resource.authoredOn;\n        specificData.lastModified = resource.lastModified;\n        specificData.executionPeriod = {\n          start: resource.executionPeriod?.start,\n          end: resource.executionPeriod?.end,\n        };\n        specificData.note = resource.note?.map((n: any) => n.text);\n        break;\n    }\n\n    // Store eClinicalWorks-specific data\n    await prisma.eClinicalWorksSpecificData.upsert({\n      where: {\n        resourceId: resource.id,\n      },\n      update: specificData,\n      create: {\n        ...specificData,\n        userId,\n      },\n    });\n  }\n\n  /**\n   * Store standard FHIR resource\n   */\n  private async storeResource(resource: any, userId: string): Promise<void> {\n    await prisma.fHIRResource.upsert({\n      where: {\n        resourceId_resourceType: {\n          resourceId: resource.id,\n          resourceType: resource.resourceType,\n        },\n      },\n      update: {\n        data: resource,\n        lastUpdated: new Date(),\n      },\n      create: {\n        resourceId: resource.id,\n        resourceType: resource.resourceType,\n        data: resource,\n        userId,\n      },\n    });\n  }\n\n  /**\n   * Get EHR connection\n   */\n  private async getConnection(connectionId: string) {\n    const connection = await prisma.eHRConnection.findUnique({\n      where: { id: connectionId },\n      include: { user: true },\n    });\n\n    if (!connection) {\n      throw new Error(\'Connection not found\');\n    }\n\n    return connection;\n  }\n\n  /**\n   * Rate limiting delay\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get eClinicalWorks capabilities\n   */\n  async getCapabilities(connectionId: string): Promise<{\n    bulkExport: boolean;\n    diagnosticReports: boolean;\n    carePlans: boolean;\n    encounters: boolean;\n    communications: boolean;\n    tasks: boolean;\n    rateLimit: string;\n  }> {\n    return {\n      bulkExport: true,\n      diagnosticReports: true,\n      carePlans: true,\n      encounters: true,\n      communications: true,\n      tasks: true,\n      rateLimit: \'7 requests/second\',\n    };\n  }\n}\n\n// Export singleton instance\nlet instance: EClinicalWorksEnhancedService | null = null;\n\nexport function getEClinicalWorksEnhancedService(): EClinicalWorksEnhancedService {\n  if (!instance) {\n    instance = new EClinicalWorksEnhancedService();\n  }\n  return instance;\n}\n</create-file>\n</function_calls>'}