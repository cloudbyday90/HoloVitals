{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/lib/services/ocr.service.ts">\nimport pdf from \'pdf-parse\';\nimport { createWorker } from \'tesseract.js\';\nimport { DocumentType, ProcessingResult, TestResult } from \'@/lib/types\';\n\nexport class OCRService {\n  /**\n   * Extract text from PDF buffer\n   */\n  async extractTextFromPDF(buffer: Buffer): Promise<string> {\n    try {\n      const data = await pdf(buffer);\n      return data.text;\n    } catch (error) {\n      console.error(\'PDF extraction error:\', error);\n      throw new Error(\'Failed to extract text from PDF\');\n    }\n  }\n\n  /**\n   * Extract text from image using Tesseract OCR\n   */\n  async extractTextFromImage(buffer: Buffer): Promise<{ text: string; confidence: number }> {\n    const worker = await createWorker(\'eng\');\n    \n    try {\n      const { data } = await worker.recognize(buffer);\n      await worker.terminate();\n      \n      return {\n        text: data.text,\n        confidence: data.confidence\n      };\n    } catch (error) {\n      await worker.terminate();\n      console.error(\'Image OCR error:\', error);\n      throw new Error(\'Failed to extract text from image\');\n    }\n  }\n\n  /**\n   * Classify document type based on content\n   */\n  async classifyDocument(text: string): Promise<DocumentType> {\n    const lowerText = text.toLowerCase();\n    \n    // Bloodwork indicators\n    if (\n      lowerText.includes(\'hemoglobin\') ||\n      lowerText.includes(\'wbc\') ||\n      lowerText.includes(\'platelet\') ||\n      lowerText.includes(\'glucose\') ||\n      lowerText.includes(\'cholesterol\') ||\n      lowerText.includes(\'lab results\') ||\n      lowerText.includes(\'blood test\')\n    ) {\n      return \'bloodwork\';\n    }\n    \n    // Imaging indicators\n    if (\n      lowerText.includes(\'x-ray\') ||\n      lowerText.includes(\'mri\') ||\n      lowerText.includes(\'ct scan\') ||\n      lowerText.includes(\'ultrasound\') ||\n      lowerText.includes(\'radiology\') ||\n      lowerText.includes(\'imaging\')\n    ) {\n      return \'imaging\';\n    }\n    \n    // Aftercare indicators\n    if (\n      lowerText.includes(\'aftercare\') ||\n      lowerText.includes(\'post-operative\') ||\n      lowerText.includes(\'follow-up\') ||\n      lowerText.includes(\'recovery instructions\')\n    ) {\n      return \'aftercare\';\n    }\n    \n    // Prescription indicators\n    if (\n      lowerText.includes(\'prescription\') ||\n      lowerText.includes(\'medication\') ||\n      lowerText.includes(\'rx\') ||\n      lowerText.includes(\'dosage\')\n    ) {\n      return \'prescription\';\n    }\n    \n    // Discharge indicators\n    if (\n      lowerText.includes(\'discharge\') ||\n      lowerText.includes(\'discharge summary\')\n    ) {\n      return \'discharge\';\n    }\n    \n    return \'other\';\n  }\n\n  /**\n   * Parse bloodwork results from text\n   */\n  parseBloodwork(text: string): TestResult[] {\n    const results: TestResult[] = [];\n    const lines = text.split(\'\\n\');\n    \n    // Common patterns for lab results\n    // Pattern 1: "Test Name: Value Unit (Min-Max)"\n    // Pattern 2: "Test Name Value Unit Min-Max"\n    \n    for (const line of lines) {\n      // Try pattern with colon\n      let match = line.match(\n        /([A-Za-z0-9\\s\\-\\/]+):\\s*([\\d.]+)\\s*([A-Za-z\\/%]+)?\\s*\\(?([\\d.-]+)?\\s*-?\\s*([\\d.]+)?\\)?/\n      );\n      \n      if (!match) {\n        // Try pattern without colon\n        match = line.match(\n          /([A-Za-z0-9\\s\\-\\/]+)\\s+([\\d.]+)\\s+([A-Za-z\\/%]+)\\s+([\\d.-]+)\\s*-\\s*([\\d.]+)/\n        );\n      }\n      \n      if (match) {\n        const testName = match[1].trim();\n        const value = parseFloat(match[2]);\n        const unit = match[3] || \'\';\n        const referenceMin = match[4] ? parseFloat(match[4]) : undefined;\n        const referenceMax = match[5] ? parseFloat(match[5]) : undefined;\n        \n        const isAbnormal = this.checkAbnormal(value, referenceMin, referenceMax);\n        \n        results.push({\n          testName,\n          value,\n          unit,\n          referenceMin,\n          referenceMax,\n          isAbnormal\n        });\n      }\n    }\n    \n    return results;\n  }\n\n  /**\n   * Check if a value is abnormal based on reference range\n   */\n  private checkAbnormal(\n    value: number,\n    min?: number,\n    max?: number\n  ): boolean {\n    if (min !== undefined && value < min) return true;\n    if (max !== undefined && value > max) return true;\n    return false;\n  }\n\n  /**\n   * Extract dates from text\n   */\n  extractDates(text: string): Date[] {\n    const dates: Date[] = [];\n    \n    // Common date patterns\n    const patterns = [\n      /\\d{1,2}\\/\\d{1,2}\\/\\d{4}/g,  // MM/DD/YYYY\n      /\\d{4}-\\d{2}-\\d{2}/g,         // YYYY-MM-DD\n      /\\d{1,2}-\\d{1,2}-\\d{4}/g,     // MM-DD-YYYY\n    ];\n    \n    for (const pattern of patterns) {\n      const matches = text.match(pattern);\n      if (matches) {\n        for (const match of matches) {\n          const date = new Date(match);\n          if (!isNaN(date.getTime())) {\n            dates.push(date);\n          }\n        }\n      }\n    }\n    \n    return dates;\n  }\n\n  /**\n   * Extract key-value pairs from text\n   */\n  extractKeyValuePairs(text: string): Record<string, string> {\n    const pairs: Record<string, string> = {};\n    const lines = text.split(\'\\n\');\n    \n    for (const line of lines) {\n      const match = line.match(/^([^:]+):\\s*(.+)$/);\n      if (match) {\n        const key = match[1].trim();\n        const value = match[2].trim();\n        pairs[key] = value;\n      }\n    }\n    \n    return pairs;\n  }\n\n  /**\n   * Process document and extract structured data\n   */\n  async processDocument(\n    buffer: Buffer,\n    mimeType: string\n  ): Promise<ProcessingResult> {\n    try {\n      let text: string;\n      let confidence: number | undefined;\n      \n      // Extract text based on file type\n      if (mimeType === \'application/pdf\') {\n        text = await this.extractTextFromPDF(buffer);\n      } else if (mimeType.startsWith(\'image/\')) {\n        const result = await this.extractTextFromImage(buffer);\n        text = result.text;\n        confidence = result.confidence;\n      } else {\n        throw new Error(\'Unsupported file type\');\n      }\n      \n      // Classify document type\n      const documentType = await this.classifyDocument(text);\n      \n      // Extract structured data based on type\n      let dataPoints = 0;\n      if (documentType === \'bloodwork\') {\n        const results = this.parseBloodwork(text);\n        dataPoints = results.length;\n      }\n      \n      return {\n        success: true,\n        documentType,\n        dataPoints\n      };\n    } catch (error) {\n      console.error(\'Document processing error:\', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : \'Unknown error\'\n      };\n    }\n  }\n}\n\nexport const ocrService = new OCRService();\n</create-file>\n</function_calls>'}