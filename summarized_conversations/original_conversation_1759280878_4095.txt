{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="medical-analysis-platform/app/api/costs/route.ts">\n/**\n * Cost API Endpoints\n * Protected - OWNER only\n */\n\nimport { NextRequest, NextResponse } from \'next/server\';\nimport { protectCostEndpoint } from \'@/lib/middleware/auth\';\nimport { prisma } from \'@/lib/prisma\';\n\n// ============================================================================\n// GET - Get cost summary\n// ============================================================================\n\nexport async function GET(req: NextRequest) {\n  // Protect endpoint - OWNER only\n  const user = await protectCostEndpoint(req);\n  if (user instanceof NextResponse) {\n    return user; // Return error response\n  }\n\n  try {\n    const { searchParams } = new URL(req.url);\n    const timeRange = searchParams.get(\'range\') || \'7d\';\n\n    // Calculate date range\n    const now = new Date();\n    let startDate: Date;\n\n    switch (timeRange) {\n      case \'7d\':\n        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n        break;\n      case \'30d\':\n        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n        break;\n      case \'90d\':\n        startDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);\n        break;\n      default:\n        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    }\n\n    // Get cost data from different services\n    const [chatbotCosts, optimizerCosts, queueCosts, instanceCosts] = await Promise.all([\n      // Chatbot costs\n      prisma.conversation.aggregate({\n        where: {\n          createdAt: { gte: startDate },\n        },\n        _sum: {\n          totalCost: true,\n          totalTokens: true,\n        },\n        _count: true,\n      }),\n\n      // Optimizer costs (savings)\n      prisma.contextOptimization.aggregate({\n        where: {\n          createdAt: { gte: startDate },\n        },\n        _sum: {\n          costSavings: true,\n          tokensReduced: true,\n        },\n        _count: true,\n      }),\n\n      // Queue costs (from analysis tasks)\n      prisma.analysisTask.aggregate({\n        where: {\n          createdAt: { gte: startDate },\n          status: \'COMPLETED\',\n        },\n        _count: true,\n      }),\n\n      // Instance costs\n      prisma.cloudInstance.aggregate({\n        where: {\n          createdAt: { gte: startDate },\n        },\n        _sum: {\n          totalCost: true,\n        },\n        _count: true,\n      }),\n    ]);\n\n    // Calculate totals\n    const totalCosts = {\n      chatbot: chatbotCosts._sum.totalCost || 0,\n      optimizer: 0, // Optimizer saves money, doesn\'t cost\n      queue: (queueCosts._count || 0) * 0.05, // Estimated $0.05 per task\n      instances: instanceCosts._sum.totalCost || 0,\n    };\n\n    const totalSavings = {\n      optimizer: optimizerCosts._sum.costSavings || 0,\n      instances: 0, // Calculate based on ephemeral vs always-on\n    };\n\n    // Calculate instance savings (90% vs always-on)\n    const instanceHours = instanceCosts._count || 0;\n    const alwaysOnCost = instanceHours * 24 * 1.5; // $1.50/hour always-on\n    const actualCost = totalCosts.instances;\n    totalSavings.instances = Math.max(0, alwaysOnCost - actualCost);\n\n    const response = {\n      timeRange,\n      startDate: startDate.toISOString(),\n      endDate: now.toISOString(),\n      costs: {\n        chatbot: totalCosts.chatbot,\n        optimizer: totalCosts.optimizer,\n        queue: totalCosts.queue,\n        instances: totalCosts.instances,\n        total: Object.values(totalCosts).reduce((a, b) => a + b, 0),\n      },\n      savings: {\n        optimizer: totalSavings.optimizer,\n        instances: totalSavings.instances,\n        total: Object.values(totalSavings).reduce((a, b) => a + b, 0),\n      },\n      metrics: {\n        totalConversations: chatbotCosts._count,\n        totalTokens: chatbotCosts._sum.totalTokens || 0,\n        tokensReduced: optimizerCosts._sum.tokensReduced || 0,\n        optimizationsPerformed: optimizerCosts._count,\n        tasksCompleted: queueCosts._count,\n        instancesProvisioned: instanceCosts._count,\n      },\n    };\n\n    return NextResponse.json(response);\n  } catch (error) {\n    console.error(\'Error fetching cost summary:\', error);\n    return NextResponse.json(\n      { error: \'Failed to fetch cost summary\' },\n      { status: 500 }\n    );\n  }\n}\n</create-file>\n</function_calls>'}