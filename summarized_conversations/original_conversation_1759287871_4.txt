{'role': 'assistant', 'content': 'Now let\'s create the Data Sync Service that handles syncing data from EHR systems:\n\n<function_calls>\n<create-file file_path="medical-analysis-platform/lib/services/EHRSyncService.ts">\n/**\n * EHR Sync Service\n * \n * Handles synchronization of FHIR data from EHR systems\n * Supports incremental and full sync\n */\n\nimport { PrismaClient } from \'@prisma/client\';\nimport { EHRConnectionService } from \'./EHRConnectionService\';\nimport { FHIRClient } from \'../fhir/FHIRClient\';\nimport { PricingService } from \'./PricingService\';\nimport { TokenService } from \'./TokenService\';\n\nconst prisma = new PrismaClient();\n\nexport interface SyncOptions {\n  connectionId: string;\n  syncType?: \'incremental\' | \'full\';\n  resourceTypes?: string[];\n  downloadDocuments?: boolean;\n}\n\nexport interface SyncProgress {\n  syncId: string;\n  status: string;\n  resourcesQueried: number;\n  resourcesCreated: number;\n  resourcesUpdated: number;\n  documentsDownloaded: number;\n  totalBytesDownloaded: number;\n  tokensEstimated: number;\n  currentResource?: string;\n}\n\nexport class EHRSyncService {\n  /**\n   * Start a sync operation\n   */\n  static async startSync(options: SyncOptions): Promise<string> {\n    const connection = await prisma.eHRConnection.findUnique({\n      where: { id: options.connectionId },\n    });\n\n    if (!connection) {\n      throw new Error(\'Connection not found\');\n    }\n\n    if (connection.status !== \'ACTIVE\') {\n      throw new Error(\'Connection is not active\');\n    }\n\n    // Create sync history record\n    const syncHistory = await prisma.syncHistory.create({\n      data: {\n        connectionId: options.connectionId,\n        status: \'QUEUED\',\n        syncType: options.syncType || \'incremental\',\n      },\n    });\n\n    // Start sync in background (in production, use a job queue)\n    this.performSync(syncHistory.id, options).catch(error => {\n      console.error(\'Sync failed:\', error);\n      prisma.syncHistory.update({\n        where: { id: syncHistory.id },\n        data: {\n          status: \'FAILED\',\n          errorMessage: error.message,\n          completedAt: new Date(),\n        },\n      });\n    });\n\n    return syncHistory.id;\n  }\n\n  /**\n   * Perform the actual sync operation\n   */\n  private static async performSync(syncId: string, options: SyncOptions): Promise<void> {\n    const startTime = Date.now();\n\n    // Update status to syncing\n    await prisma.syncHistory.update({\n      where: { id: syncId },\n      data: {\n        status: \'SYNCING\',\n        startedAt: new Date(),\n      },\n    });\n\n    try {\n      // Get FHIR client\n      const fhirClient = await EHRConnectionService.getFHIRClient(options.connectionId);\n      \n      const connection = await prisma.eHRConnection.findUnique({\n        where: { id: options.connectionId },\n      });\n\n      if (!connection?.patientId) {\n        throw new Error(\'No patient ID available\');\n      }\n\n      // Define resource types to sync\n      const resourceTypes = options.resourceTypes || [\n        \'DocumentReference\',\n        \'Observation\',\n        \'Condition\',\n        \'MedicationRequest\',\n        \'AllergyIntolerance\',\n        \'Immunization\',\n        \'Procedure\',\n      ];\n\n      let totalQueried = 0;\n      let totalCreated = 0;\n      let totalUpdated = 0;\n      let totalSkipped = 0;\n      let totalFailed = 0;\n      let documentsDownloaded = 0;\n      let totalBytesDownloaded = 0;\n\n      // Sync each resource type\n      for (const resourceType of resourceTypes) {\n        try {\n          const result = await this.syncResourceType(\n            fhirClient,\n            connection.id,\n            connection.patientId,\n            resourceType,\n            options.syncType === \'full\' ? undefined : connection.lastSyncAt || undefined,\n            options.downloadDocuments ?? true\n          );\n\n          totalQueried += result.queried;\n          totalCreated += result.created;\n          totalUpdated += result.updated;\n          totalSkipped += result.skipped;\n          totalFailed += result.failed;\n          documentsDownloaded += result.documentsDownloaded;\n          totalBytesDownloaded += result.bytesDownloaded;\n        } catch (error: any) {\n          console.error(`Failed to sync ${resourceType}:`, error);\n          totalFailed++;\n        }\n      }\n\n      // Calculate duration\n      const duration = Math.floor((Date.now() - startTime) / 1000);\n\n      // Update sync history\n      await prisma.syncHistory.update({\n        where: { id: syncId },\n        data: {\n          status: \'COMPLETED\',\n          completedAt: new Date(),\n          duration,\n          resourcesQueried: totalQueried,\n          resourcesCreated: totalCreated,\n          resourcesUpdated: totalUpdated,\n          resourcesSkipped: totalSkipped,\n          resourcesFailed: totalFailed,\n          documentsDownloaded,\n          totalBytesDownloaded: BigInt(totalBytesDownloaded),\n        },\n      });\n\n      // Update connection sync schedule\n      await EHRConnectionService.updateSyncSchedule(options.connectionId);\n\n    } catch (error: any) {\n      const duration = Math.floor((Date.now() - startTime) / 1000);\n\n      await prisma.syncHistory.update({\n        where: { id: syncId },\n        data: {\n          status: \'FAILED\',\n          completedAt: new Date(),\n          duration,\n          errorMessage: error.message,\n          errorDetails: JSON.stringify({\n            name: error.name,\n            stack: error.stack,\n          }),\n        },\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Sync a specific resource type\n   */\n  private static async syncResourceType(\n    fhirClient: FHIRClient,\n    connectionId: string,\n    patientId: string,\n    resourceType: string,\n    since?: Date,\n    downloadDocuments: boolean = true\n  ): Promise<{\n    queried: number;\n    created: number;\n    updated: number;\n    skipped: number;\n    failed: number;\n    documentsDownloaded: number;\n    bytesDownloaded: number;\n  }> {\n    let queried = 0;\n    let created = 0;\n    let updated = 0;\n    let skipped = 0;\n    let failed = 0;\n    let documentsDownloaded = 0;\n    let bytesDownloaded = 0;\n\n    try {\n      // Build search parameters\n      const searchParams: any = {};\n      if (since) {\n        searchParams._lastUpdated = `gt${since.toISOString()}`;\n      }\n\n      // Search for resources\n      let resources: any[] = [];\n      \n      switch (resourceType) {\n        case \'DocumentReference\':\n          resources = await fhirClient.getDocumentReferences(patientId, searchParams);\n          break;\n        case \'Observation\':\n          resources = await fhirClient.getObservations(patientId, searchParams);\n          break;\n        case \'Condition\':\n          resources = await fhirClient.getConditions(patientId, searchParams);\n          break;\n        case \'MedicationRequest\':\n          resources = await fhirClient.getMedicationRequests(patientId, searchParams);\n          break;\n        case \'AllergyIntolerance\':\n          resources = await fhirClient.getAllergyIntolerances(patientId, searchParams);\n          break;\n        case \'Immunization\':\n          resources = await fhirClient.getImmunizations(patientId, searchParams);\n          break;\n        case \'Procedure\':\n          resources = await fhirClient.getProcedures(patientId, searchParams);\n          break;\n        default:\n          resources = await fhirClient.searchAll(resourceType, {\n            patient: patientId,\n            ...searchParams,\n          });\n      }\n\n      queried = resources.length;\n\n      // Process each resource\n      for (const resource of resources) {\n        try {\n          const result = await this.saveResource(\n            connectionId,\n            resource,\n            resourceType,\n            fhirClient,\n            downloadDocuments\n          );\n\n          if (result.created) created++;\n          if (result.updated) updated++;\n          if (result.skipped) skipped++;\n          if (result.documentDownloaded) {\n            documentsDownloaded++;\n            bytesDownloaded += result.bytesDownloaded || 0;\n          }\n        } catch (error) {\n          console.error(`Failed to save resource ${resource.id}:`, error);\n          failed++;\n        }\n      }\n    } catch (error) {\n      console.error(`Failed to sync resource type ${resourceType}:`, error);\n      throw error;\n    }\n\n    return {\n      queried,\n      created,\n      updated,\n      skipped,\n      failed,\n      documentsDownloaded,\n      bytesDownloaded,\n    };\n  }\n\n  /**\n   * Save a FHIR resource to database\n   */\n  private static async saveResource(\n    connectionId: string,\n    resource: any,\n    resourceType: string,\n    fhirClient: FHIRClient,\n    downloadDocuments: boolean\n  ): Promise<{\n    created: boolean;\n    updated: boolean;\n    skipped: boolean;\n    documentDownloaded: boolean;\n    bytesDownloaded?: number;\n  }> {\n    const fhirId = resource.id;\n    if (!fhirId) {\n      return { created: false, updated: false, skipped: true, documentDownloaded: false };\n    }\n\n    // Check if resource already exists\n    const existing = await prisma.fHIRResource.findUnique({\n      where: {\n        connectionId_fhirId_resourceType: {\n          connectionId,\n          fhirId,\n          resourceType: resourceType as any,\n        },\n      },\n    });\n\n    // Extract metadata\n    const metadata = this.extractMetadata(resource, resourceType);\n\n    // Handle document download\n    let documentDownloaded = false;\n    let bytesDownloaded = 0;\n    let localFilePath: string | undefined;\n\n    if (resourceType === \'DocumentReference\' && downloadDocuments) {\n      try {\n        const buffer = await fhirClient.downloadDocument(resource);\n        bytesDownloaded = buffer.length;\n        \n        // Save document to file system (in production, use cloud storage)\n        const fileName = `${connectionId}_${fhirId}_${Date.now()}.pdf`;\n        localFilePath = `/uploads/ehr/${fileName}`;\n        \n        // TODO: Actually save the file\n        // fs.writeFileSync(localFilePath, buffer);\n        \n        documentDownloaded = true;\n      } catch (error) {\n        console.error(\'Failed to download document:\', error);\n      }\n    }\n\n    if (existing) {\n      // Update existing resource\n      await prisma.fHIRResource.update({\n        where: { id: existing.id },\n        data: {\n          rawData: JSON.stringify(resource),\n          ...metadata,\n          documentDownloaded: documentDownloaded || existing.documentDownloaded,\n          localFilePath: localFilePath || existing.localFilePath,\n          updatedAt: new Date(),\n        },\n      });\n\n      return {\n        created: false,\n        updated: true,\n        skipped: false,\n        documentDownloaded,\n        bytesDownloaded,\n      };\n    } else {\n      // Create new resource\n      await prisma.fHIRResource.create({\n        data: {\n          connectionId,\n          resourceType: resourceType as any,\n          fhirId,\n          rawData: JSON.stringify(resource),\n          ...metadata,\n          documentDownloaded,\n          localFilePath,\n        },\n      });\n\n      return {\n        created: true,\n        updated: false,\n        skipped: false,\n        documentDownloaded,\n        bytesDownloaded,\n      };\n    }\n  }\n\n  /**\n   * Extract metadata from FHIR resource\n   */\n  private static extractMetadata(resource: any, resourceType: string): any {\n    const metadata: any = {\n      title: undefined,\n      description: undefined,\n      date: undefined,\n      category: undefined,\n      status: resource.status,\n      contentType: undefined,\n      contentUrl: undefined,\n      contentSize: undefined,\n    };\n\n    switch (resourceType) {\n      case \'DocumentReference\':\n        metadata.title = resource.description || resource.type?.text;\n        metadata.date = resource.date ? new Date(resource.date) : undefined;\n        metadata.category = resource.category?.[0]?.text;\n        \n        const content = resource.content?.[0];\n        if (content?.attachment) {\n          metadata.contentType = content.attachment.contentType;\n          metadata.contentUrl = content.attachment.url;\n          metadata.contentSize = content.attachment.size;\n        }\n        break;\n\n      case \'Observation\':\n        metadata.title = resource.code?.text || resource.code?.coding?.[0]?.display;\n        metadata.date = resource.effectiveDateTime ? new Date(resource.effectiveDateTime) : undefined;\n        metadata.category = resource.category?.[0]?.text;\n        metadata.description = resource.valueString || resource.valueQuantity?.value?.toString();\n        break;\n\n      case \'Condition\':\n        metadata.title = resource.code?.text || resource.code?.coding?.[0]?.display;\n        metadata.date = resource.recordedDate ? new Date(resource.recordedDate) : undefined;\n        metadata.category = resource.category?.[0]?.text;\n        break;\n\n      case \'MedicationRequest\':\n        metadata.title = resource.medicationCodeableConcept?.text || \n                        resource.medicationCodeableConcept?.coding?.[0]?.display;\n        metadata.date = resource.authoredOn ? new Date(resource.authoredOn) : undefined;\n        break;\n\n      case \'AllergyIntolerance\':\n        metadata.title = resource.code?.text || resource.code?.coding?.[0]?.display;\n        metadata.date = resource.recordedDate ? new Date(resource.recordedDate) : undefined;\n        metadata.category = resource.category?.[0];\n        break;\n\n      case \'Immunization\':\n        metadata.title = resource.vaccineCode?.text || resource.vaccineCode?.coding?.[0]?.display;\n        metadata.date = resource.occurrenceDateTime ? new Date(resource.occurrenceDateTime) : undefined;\n        break;\n\n      case \'Procedure\':\n        metadata.title = resource.code?.text || resource.code?.coding?.[0]?.display;\n        metadata.date = resource.performedDateTime ? new Date(resource.performedDateTime) : undefined;\n        break;\n    }\n\n    return metadata;\n  }\n\n  /**\n   * Get sync status\n   */\n  static async getSyncStatus(syncId: string): Promise<any> {\n    return prisma.syncHistory.findUnique({\n      where: { id: syncId },\n    });\n  }\n\n  /**\n   * Get sync history for a connection\n   */\n  static async getSyncHistory(connectionId: string, limit: number = 10): Promise<any[]> {\n    return prisma.syncHistory.findMany({\n      where: { connectionId },\n      orderBy: { createdAt: \'desc\' },\n      take: limit,\n    });\n  }\n\n  /**\n   * Cancel an ongoing sync\n   */\n  static async cancelSync(syncId: string): Promise<any> {\n    return prisma.syncHistory.update({\n      where: { id: syncId },\n      data: {\n        status: \'CANCELLED\',\n        completedAt: new Date(),\n      },\n    });\n  }\n\n  /**\n   * Get synced resources for a connection\n   */\n  static async getSyncedResources(\n    connectionId: string,\n    resourceType?: string,\n    limit: number = 50,\n    offset: number = 0\n  ): Promise<{ resources: any[]; total: number }> {\n    const where: any = { connectionId };\n    if (resourceType) {\n      where.resourceType = resourceType;\n    }\n\n    const [resources, total] = await Promise.all([\n      prisma.fHIRResource.findMany({\n        where,\n        orderBy: { date: \'desc\' },\n        take: limit,\n        skip: offset,\n      }),\n      prisma.fHIRResource.count({ where }),\n    ]);\n\n    return { resources, total };\n  }\n}\n</create-file>\n</function_calls>'}